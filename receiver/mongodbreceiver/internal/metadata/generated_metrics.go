// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"go.opentelemetry.io/collector/config"
	"go.opentelemetry.io/collector/pdata/pmetric"
)

// Type is the component type name.
const Type config.Type = "mongodbreceiver"

// MetricIntf is an interface to generically interact with generated metric.
type MetricIntf interface {
	Name() string
	New() pmetric.Metric
	Init(metric pmetric.Metric)
}

// Intentionally not exposing this so that it is opaque and can change freely.
type metricImpl struct {
	name     string
	initFunc func(pmetric.Metric)
}

// Name returns the metric name.
func (m *metricImpl) Name() string {
	return m.name
}

// New creates a metric object preinitialized.
func (m *metricImpl) New() pmetric.Metric {
	metric := pmetric.NewMetric()
	m.Init(metric)
	return metric
}

// Init initializes the provided metric object.
func (m *metricImpl) Init(metric pmetric.Metric) {
	m.initFunc(metric)
}

type metricStruct struct {
	MongodbCacheOperations        MetricIntf
	MongodbCollectionCount        MetricIntf
	MongodbConnectionCount        MetricIntf
	MongodbCursorCount            MetricIntf
	MongodbCursorTimeoutCount     MetricIntf
	MongodbDataSize               MetricIntf
	MongodbDatabaseCount          MetricIntf
	MongodbDocumentOperationCount MetricIntf
	MongodbExtentCount            MetricIntf
	MongodbGlobalLockTime         MetricIntf
	MongodbIndexAccessCount       MetricIntf
	MongodbIndexCount             MetricIntf
	MongodbIndexSize              MetricIntf
	MongodbMemoryUsage            MetricIntf
	MongodbNetworkIoReceive       MetricIntf
	MongodbNetworkIoTransmit      MetricIntf
	MongodbNetworkRequestCount    MetricIntf
	MongodbObjectCount            MetricIntf
	MongodbOperationCount         MetricIntf
	MongodbOperationScanAndOrder  MetricIntf
	MongodbOperationTime          MetricIntf
	MongodbOperationWriteConflict MetricIntf
	MongodbSessionCount           MetricIntf
	MongodbStorageSize            MetricIntf
}

// Names returns a list of all the metric name strings.
func (m *metricStruct) Names() []string {
	return []string{
		"mongodb.cache.operations",
		"mongodb.collection.count",
		"mongodb.connection.count",
		"mongodb.cursor.count",
		"mongodb.cursor.timeout.count",
		"mongodb.data.size",
		"mongodb.database.count",
		"mongodb.document.operation.count",
		"mongodb.extent.count",
		"mongodb.global_lock.time",
		"mongodb.index.access.count",
		"mongodb.index.count",
		"mongodb.index.size",
		"mongodb.memory.usage",
		"mongodb.network.io.receive",
		"mongodb.network.io.transmit",
		"mongodb.network.request.count",
		"mongodb.object.count",
		"mongodb.operation.count",
		"mongodb.operation.scanAndOrder",
		"mongodb.operation.time",
		"mongodb.operation.writeConflict",
		"mongodb.session.count",
		"mongodb.storage.size",
	}
}

var metricsByName = map[string]MetricIntf{
	"mongodb.cache.operations":         Metrics.MongodbCacheOperations,
	"mongodb.collection.count":         Metrics.MongodbCollectionCount,
	"mongodb.connection.count":         Metrics.MongodbConnectionCount,
	"mongodb.cursor.count":             Metrics.MongodbCursorCount,
	"mongodb.cursor.timeout.count":     Metrics.MongodbCursorTimeoutCount,
	"mongodb.data.size":                Metrics.MongodbDataSize,
	"mongodb.database.count":           Metrics.MongodbDatabaseCount,
	"mongodb.document.operation.count": Metrics.MongodbDocumentOperationCount,
	"mongodb.extent.count":             Metrics.MongodbExtentCount,
	"mongodb.global_lock.time":         Metrics.MongodbGlobalLockTime,
	"mongodb.index.access.count":       Metrics.MongodbIndexAccessCount,
	"mongodb.index.count":              Metrics.MongodbIndexCount,
	"mongodb.index.size":               Metrics.MongodbIndexSize,
	"mongodb.memory.usage":             Metrics.MongodbMemoryUsage,
	"mongodb.network.io.receive":       Metrics.MongodbNetworkIoReceive,
	"mongodb.network.io.transmit":      Metrics.MongodbNetworkIoTransmit,
	"mongodb.network.request.count":    Metrics.MongodbNetworkRequestCount,
	"mongodb.object.count":             Metrics.MongodbObjectCount,
	"mongodb.operation.count":          Metrics.MongodbOperationCount,
	"mongodb.operation.scanAndOrder":   Metrics.MongodbOperationScanAndOrder,
	"mongodb.operation.time":           Metrics.MongodbOperationTime,
	"mongodb.operation.writeConflict":  Metrics.MongodbOperationWriteConflict,
	"mongodb.session.count":            Metrics.MongodbSessionCount,
	"mongodb.storage.size":             Metrics.MongodbStorageSize,
}

func (m *metricStruct) ByName(n string) MetricIntf {
	return metricsByName[n]
}

// Metrics contains a set of methods for each metric that help with
// manipulating those metrics.
var Metrics = &metricStruct{
	&metricImpl{
		"mongodb.cache.operations",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.cache.operations")
			metric.SetDescription("The number of cache operations of the instance.")
			metric.SetUnit("{operations}")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(true)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.collection.count",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.collection.count")
			metric.SetDescription("The number of collections.")
			metric.SetUnit("{collections}")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(false)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.connection.count",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.connection.count")
			metric.SetDescription("The number of connections.")
			metric.SetUnit("{connections}")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(false)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.cursor.count",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.cursor.count")
			metric.SetDescription("The number of open cursors maintained for clients.")
			metric.SetUnit("{cursors}")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(false)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.cursor.timeout.count",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.cursor.timeout.count")
			metric.SetDescription("The number of cursors that have timed out.")
			metric.SetUnit("{cursors}")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(false)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.data.size",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.data.size")
			metric.SetDescription("The size of the collection. Data compression does not affect this value.")
			metric.SetUnit("By")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(false)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.database.count",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.database.count")
			metric.SetDescription("The number of existing databases.")
			metric.SetUnit("{databases}")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(false)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.document.operation.count",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.document.operation.count")
			metric.SetDescription("The number of document operations executed.")
			metric.SetUnit("{documents}")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(false)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.extent.count",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.extent.count")
			metric.SetDescription("The number of extents.")
			metric.SetUnit("{extents}")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(false)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.global_lock.time",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.global_lock.time")
			metric.SetDescription("The time the global lock has been held.")
			metric.SetUnit("ms")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(true)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.index.access.count",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.index.access.count")
			metric.SetDescription("The number of times an index has been accessed.")
			metric.SetUnit("{accesses}")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(false)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.index.count",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.index.count")
			metric.SetDescription("The number of indexes.")
			metric.SetUnit("{indexes}")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(false)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.index.size",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.index.size")
			metric.SetDescription("Sum of the space allocated to all indexes in the database, including free index space.")
			metric.SetUnit("By")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(false)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.memory.usage",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.memory.usage")
			metric.SetDescription("The amount of memory used.")
			metric.SetUnit("By")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(false)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.network.io.receive",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.network.io.receive")
			metric.SetDescription("The number of bytes received.")
			metric.SetUnit("By")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(false)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.network.io.transmit",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.network.io.transmit")
			metric.SetDescription("The number of by transmitted.")
			metric.SetUnit("By")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(false)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.network.request.count",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.network.request.count")
			metric.SetDescription("The number of requests received by the server.")
			metric.SetUnit("{requests}")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(false)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.object.count",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.object.count")
			metric.SetDescription("The number of objects.")
			metric.SetUnit("{objects}")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(false)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.operation.count",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.operation.count")
			metric.SetDescription("The number of operations executed.")
			metric.SetUnit("{operations}")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(true)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.operation.scanAndOrder",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.operation.scanAndOrder")
			metric.SetDescription("The total number of queries that return sorted numbers that cannot perform the sort operation using an index.")
			metric.SetUnit("{queries}")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(false)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.operation.time",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.operation.time")
			metric.SetDescription("The total time spent performing operations.")
			metric.SetUnit("ms")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(true)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.operation.writeConflict",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.operation.writeConflict")
			metric.SetDescription("The total number of queries that encountered write conflicts.")
			metric.SetUnit("{queries}")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(false)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.session.count",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.session.count")
			metric.SetDescription("The total number of active sessions.")
			metric.SetUnit("{sessions}")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(false)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.storage.size",
		func(metric pmetric.Metric) {
			metric.SetName("mongodb.storage.size")
			metric.SetDescription("The total amount of storage allocated to this collection.")
			metric.SetUnit("By")
			metric.SetDataType(pmetric.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(true)
			metric.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
		},
	},
}

// M contains a set of methods for each metric that help with
// manipulating those metrics. M is an alias for Metrics
var M = Metrics

// Attributes contains the possible metric attributes that can be used.
var Attributes = struct {
	// Collection (The name of a collection.)
	Collection string
	// ConnectionType (The status of the connection.)
	ConnectionType string
	// Database (The name of a database.)
	Database string
	// MemoryType (The type of memory used.)
	MemoryType string
	// Operation (The MongoDB operation being counted.)
	Operation string
	// Type (The result of a cache request.)
	Type string
}{
	"collection",
	"type",
	"database",
	"type",
	"operation",
	"type",
}

// A is an alias for Attributes.
var A = Attributes

// AttributeConnectionType are the possible values that the attribute "connection_type" can have.
var AttributeConnectionType = struct {
	Active    string
	Available string
	Current   string
}{
	"active",
	"available",
	"current",
}

// AttributeMemoryType are the possible values that the attribute "memory_type" can have.
var AttributeMemoryType = struct {
	Resident string
	Virtual  string
}{
	"resident",
	"virtual",
}

// AttributeOperation are the possible values that the attribute "operation" can have.
var AttributeOperation = struct {
	Insert  string
	Query   string
	Update  string
	Delete  string
	Getmore string
	Command string
}{
	"insert",
	"query",
	"update",
	"delete",
	"getmore",
	"command",
}

// AttributeType are the possible values that the attribute "type" can have.
var AttributeType = struct {
	Hit  string
	Miss string
}{
	"hit",
	"miss",
}
