// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package protocol

import (
	"errors"
	"fmt"
	"strconv"
	"strings"

	metricspb "github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1"
)

// PathParser implements the code needed to handle only the <metric_path> part of
// a Carbon metric line:
//
// 	<metric_path> <metric_value> <metric_timestamp>
//
// See https://graphite.readthedocs.io/en/latest/feeding-carbon.html#the-plaintext-protocol,
// for more information.
//
// The type PathParserHelper implements the common code for parsers that differ
// only by the way that they handle the <metric_path>.
type PathParser interface {
	// ParsePath converts the <metric_path> of a Carbon line (see Parse function
	// for description of the full line). The return values are:
	//
	// - name: the metric name extracted/generated by the parser.
	// - keys: the label keys extracted/generated by the parser.
	// - values: the label values extracted/generated by the parser.
	// - forceCumulative: forces the metric to be a cumulative counter instead of
	//   a gauge.
	// - err: any error that prevented correctly parsing the <metric_path>.
	ParsePath(path string) (name string, keys []*metricspb.LabelKey, values []*metricspb.LabelValue, forceCumulative bool, err error)
}

// PathParserHelper implements the common code to parse a Carbon line taking a
// PathParser to implement a full parser.
type PathParserHelper struct {
	pathParser PathParser
}

var _ (Parser) = (*PathParserHelper)(nil)

// BuildParser creates a new Parser instance that receives plaintext
// Carbon data.
func NewParser(pathParser PathParser) (Parser, error) {
	if pathParser == nil {
		return nil, errors.New("nil pathParser")
	}
	return &PathParserHelper{
		pathParser: pathParser,
	}, nil
}

// Parse receives the string with plaintext data, aka line, in the Carbon
// format and transforms it to the collector metric format. See
// https://graphite.readthedocs.io/en/latest/feeding-carbon.html#the-plaintext-protocol.
//
// The expected line is a text line in the following format:
// 	"<metric_path> <metric_value> <metric_timestamp>"
//
// The <metric_path> is where there are variations that require selection
// of specialized parsers to handle them, but include the metric name and
// labels/dimensions for the metric.
//
// The <metric_value> is the textual representation of the metric value.
//
// The <metric_timestamp> is the Unix time text of when the measurement was
// made.
func (pph *PathParserHelper) Parse(line string) (*metricspb.Metric, error) {
	parts := strings.SplitN(line, " ", 4)
	if len(parts) != 3 {
		return nil, fmt.Errorf("invalid carbon metric [%s]", line)
	}

	path := parts[0]
	valueStr := parts[1]
	timestampStr := parts[2]

	metricName, labelKeys, labelValues, forceCumulative, err := pph.pathParser.ParsePath(path)
	if err != nil {
		return nil, fmt.Errorf("invalid carbon metric [%s]: %v", line, err)
	}

	unixTime, err := strconv.ParseInt(timestampStr, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid carbon metric time [%s]: %v", line, err)
	}

	var metricType metricspb.MetricDescriptor_Type
	point := metricspb.Point{
		Timestamp: convertUnixSec(unixTime),
	}
	intVal, err := strconv.ParseInt(valueStr, 10, 64)
	if err == nil {
		if forceCumulative {
			metricType = metricspb.MetricDescriptor_CUMULATIVE_INT64
		} else {
			metricType = metricspb.MetricDescriptor_GAUGE_INT64
		}
		point.Value = &metricspb.Point_Int64Value{Int64Value: intVal}
	} else {
		dblVal, err := strconv.ParseFloat(valueStr, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid carbon metric value [%s]: %v", line, err)
		}
		if forceCumulative {
			metricType = metricspb.MetricDescriptor_CUMULATIVE_DOUBLE
		} else {
			metricType = metricspb.MetricDescriptor_GAUGE_DOUBLE
		}
		point.Value = &metricspb.Point_DoubleValue{DoubleValue: dblVal}
	}

	metric := buildMetricForSinglePoint(
		metricName,
		metricType,
		labelKeys,
		labelValues,
		&point)
	return metric, nil
}
