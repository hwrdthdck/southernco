// Copyright The OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/model/pdata"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`
}

// MetricsSettings provides settings for disk metrics.
type MetricsSettings struct {
	SystemDiskIo                MetricSettings `mapstructure:"system.disk.io"`
	SystemDiskIoTime            MetricSettings `mapstructure:"system.disk.io_time"`
	SystemDiskMerged            MetricSettings `mapstructure:"system.disk.merged"`
	SystemDiskOperationTime     MetricSettings `mapstructure:"system.disk.operation_time"`
	SystemDiskOperations        MetricSettings `mapstructure:"system.disk.operations"`
	SystemDiskPendingOperations MetricSettings `mapstructure:"system.disk.pending_operations"`
	SystemDiskWeightedIoTime    MetricSettings `mapstructure:"system.disk.weighted_io_time"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		SystemDiskIo: MetricSettings{
			Enabled: true,
		},
		SystemDiskIoTime: MetricSettings{
			Enabled: true,
		},
		SystemDiskMerged: MetricSettings{
			Enabled: true,
		},
		SystemDiskOperationTime: MetricSettings{
			Enabled: true,
		},
		SystemDiskOperations: MetricSettings{
			Enabled: true,
		},
		SystemDiskPendingOperations: MetricSettings{
			Enabled: true,
		},
		SystemDiskWeightedIoTime: MetricSettings{
			Enabled: true,
		},
	}
}

// metric holds data for generated metric and keeps track of data points slice capacity.
type metric struct {
	data     pdata.Metric // data buffer for generated metric.
	capacity int          // max observed number of data points added to the metric.
}

func (m *metric) updateCapacity(dpLen int) {
	if dpLen > m.capacity {
		m.capacity = dpLen
	}
}

func newMetric() metric {
	return metric{data: pdata.NewMetric()}
}

type metrics struct {
	systemDiskIo                metric
	systemDiskIoTime            metric
	systemDiskMerged            metric
	systemDiskOperationTime     metric
	systemDiskOperations        metric
	systemDiskPendingOperations metric
	systemDiskWeightedIoTime    metric
}

func newMetrics(config MetricsSettings) metrics {
	ms := metrics{}
	if config.SystemDiskIo.Enabled {
		ms.systemDiskIo = newMetric()
	}
	if config.SystemDiskIoTime.Enabled {
		ms.systemDiskIoTime = newMetric()
	}
	if config.SystemDiskMerged.Enabled {
		ms.systemDiskMerged = newMetric()
	}
	if config.SystemDiskOperationTime.Enabled {
		ms.systemDiskOperationTime = newMetric()
	}
	if config.SystemDiskOperations.Enabled {
		ms.systemDiskOperations = newMetric()
	}
	if config.SystemDiskPendingOperations.Enabled {
		ms.systemDiskPendingOperations = newMetric()
	}
	if config.SystemDiskWeightedIoTime.Enabled {
		ms.systemDiskWeightedIoTime = newMetric()
	}
	return ms
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user configuration.
type MetricsBuilder struct {
	config    MetricsSettings
	startTime pdata.Timestamp
	metrics   metrics
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pdata.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(config MetricsSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		config:    config,
		startTime: pdata.NewTimestampFromTime(time.Now()),
		metrics:   newMetrics(config),
	}

	for _, op := range options {
		op(mb)
	}

	mb.initMetrics()
	return mb
}

// Emit appends generated metrics to a pdata.MetricsSlice and updates the internal state to be ready for recording
// another set of data points. This function will be doing all transformations required to produce metric representation
// defined in metadata and user configuration, e.g. delta/cumulative translation.
func (mb *MetricsBuilder) Emit(metrics pdata.MetricSlice) {
	if mb.config.SystemDiskIo.Enabled && mb.metrics.systemDiskIo.data.Sum().DataPoints().Len() > 0 {
		mb.metrics.systemDiskIo.updateCapacity(mb.metrics.systemDiskIo.data.Sum().DataPoints().Len())
		mb.metrics.systemDiskIo.data.MoveTo(metrics.AppendEmpty())
	}
	if mb.config.SystemDiskIoTime.Enabled && mb.metrics.systemDiskIoTime.data.Sum().DataPoints().Len() > 0 {
		mb.metrics.systemDiskIoTime.updateCapacity(mb.metrics.systemDiskIoTime.data.Sum().DataPoints().Len())
		mb.metrics.systemDiskIoTime.data.MoveTo(metrics.AppendEmpty())
	}
	if mb.config.SystemDiskMerged.Enabled && mb.metrics.systemDiskMerged.data.Sum().DataPoints().Len() > 0 {
		mb.metrics.systemDiskMerged.updateCapacity(mb.metrics.systemDiskMerged.data.Sum().DataPoints().Len())
		mb.metrics.systemDiskMerged.data.MoveTo(metrics.AppendEmpty())
	}
	if mb.config.SystemDiskOperationTime.Enabled && mb.metrics.systemDiskOperationTime.data.Sum().DataPoints().Len() > 0 {
		mb.metrics.systemDiskOperationTime.updateCapacity(mb.metrics.systemDiskOperationTime.data.Sum().DataPoints().Len())
		mb.metrics.systemDiskOperationTime.data.MoveTo(metrics.AppendEmpty())
	}
	if mb.config.SystemDiskOperations.Enabled && mb.metrics.systemDiskOperations.data.Sum().DataPoints().Len() > 0 {
		mb.metrics.systemDiskOperations.updateCapacity(mb.metrics.systemDiskOperations.data.Sum().DataPoints().Len())
		mb.metrics.systemDiskOperations.data.MoveTo(metrics.AppendEmpty())
	}
	if mb.config.SystemDiskPendingOperations.Enabled && mb.metrics.systemDiskPendingOperations.data.Sum().DataPoints().Len() > 0 {
		mb.metrics.systemDiskPendingOperations.updateCapacity(mb.metrics.systemDiskPendingOperations.data.Sum().DataPoints().Len())
		mb.metrics.systemDiskPendingOperations.data.MoveTo(metrics.AppendEmpty())
	}
	if mb.config.SystemDiskWeightedIoTime.Enabled && mb.metrics.systemDiskWeightedIoTime.data.Sum().DataPoints().Len() > 0 {
		mb.metrics.systemDiskWeightedIoTime.updateCapacity(mb.metrics.systemDiskWeightedIoTime.data.Sum().DataPoints().Len())
		mb.metrics.systemDiskWeightedIoTime.data.MoveTo(metrics.AppendEmpty())
	}

	// Reset metric data points collection.
	mb.initMetrics()
}

// initSystemDiskIoMetric builds new system.disk.io metric.
func (mb *MetricsBuilder) initSystemDiskIoMetric() {
	metric := mb.metrics.systemDiskIo
	metric.data.SetName("system.disk.io")
	metric.data.SetDescription("Disk bytes transferred.")
	metric.data.SetUnit("By")
	metric.data.SetDataType(pdata.MetricDataTypeSum)
	metric.data.Sum().SetIsMonotonic(true)
	metric.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	metric.data.Sum().DataPoints().EnsureCapacity(metric.capacity)
}

// initSystemDiskIoTimeMetric builds new system.disk.io_time metric.
func (mb *MetricsBuilder) initSystemDiskIoTimeMetric() {
	metric := mb.metrics.systemDiskIoTime
	metric.data.SetName("system.disk.io_time")
	metric.data.SetDescription("Time disk spent activated. On Windows, this is calculated as the inverse of disk idle time.")
	metric.data.SetUnit("s")
	metric.data.SetDataType(pdata.MetricDataTypeSum)
	metric.data.Sum().SetIsMonotonic(true)
	metric.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	metric.data.Sum().DataPoints().EnsureCapacity(metric.capacity)
}

// initSystemDiskMergedMetric builds new system.disk.merged metric.
func (mb *MetricsBuilder) initSystemDiskMergedMetric() {
	metric := mb.metrics.systemDiskMerged
	metric.data.SetName("system.disk.merged")
	metric.data.SetDescription("The number of disk reads merged into single physical disk access operations.")
	metric.data.SetUnit("{operations}")
	metric.data.SetDataType(pdata.MetricDataTypeSum)
	metric.data.Sum().SetIsMonotonic(true)
	metric.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	metric.data.Sum().DataPoints().EnsureCapacity(metric.capacity)
}

// initSystemDiskOperationTimeMetric builds new system.disk.operation_time metric.
func (mb *MetricsBuilder) initSystemDiskOperationTimeMetric() {
	metric := mb.metrics.systemDiskOperationTime
	metric.data.SetName("system.disk.operation_time")
	metric.data.SetDescription("Time spent in disk operations.")
	metric.data.SetUnit("s")
	metric.data.SetDataType(pdata.MetricDataTypeSum)
	metric.data.Sum().SetIsMonotonic(true)
	metric.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	metric.data.Sum().DataPoints().EnsureCapacity(metric.capacity)
}

// initSystemDiskOperationsMetric builds new system.disk.operations metric.
func (mb *MetricsBuilder) initSystemDiskOperationsMetric() {
	metric := mb.metrics.systemDiskOperations
	metric.data.SetName("system.disk.operations")
	metric.data.SetDescription("Disk operations count.")
	metric.data.SetUnit("{operations}")
	metric.data.SetDataType(pdata.MetricDataTypeSum)
	metric.data.Sum().SetIsMonotonic(true)
	metric.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	metric.data.Sum().DataPoints().EnsureCapacity(metric.capacity)
}

// initSystemDiskPendingOperationsMetric builds new system.disk.pending_operations metric.
func (mb *MetricsBuilder) initSystemDiskPendingOperationsMetric() {
	metric := mb.metrics.systemDiskPendingOperations
	metric.data.SetName("system.disk.pending_operations")
	metric.data.SetDescription("The queue size of pending I/O operations.")
	metric.data.SetUnit("{operations}")
	metric.data.SetDataType(pdata.MetricDataTypeSum)
	metric.data.Sum().SetIsMonotonic(false)
	metric.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	metric.data.Sum().DataPoints().EnsureCapacity(metric.capacity)
}

// initSystemDiskWeightedIoTimeMetric builds new system.disk.weighted_io_time metric.
func (mb *MetricsBuilder) initSystemDiskWeightedIoTimeMetric() {
	metric := mb.metrics.systemDiskWeightedIoTime
	metric.data.SetName("system.disk.weighted_io_time")
	metric.data.SetDescription("Time disk spent activated multiplied by the queue length.")
	metric.data.SetUnit("s")
	metric.data.SetDataType(pdata.MetricDataTypeSum)
	metric.data.Sum().SetIsMonotonic(true)
	metric.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	metric.data.Sum().DataPoints().EnsureCapacity(metric.capacity)
}

// initMetrics initializes metrics.
func (mb *MetricsBuilder) initMetrics() {
	if mb.config.SystemDiskIo.Enabled {
		// TODO: Use metric.data.Sum().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.initSystemDiskIoMetric()
	}
	if mb.config.SystemDiskIoTime.Enabled {
		// TODO: Use metric.data.Sum().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.initSystemDiskIoTimeMetric()
	}
	if mb.config.SystemDiskMerged.Enabled {
		// TODO: Use metric.data.Sum().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.initSystemDiskMergedMetric()
	}
	if mb.config.SystemDiskOperationTime.Enabled {
		// TODO: Use metric.data.Sum().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.initSystemDiskOperationTimeMetric()
	}
	if mb.config.SystemDiskOperations.Enabled {
		// TODO: Use metric.data.Sum().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.initSystemDiskOperationsMetric()
	}
	if mb.config.SystemDiskPendingOperations.Enabled {
		// TODO: Use metric.data.Sum().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.initSystemDiskPendingOperationsMetric()
	}
	if mb.config.SystemDiskWeightedIoTime.Enabled {
		// TODO: Use metric.data.Sum().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.initSystemDiskWeightedIoTimeMetric()
	}
}

// RecordSystemDiskIoDataPoint adds a data point to system.disk.io metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordSystemDiskIoDataPoint(ts pdata.Timestamp, val int64, deviceAttributeValue string, directionAttributeValue string) {
	if !mb.config.SystemDiskIo.Enabled {
		return
	}

	dp := mb.metrics.systemDiskIo.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Device, pdata.NewAttributeValueString(deviceAttributeValue))
	dp.Attributes().Insert(A.Direction, pdata.NewAttributeValueString(directionAttributeValue))
}

// RecordSystemDiskIoTimeDataPoint adds a data point to system.disk.io_time metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordSystemDiskIoTimeDataPoint(ts pdata.Timestamp, val float64, deviceAttributeValue string) {
	if !mb.config.SystemDiskIoTime.Enabled {
		return
	}

	dp := mb.metrics.systemDiskIoTime.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.Device, pdata.NewAttributeValueString(deviceAttributeValue))
}

// RecordSystemDiskMergedDataPoint adds a data point to system.disk.merged metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordSystemDiskMergedDataPoint(ts pdata.Timestamp, val int64, deviceAttributeValue string, directionAttributeValue string) {
	if !mb.config.SystemDiskMerged.Enabled {
		return
	}

	dp := mb.metrics.systemDiskMerged.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Device, pdata.NewAttributeValueString(deviceAttributeValue))
	dp.Attributes().Insert(A.Direction, pdata.NewAttributeValueString(directionAttributeValue))
}

// RecordSystemDiskOperationTimeDataPoint adds a data point to system.disk.operation_time metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordSystemDiskOperationTimeDataPoint(ts pdata.Timestamp, val float64, deviceAttributeValue string, directionAttributeValue string) {
	if !mb.config.SystemDiskOperationTime.Enabled {
		return
	}

	dp := mb.metrics.systemDiskOperationTime.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.Device, pdata.NewAttributeValueString(deviceAttributeValue))
	dp.Attributes().Insert(A.Direction, pdata.NewAttributeValueString(directionAttributeValue))
}

// RecordSystemDiskOperationsDataPoint adds a data point to system.disk.operations metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordSystemDiskOperationsDataPoint(ts pdata.Timestamp, val int64, deviceAttributeValue string, directionAttributeValue string) {
	if !mb.config.SystemDiskOperations.Enabled {
		return
	}

	dp := mb.metrics.systemDiskOperations.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Device, pdata.NewAttributeValueString(deviceAttributeValue))
	dp.Attributes().Insert(A.Direction, pdata.NewAttributeValueString(directionAttributeValue))
}

// RecordSystemDiskPendingOperationsDataPoint adds a data point to system.disk.pending_operations metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordSystemDiskPendingOperationsDataPoint(ts pdata.Timestamp, val int64, deviceAttributeValue string) {
	if !mb.config.SystemDiskPendingOperations.Enabled {
		return
	}

	dp := mb.metrics.systemDiskPendingOperations.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Device, pdata.NewAttributeValueString(deviceAttributeValue))
}

// RecordSystemDiskWeightedIoTimeDataPoint adds a data point to system.disk.weighted_io_time metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordSystemDiskWeightedIoTimeDataPoint(ts pdata.Timestamp, val float64, deviceAttributeValue string) {
	if !mb.config.SystemDiskWeightedIoTime.Enabled {
		return
	}

	dp := mb.metrics.systemDiskWeightedIoTime.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.Device, pdata.NewAttributeValueString(deviceAttributeValue))
}

// Attributes contains the possible metric attributes that can be used.
var Attributes = struct {
	// Device (Name of the disk.)
	Device string
	// Direction (Direction of flow of bytes/opertations (read or write).)
	Direction string
}{
	"device",
	"direction",
}

// A is an alias for Attributes.
var A = Attributes

// AttributeDirection are the possible values that the attribute "direction" can have.
var AttributeDirection = struct {
	Read  string
	Write string
}{
	"read",
	"write",
}
