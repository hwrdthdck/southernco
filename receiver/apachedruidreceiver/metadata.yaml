type: apachedruid

status:
  class: receiver
  stability:
    development: [metrics, logs]
  distributions: [contrib, observiq, sumo]
  codeowners:
    active: [yuanlihan]

resource_attributes:
  apachedruid.cluster.name:
    description: The name of the apachedruid cluster.
    type: string
    enabled: true
  apachedruid.node.host:
    description: The name of the apachedruid node.
    type: string
    enabled: true
  apachedruid.node.service:
    description: The service name of the apachedruid node.
    type: string
    enabled: true
attributes:
  query_data_source:
    name_override: data_source
    description: The data source name of the query.
    type: string
  query_num_metrics:
    name_override: num_metrics
    description: The number of metrics of the query.
    type: string
  query_dimension:
    name_override: dimension
    description: The dimension of the query.
    type: string
  query_has_filters:
    name_override: has_filters
    description: Whether query has filters.
    type: string
  query_threshold:
    name_override: threshold
    description: The threshold of query.
    type: int
  query_num_complex_metrics:
    name_override: num_complex_metrics
    description: The number of complex metrics.
    type: int
  query_type:
    name_override: type
    description: The type of query.
    type: string
  query_remote_address:
    name_override: remote_address
    description: The remote address of the query.
    type: string
  query_id:
    name_override: id
    description: The id of query.
    type: string
  query_context:
    name_override: context
    description: The context of the query.
    type: string
  query_num_dimensions:
    name_override: num_dimensions
    description: The number of dimensions of query.
    type: string
  query_interval:
    name_override: interval
    description: The interval of the query.
    type: string
  query_duration:
    name_override: duration
    description: The duration of query.
    type: string
  query_status:
    name_override: status
    description: The status of the query.
    type: string
  query_server:
    name_override: server
    description: The server of the query.
    type: string
  query_lane:
    name_override: lane
    description: The name of query lane.
    type: string
  sqlQuery_data_source:
    name_override: data_source
    description: The data source name of the query.
    type: string
  sqlQuery_native_query_ids:
    name_override: native_query_ids
    description: The native query ids of sql query.
    type: string
  sqlQuery_engine:
    name_override: engine
    description: The engine name of the sql query.
    type: string
  sqlQuery_remote_address:
    name_override: remote_address
    description: The remote address of sql query.
    type: string
  sqlQuery_id:
    name_override: id
    description: The id of sql query.
    type: string
  sqlQuery_success:
    name_override: success
    description: Whether sql query is successful.
    type: string
  serverview_tier:
    name_override: tier
    description: The name of the tier.
    type: string
  serverview_server:
    name_override: server
    description: The address of server.
    type: string
  query_segment:
    name_override: segment
    description: The segment of the query.
    type: string
  query_vectorized:
    name_override: vectorized
    description: Whether query is vectorized.
    type: string
  ingest_task_type:
    name_override: task_type
    description: The type of ingestion task.
    type: string
  ingest_data_source:
    name_override: data_source
    description: The data source of ingestion task.
    type: string
  ingest_group_id:
    name_override: group_id
    description: The ingestion group id.
    type: string
  ingest_tags:
    name_override: tags
    description: The names of tags.
    type: string
  ingest_task_id:
    name_override: task_id
    description: The id of the task.
    type: string
  ingest_task_ingestion_mode:
    name_override: task_ingestion_mode
    description: The mode of ingestion task.
    type: string
  ingest_stream:
    name_override: stream
    description: The name of stream to ingest.
    type: string
  ingest_partition:
    name_override: partition
    description: The partition of the topic.
    type: string
  compact_task_type:
    name_override: task_type
    description: The type of task.
    type: string
  compact_data_source:
    name_override: data_source
    description: The data source of compaction task.
    type: string
  compact_group_id:
    name_override: group_id
    description: The group id of compaction task.
    type: string
  compact_tags:
    name_override: tags
    description: The tags of the compaction task.
    type: string
  compact_task_id:
    name_override: task_id
    description: The task id of compaction task.
    type: string
  task_type:
    name_override: task_type
    description: The type of task.
    type: string
  task_data_source:
    name_override: data_source
    description: The data source of the task.
    type: string
  task_group_id:
    name_override: group_id
    description: The group id of the task.
    type: string
  task_status:
    name_override: task_status
    description: The status of the task.
    type: string
  task_tags:
    name_override: tags
    description: The tags of task.
    type: string
  task_id:
    name_override: task_id
    description: The id of task.
    type: string
  task_action_type:
    name_override: task_action_type
    description: The action type of task.
    type: string
  task_interval:
    name_override: interval
    description: The interval of task.
    type: string
  task_segment_availability_confirmed:
    name_override: segment_availability_confirmed
    description: Whether segment availability is confirmed.
    type: string
  segment_task_type:
    name_override: task_type
    description: The task type of the segment.
    type: string
  segment_data_source:
    name_override: data_source
    description: The data source of the segment.
    type: string
  segment_group_id:
    name_override: group_id
    description: The group id of segment.
    type: string
  segment_tags:
    name_override: tags
    description: The tags of the segment.
    type: string
  segment_task_id:
    name_override: task_id
    description: The task id of segment.
    type: string
  segment_interval:
    name_override: interval
    description: The interval of segment.
    type: string
  taskSlot_category:
    name_override: category
    description: The category of task slot.
    type: string
  worker_category:
    name_override: category
    description: The category of worker.
    type: string
  worker_version:
    name_override: worker_version
    description: The verson of worker.
    type: string
  ingest_supervisor_task_id:
    name_override: supervisor_task_id
    description: The task id of supervisor.
    type: string
  segment_tier:
    name_override: tier
    description: The name of segment tier.
    type: string
  segment_description:
    name_override: description
    description: The description of segment.
    type: string
  segment_server:
    name_override: server
    description: The server of the segment.
    type: string
  segment_priority:
    name_override: priority
    description: The priority of segment.
    type: string
  tier:
    name_override: tier
    description: The name of tier.
    type: string
  kill_data_source:
    name_override: data_source
    description: The data source name of the kill task.
    type: string
  interval_data_source:
    name_override: data_source
    description: The interval of data source.
    type: string
  coordinator_duty:
    name_override: duty
    description: The name of coordinator duty task.
    type: string
  coordinator_duty_group:
    name_override: duty_group
    description: The name of the duty group.
    type: string
  segment_range:
    name_override: range
    description: The range of segment.
    type: string
  jvm_pool_name:
    name_override: pool_name
    description: The name of the pool.
    type: string
  jvm_pool_kind:
    name_override: pool_kind
    description: The pool kind of jvm.
    type: string
  jvm_bufferpool_name:
    name_override: bufferpool_name
    description: The name of buffer pool.
    type: string
  jvm_mem_kind:
    name_override: mem_kind
    description: The memory kind of jvm.
    type: string
  jvm_gc_gen:
    name_override: gc_gen
    description: The name of GC generation.
    type: string
  jvm_gc_name:
    name_override: gc_name
    description: The gc name of jvm.
    type: string
  ingest_service_name:
    name_override: service_name
    description: The name of ingestion service.
    type: string
  ingest_buffer_capacity:
    name_override: buffer_capacity
    description: The capacity of ingestion buffer.
    type: string
  sys_disk_name:
    name_override: disk_name
    description: The name of disk.
    type: string
  sys_net_hwaddr:
    name_override: net_hwaddr
    description: The net hardware address.
    type: string
  sys_net_name:
    name_override: net_name
    description: The name of network.
    type: string
  sys_net_address:
    name_override: net_address
    description: The net address.
    type: string
  sys_fs_dir_name:
    name_override: fs_dir_name
    description: The dir name.
    type: string
  sys_fs_dev_name:
    name_override: fs_dev_name
    description: The dev name.
    type: string
  sys_cpu_time:
    name_override: cpu_time
    description: The group name of cpu time usage.
    type: string
  sys_cpu_name:
    name_override: cpu_name
    description: The group name of cpu usage.
    type: string
metrics:
  apachedruid.query.time:
    description: Milliseconds taken to complete a query.
    unit: ms
    gauge:
      value_type: int
    attributes:
      [
        query_data_source,
        query_num_metrics,
        query_dimension,
        query_has_filters,
        query_threshold,
        query_num_complex_metrics,
        query_type,
        query_remote_address,
        query_id,
        query_context,
        query_num_dimensions,
        query_interval,
        query_duration,
      ]
    enabled: true
  apachedruid.query.bytes:
    description: The total number of bytes returned to the requesting client in the query response from the broker. Other services report the total bytes for their portion of the query.
    unit: By
    gauge:
      value_type: int
    attributes:
      [
        query_data_source,
        query_num_metrics,
        query_dimension,
        query_has_filters,
        query_threshold,
        query_num_complex_metrics,
        query_type,
        query_remote_address,
        query_id,
        query_context,
        query_num_dimensions,
        query_interval,
        query_duration,
      ]
    enabled: true
  apachedruid.query.node.time:
    description: Milliseconds taken to query individual historical/realtime processes.
    unit: ms
    gauge:
      value_type: int
    attributes: [query_status, query_server, query_id]
    enabled: true
  apachedruid.query.node.bytes:
    description: Number of bytes returned from querying individual historical/realtime processes.
    unit: By
    gauge:
      value_type: int
    attributes: [query_status, query_server, query_id]
    enabled: true
  apachedruid.query.node.ttfb:
    description: Time to first byte. Milliseconds elapsed until Broker starts receiving the response from individual historical/realtime processes.
    unit: ms
    gauge:
      value_type: int
    attributes: [query_status, query_server, query_id]
    enabled: true
  apachedruid.query.node.backpressure:
    description: Milliseconds that the channel to this process has spent suspended due to backpressure.
    unit: ms
    gauge:
      value_type: int
    attributes: [query_status, query_server, query_id]
    enabled: true
  apachedruid.query.count:
    description: Number of total queries.
    unit: "{queries}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.success.count:
    description: Number of queries successfully processed.
    unit: "{queries}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.failed.count:
    description: Number of failed queries.
    unit: "{queries}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.interrupted.count:
    description: Number of queries interrupted due to cancellation.
    unit: "{queries}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.timeout.count:
    description: Number of timed out queries.
    unit: "{queries}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.merge_buffer.pending_requests:
    description: Number of requests waiting to acquire a batch of buffers from the merge buffer pool.
    unit: "{requests}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.segments.count:
    description: This metric is not enabled by default. See the `QueryMetrics` Interface for reference regarding enabling this metric. Number of segments that will be touched by the query. In the broker, it makes a plan to distribute the query to realtime tasks and historicals based on a snapshot of segment distribution state. If there are some segments moved after this snapshot is created, certain historicals and realtime tasks can report those segments as missing to the broker. The broker will resend the query to the new servers that serve those segments after move. In this case, those segments can be counted more than once in this metric.
    unit: "{segments}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.priority:
    description: Assigned lane and priority, only if Laning strategy is enabled. Refer to [Laning strategies](https,//druid.apache.org/docs/latest/configuration#laning-strategies).
    unit: 1
    gauge:
      value_type: int
    attributes: [query_type, query_data_source, query_lane]
    enabled: true
  apachedruid.sql_query.time:
    description: Milliseconds taken to complete a SQL query.
    unit: ms
    gauge:
      value_type: int
    attributes:
      [
        sqlQuery_data_source,
        sqlQuery_native_query_ids,
        sqlQuery_engine,
        sqlQuery_remote_address,
        sqlQuery_id,
        sqlQuery_success,
      ]
    enabled: true
  apachedruid.sql_query.planning_time_ms:
    description: Milliseconds taken to plan a SQL to native query.
    unit: ms
    gauge:
      value_type: int
    attributes:
      [
        sqlQuery_data_source,
        sqlQuery_native_query_ids,
        sqlQuery_engine,
        sqlQuery_remote_address,
        sqlQuery_id,
        sqlQuery_success,
      ]
    enabled: true
  apachedruid.sql_query.bytes:
    description: Number of bytes returned in the SQL query response.
    unit: By
    gauge:
      value_type: int
    attributes:
      [
        sqlQuery_data_source,
        sqlQuery_native_query_ids,
        sqlQuery_engine,
        sqlQuery_remote_address,
        sqlQuery_id,
        sqlQuery_success,
      ]
    enabled: true
  apachedruid.serverview.init.time:
    description: Time taken to initialize the broker server view. Useful to detect if brokers are taking too long to start.
    unit: ms
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.metadatacache.init.time:
    description: Time taken to initialize the broker segment metadata cache. Useful to detect if brokers are taking too long to start.
    unit: ms
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.metadatacache.refresh.count:
    description: Number of segments to refresh in broker segment metadata cache.
    unit: 1
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.metadatacache.refresh.time:
    description: Time taken to refresh segments in broker segment metadata cache.
    unit: ms
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.serverview.sync.healthy:
    description: Sync status of the Broker with a segment-loading server such as a Historical or Peon. Emitted only when [HTTP-based server view](https,//druid.apache.org/docs/latest/configuration#segment-management) is enabled. This metric can be used in conjunction with `serverview/sync/unstableTime` to debug slow startup of Brokers.
    unit: 1
    gauge:
      value_type: int
    attributes: [serverview_tier, serverview_server]
    enabled: true
  apachedruid.serverview.sync.unstable_time:
    description: Time in milliseconds for which the Broker has been failing to sync with a segment-loading server. Emitted only when [HTTP-based server view](https,//druid.apache.org/docs/latest/configuration#segment-management) is enabled.
    unit: ms
    gauge:
      value_type: int
    attributes: [serverview_tier, serverview_server]
    enabled: true
  apachedruid.subquery.row_limit.count:
    description: Number of subqueries whose results are materialized as rows (Java objects on heap).
    unit: "{subqueries}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.subquery.byte_limit.count:
    description: Number of subqueries whose results are materialized as frames (Druid's internal byte representation of rows).
    unit: "{subqueries}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.subquery.fallback.count:
    description: Number of subqueries which cannot be materialized as frames.
    unit: "{subqueries}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.subquery.fallback.insufficient_type.count:
    description: Number of subqueries which cannot be materialized as frames due to insufficient type information in the row signature.
    unit: "{subqueries}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.subquery.fallback.unknown_reason.count:
    description: Number of subqueries which cannot be materialized as frames due other reasons.
    unit: "{subqueries}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.row_limit.exceeded.count:
    description: Number of queries whose inlined subquery results exceeded the given row limit.
    unit: "{queries}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.byte_limit.exceeded.count:
    description: Number of queries whose inlined subquery results exceeded the given byte limit.
    unit: "{queries}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.segment.time:
    description: Milliseconds taken to query individual segment. Includes time to page in the segment from disk.
    unit: ms
    gauge:
      value_type: int
    attributes: [query_status, query_segment, query_id, query_vectorized]
    enabled: true
  apachedruid.query.wait.time:
    description: Milliseconds spent waiting for a segment to be scanned.
    unit: ms
    gauge:
      value_type: int
    attributes: [query_segment, query_id]
    enabled: true
  apachedruid.segment.scan.pending:
    description: Number of segments in queue waiting to be scanned.
    unit: "{segments}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.segment.scan.active:
    description: Number of segments currently scanned. This metric also indicates how many threads from `druid.processing.numThreads` are currently being used.
    unit: "{segments}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.segment_and_cache.time:
    description: Milliseconds taken to query individual segment or hit the cache (if it is enabled on the Historical process).
    unit: ms
    gauge:
      value_type: int
    attributes: [query_segment, query_id]
    enabled: true
  apachedruid.query.cpu.time:
    description: Microseconds of CPU time taken to complete a query.
    unit: ms
    gauge:
      value_type: int
    attributes:
      [
        query_data_source,
        query_num_metrics,
        query_dimension,
        query_has_filters,
        query_threshold,
        query_num_complex_metrics,
        query_type,
        query_remote_address,
        query_id,
        query_context,
        query_num_dimensions,
        query_interval,
        query_duration,
      ]
    enabled: true
  apachedruid.jetty.num_open_connections:
    description: Number of open jetty connections.
    unit: "{connections}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.jetty.thread_pool.total:
    description: Number of total workable threads allocated.
    unit: "{threads}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.jetty.thread_pool.idle:
    description: Number of idle threads.
    unit: "{threads}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.jetty.thread_pool.busy:
    description: Number of busy threads that has work to do from the worker queue.
    unit: "{threads}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.jetty.thread_pool.is_low_on_threads:
    description: A rough indicator of whether number of total workable threads allocated is enough to handle the works in the work queue.
    unit: "{threads}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.jetty.thread_pool.min:
    description: Number of minimum threads allocatable.
    unit: "{threads}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.jetty.thread_pool.max:
    description: Number of maximum threads allocatable.
    unit: "{threads}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.jetty.thread_pool.queue_size:
    description: Size of the worker queue.
    unit: 1
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.delta.num_entries:
    description: Number of cache entries.
    unit: "{entries}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.total.num_entries:
    description: Number of cache entries.
    unit: "{entries}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.delta.size_bytes:
    description: Size in bytes of cache entries.
    unit: By
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.total.size_bytes:
    description: Size in bytes of cache entries.
    unit: By
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.delta.hits:
    description: Number of cache hits.
    unit: "{hits}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.total.hits:
    description: Number of cache hits.
    unit: "{hits}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.delta.misses:
    description: Number of cache misses.
    unit: "{misses}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.total.misses:
    description: Number of cache misses.
    unit: "{misses}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.delta.evictions:
    description: Number of cache evictions.
    unit: "{evictions}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.total.evictions:
    description: Number of cache evictions.
    unit: "{evictions}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.delta.hit_rate:
    description: Cache hit rate.
    unit: 1.0
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: double
    attributes: []
    enabled: true
  apachedruid.query.cache.total.hit_rate:
    description: Cache hit rate.
    unit: 1.0
    gauge:
      value_type: double
    attributes: []
    enabled: true
  apachedruid.query.cache.delta.average_bytes:
    description: Average cache entry byte size.
    unit: By
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.total.average_bytes:
    description: Average cache entry byte size.
    unit: By
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.delta.timeouts:
    description: Number of cache timeouts.
    unit: "{timeouts}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.total.timeouts:
    description: Number of cache timeouts.
    unit: "{timeouts}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.delta.errors:
    description: Number of cache errors.
    unit: "{errors}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.total.errors:
    description: Number of cache errors.
    unit: "{errors}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.delta.put.ok:
    description: Number of new cache entries successfully cached.
    unit: 1
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.total.put.ok:
    description: Number of new cache entries successfully cached.
    unit: 1
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.delta.put.error:
    description: Number of new cache entries that could not be cached due to errors.
    unit: "{errors}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.total.put.error:
    description: Number of new cache entries that could not be cached due to errors.
    unit: "{errors}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.delta.put.oversized:
    description: Number of potential new cache entries that were skipped due to being too large (based on `druid.{broker,historical,realtime}.cache.maxEntrySize` properties).
    unit: 1
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.total.put.oversized:
    description: Number of potential new cache entries that were skipped due to being too large (based on `druid.{broker,historical,realtime}.cache.maxEntrySize` properties).
    unit: 1
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.memcached.total:
    description: Cache metrics unique to memcached (only if `druid.cache.type=memcached`) as their actual values.
    unit: 1
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.query.cache.memcached.delta:
    description: Cache metrics unique to memcached (only if `druid.cache.type=memcached`) as their delta from the prior event emission.
    unit: 1
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.ingest.count:
    description: Count of `1` every time an ingestion job runs (includes compaction jobs). Aggregate using dimensions.
    unit: 1
    gauge:
      value_type: int
    attributes:
      [
        ingest_task_type,
        ingest_data_source,
        ingest_group_id,
        ingest_tags,
        ingest_task_id,
        ingest_task_ingestion_mode,
      ]
    enabled: true
  apachedruid.ingest.segments.count:
    description: Count of final segments created by job (includes tombstones).
    unit: 1
    gauge:
      value_type: int
    attributes:
      [
        ingest_task_type,
        ingest_data_source,
        ingest_group_id,
        ingest_tags,
        ingest_task_id,
        ingest_task_ingestion_mode,
      ]
    enabled: true
  apachedruid.ingest.tombstones.count:
    description: Count of tombstones created by job.
    unit: 1
    gauge:
      value_type: int
    attributes:
      [
        ingest_task_type,
        ingest_data_source,
        ingest_group_id,
        ingest_tags,
        ingest_task_id,
        ingest_task_ingestion_mode,
      ]
    enabled: true
  apachedruid.ingest.kafka.lag:
    description: Total lag between the offsets consumed by the Kafka indexing tasks and latest offsets in Kafka brokers across all partitions. Minimum emission period for this metric is a minute.
    unit: 1
    gauge:
      value_type: int
    attributes: [ingest_tags, ingest_stream, ingest_data_source]
    enabled: true
  apachedruid.ingest.kafka.max_lag:
    description: Max lag between the offsets consumed by the Kafka indexing tasks and latest offsets in Kafka brokers across all partitions. Minimum emission period for this metric is a minute.
    unit: 1
    gauge:
      value_type: int
    attributes: [ingest_tags, ingest_stream, ingest_data_source]
    enabled: true
  apachedruid.ingest.kafka.avg_lag:
    description: Average lag between the offsets consumed by the Kafka indexing tasks and latest offsets in Kafka brokers across all partitions. Minimum emission period for this metric is a minute.
    unit: 1
    gauge:
      value_type: int
    attributes: [ingest_tags, ingest_stream, ingest_data_source]
    enabled: true
  apachedruid.ingest.kafka.partition_lag:
    description: Partition-wise lag between the offsets consumed by the Kafka indexing tasks and latest offsets in Kafka brokers. Minimum emission period for this metric is a minute.
    unit: 1
    gauge:
      value_type: int
    attributes:
      [ingest_tags, ingest_partition, ingest_stream, ingest_data_source]
    enabled: true
  apachedruid.ingest.kinesis.lag.time:
    description: Total lag time in milliseconds between the current message sequence number consumed by the Kinesis indexing tasks and latest sequence number in Kinesis across all shards. Minimum emission period for this metric is a minute.
    unit: ms
    gauge:
      value_type: int
    attributes: [ingest_tags, ingest_stream, ingest_data_source]
    enabled: true
  apachedruid.ingest.kinesis.max_lag.time:
    description: Max lag time in milliseconds between the current message sequence number consumed by the Kinesis indexing tasks and latest sequence number in Kinesis across all shards. Minimum emission period for this metric is a minute.
    unit: ms
    gauge:
      value_type: int
    attributes: [ingest_tags, ingest_stream, ingest_data_source]
    enabled: true
  apachedruid.ingest.kinesis.avg_lag.time:
    description: Average lag time in milliseconds between the current message sequence number consumed by the Kinesis indexing tasks and latest sequence number in Kinesis across all shards. Minimum emission period for this metric is a minute.
    unit: ms
    gauge:
      value_type: int
    attributes: [ingest_tags, ingest_stream, ingest_data_source]
    enabled: true
  apachedruid.ingest.kinesis.partition_lag.time:
    description: Partition-wise lag time in milliseconds between the current message sequence number consumed by the Kinesis indexing tasks and latest sequence number in Kinesis. Minimum emission period for this metric is a minute.
    unit: ms
    gauge:
      value_type: int
    attributes:
      [ingest_tags, ingest_partition, ingest_stream, ingest_data_source]
    enabled: true
  apachedruid.compact.segment_analyzer.fetch_and_process_millis:
    description: Time taken to fetch and process segments to infer the schema for the compaction task to run.
    unit: 1
    gauge:
      value_type: int
    attributes:
      [
        compact_task_type,
        compact_data_source,
        compact_group_id,
        compact_tags,
        compact_task_id,
      ]
    enabled: true
  apachedruid.ingest.events.processed:
    description: Number of events processed per emission period.
    unit: "{events}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes:
      [
        ingest_task_type,
        ingest_data_source,
        ingest_group_id,
        ingest_tags,
        ingest_task_id,
      ]
    enabled: true
  apachedruid.ingest.events.processed_with_error:
    description: Number of events processed with some partial errors per emission period. Events processed with partial errors are counted towards both this metric and `ingest/events/processed`.
    unit: "{events}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes:
      [
        ingest_task_type,
        ingest_data_source,
        ingest_group_id,
        ingest_tags,
        ingest_task_id,
      ]
    enabled: true
  apachedruid.ingest.events.unparseable:
    description: Number of events rejected because the events are unparseable.
    unit: "{events}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes:
      [
        ingest_task_type,
        ingest_data_source,
        ingest_group_id,
        ingest_tags,
        ingest_task_id,
      ]
    enabled: true
  apachedruid.ingest.events.thrown_away:
    description: Number of events rejected because they are null, or filtered by `transformSpec`, or outside one of `lateMessageRejectionPeriod`, `earlyMessageRejectionPeriod`, or `windowPeriod`.
    unit: "{events}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes:
      [
        ingest_task_type,
        ingest_data_source,
        ingest_group_id,
        ingest_tags,
        ingest_task_id,
      ]
    enabled: true
  apachedruid.ingest.events.duplicate:
    description: Number of events rejected because the events are duplicated.
    unit: "{events}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes:
      [
        ingest_task_type,
        ingest_data_source,
        ingest_group_id,
        ingest_tags,
        ingest_task_id,
      ]
    enabled: true
  apachedruid.ingest.input.bytes:
    description: Number of bytes read from input sources, after decompression but prior to parsing. This covers all data read, including data that does not end up being fully processed and ingested. For example, this includes data that ends up being rejected for being unparseable or filtered out.
    unit: By
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes:
      [
        ingest_task_type,
        ingest_data_source,
        ingest_group_id,
        ingest_tags,
        ingest_task_id,
      ]
    enabled: true
  apachedruid.ingest.rows.output:
    description: Number of Druid rows persisted.
    unit: "{rows}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes:
      [ingest_task_type, ingest_task_id, ingest_data_source, ingest_group_id]
    enabled: true
  apachedruid.ingest.persists.count:
    description: Number of times persist occurred.
    unit: 1
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes:
      [
        ingest_task_type,
        ingest_data_source,
        ingest_group_id,
        ingest_tags,
        ingest_task_id,
      ]
    enabled: true
  apachedruid.ingest.persists.time:
    description: Milliseconds spent doing intermediate persist.
    unit: ms
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes:
      [
        ingest_task_type,
        ingest_data_source,
        ingest_group_id,
        ingest_tags,
        ingest_task_id,
      ]
    enabled: true
  apachedruid.ingest.persists.cpu:
    description: CPU time in nanoseconds spent on doing intermediate persist.
    unit: ns
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes:
      [
        ingest_task_type,
        ingest_data_source,
        ingest_group_id,
        ingest_tags,
        ingest_task_id,
      ]
    enabled: true
  apachedruid.ingest.persists.back_pressure:
    description: Milliseconds spent creating persist tasks and blocking waiting for them to finish.
    unit: ms
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes:
      [
        ingest_task_type,
        ingest_data_source,
        ingest_group_id,
        ingest_tags,
        ingest_task_id,
      ]
    enabled: true
  apachedruid.ingest.persists.failed:
    description: Number of persists that failed.
    unit: "{persists}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes:
      [
        ingest_task_type,
        ingest_data_source,
        ingest_group_id,
        ingest_tags,
        ingest_task_id,
      ]
    enabled: true
  apachedruid.ingest.handoff.failed:
    description: Number of handoffs that failed.
    unit: "{handoffs}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes:
      [
        ingest_task_type,
        ingest_data_source,
        ingest_group_id,
        ingest_tags,
        ingest_task_id,
      ]
    enabled: true
  apachedruid.ingest.merge.time:
    description: Milliseconds spent merging intermediate segments.
    unit: ms
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes:
      [
        ingest_task_type,
        ingest_data_source,
        ingest_group_id,
        ingest_tags,
        ingest_task_id,
      ]
    enabled: true
  apachedruid.ingest.merge.cpu:
    description: CPU time in Nanoseconds spent on merging intermediate segments.
    unit: ns
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes:
      [
        ingest_task_type,
        ingest_data_source,
        ingest_group_id,
        ingest_tags,
        ingest_task_id,
      ]
    enabled: true
  apachedruid.ingest.handoff.count:
    description: Number of handoffs that happened.
    unit: "{handoffs}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes:
      [
        ingest_task_type,
        ingest_data_source,
        ingest_group_id,
        ingest_tags,
        ingest_task_id,
      ]
    enabled: true
  apachedruid.ingest.sink.count:
    description: Number of sinks not handed off.
    unit: "{sinks}"
    gauge:
      value_type: int
    attributes:
      [
        ingest_task_type,
        ingest_data_source,
        ingest_group_id,
        ingest_tags,
        ingest_task_id,
      ]
    enabled: true
  apachedruid.ingest.events.message_gap:
    description: Time gap in milliseconds between the latest ingested event timestamp and the current system timestamp of metrics emission. If the value is increasing but lag is low, Druid may not be receiving new data. This metric is reset as new tasks spawn up.
    unit: ms
    gauge:
      value_type: int
    attributes:
      [
        ingest_task_type,
        ingest_data_source,
        ingest_group_id,
        ingest_tags,
        ingest_task_id,
      ]
    enabled: true
  apachedruid.ingest.notices.queue_size:
    description: Number of pending notices to be processed by the coordinator.
    unit: "{notices}"
    gauge:
      value_type: int
    attributes: [ingest_tags, ingest_data_source]
    enabled: true
  apachedruid.ingest.notices.time:
    description: Milliseconds taken to process a notice by the supervisor.
    unit: ms
    gauge:
      value_type: int
    attributes: [ingest_tags, ingest_data_source]
    enabled: true
  apachedruid.ingest.pause.time:
    description: Milliseconds spent by a task in a paused state without ingesting.
    unit: ms
    gauge:
      value_type: int
    attributes: [ingest_tags, ingest_task_id, ingest_data_source]
    enabled: true
  apachedruid.ingest.handoff.time:
    description: Total number of milliseconds taken to handoff a set of segments.
    unit: ms
    gauge:
      value_type: int
    attributes:
      [
        ingest_task_type,
        ingest_data_source,
        ingest_group_id,
        ingest_tags,
        ingest_task_id,
      ]
    enabled: true
  apachedruid.task.run.time:
    description: Milliseconds taken to run a task.
    unit: ms
    gauge:
      value_type: int
    attributes:
      [
        task_type,
        task_data_source,
        task_group_id,
        task_status,
        task_tags,
        task_id,
      ]
    enabled: true
  apachedruid.task.pending.time:
    description: Milliseconds taken for a task to wait for running.
    unit: ms
    gauge:
      value_type: int
    attributes: [task_type, task_data_source, task_group_id, task_tags, task_id]
    enabled: true
  apachedruid.task.action.log.time:
    description: Milliseconds taken to log a task action to the audit log.
    unit: ms
    gauge:
      value_type: int
    attributes:
      [
        task_type,
        task_data_source,
        task_action_type,
        task_group_id,
        task_tags,
        task_id,
      ]
    enabled: true
  apachedruid.task.action.run.time:
    description: Milliseconds taken to execute a task action.
    unit: ms
    gauge:
      value_type: int
    attributes:
      [
        task_type,
        task_data_source,
        task_action_type,
        task_group_id,
        task_tags,
        task_id,
      ]
    enabled: true
  apachedruid.task.action.success.count:
    description: Number of task actions that were executed successfully during the emission period. Currently only being emitted for [batched `segmentAllocate` actions](https,//druid.apache.org/docs/latest/ingestion/tasks#batching-segmentallocate-actions).
    unit: "{actions}"
    gauge:
      value_type: int
    attributes:
      [
        task_type,
        task_data_source,
        task_action_type,
        task_group_id,
        task_tags,
        task_id,
      ]
    enabled: true
  apachedruid.task.action.failed.count:
    description: Number of task actions that failed during the emission period. Currently only being emitted for [batched `segmentAllocate` actions](https,//druid.apache.org/docs/latest/ingestion/tasks#batching-segmentallocate-actions).
    unit: "{actions}"
    gauge:
      value_type: int
    attributes:
      [
        task_type,
        task_data_source,
        task_action_type,
        task_group_id,
        task_tags,
        task_id,
      ]
    enabled: true
  apachedruid.task.action.batch.queue_time:
    description: Milliseconds spent by a batch of task actions in queue. Currently only being emitted for [batched `segmentAllocate` actions](https,//druid.apache.org/docs/latest/ingestion/tasks#batching-segmentallocate-actions).
    unit: ms
    gauge:
      value_type: int
    attributes: [task_interval, task_data_source, task_action_type]
    enabled: true
  apachedruid.task.action.batch.run_time:
    description: Milliseconds taken to execute a batch of task actions. Currently only being emitted for [batched `segmentAllocate` actions](https,//druid.apache.org/docs/latest/ingestion/tasks#batching-segmentallocate-actions).
    unit: ms
    gauge:
      value_type: int
    attributes: [task_interval, task_data_source, task_action_type]
    enabled: true
  apachedruid.task.action.batch.size:
    description: Number of task actions in a batch that was executed during the emission period. Currently only being emitted for [batched `segmentAllocate` actions](https,//druid.apache.org/docs/latest/ingestion/tasks#batching-segmentallocate-actions).
    unit: "{actions}"
    gauge:
      value_type: int
    attributes: [task_interval, task_data_source, task_action_type]
    enabled: true
  apachedruid.task.action.batch.attempts:
    description: Number of execution attempts for a single batch of task actions. Currently only being emitted for [batched `segmentAllocate` actions](https,//druid.apache.org/docs/latest/ingestion/tasks#batching-segmentallocate-actions).
    unit: "{attempts}"
    gauge:
      value_type: int
    attributes: [task_interval, task_data_source, task_action_type]
    enabled: true
  apachedruid.task.segment_availability.wait.time:
    description: The amount of milliseconds a batch indexing task waited for newly created segments to become available for querying.
    unit: ms
    gauge:
      value_type: int
    attributes:
      [
        task_type,
        task_data_source,
        task_group_id,
        task_segment_availability_confirmed,
        task_tags,
        task_id,
      ]
    enabled: true
  apachedruid.segment.added.bytes:
    description: Size in bytes of new segments created.
    unit: By
    gauge:
      value_type: int
    attributes:
      [
        segment_task_type,
        segment_data_source,
        segment_group_id,
        segment_tags,
        segment_task_id,
        segment_interval,
      ]
    enabled: true
  apachedruid.segment.moved.bytes:
    description: Size in bytes of segments moved/archived via the Move Task.
    unit: By
    gauge:
      value_type: int
    attributes:
      [
        segment_task_type,
        segment_data_source,
        segment_group_id,
        segment_tags,
        segment_task_id,
        segment_interval,
      ]
    enabled: true
  apachedruid.segment.nuked.bytes:
    description: Size in bytes of segments deleted via the Kill Task.
    unit: By
    gauge:
      value_type: int
    attributes:
      [
        segment_task_type,
        segment_data_source,
        segment_group_id,
        segment_tags,
        segment_task_id,
        segment_interval,
      ]
    enabled: true
  apachedruid.task.success.count:
    description: Number of successful tasks per emission period. This metric is only available if the `TaskCountStatsMonitor` module is included.
    unit: "{tasks}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [task_data_source]
    enabled: true
  apachedruid.task.failed.count:
    description: Number of failed tasks per emission period. This metric is only available if the `TaskCountStatsMonitor` module is included.
    unit: "{tasks}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [task_data_source]
    enabled: true
  apachedruid.task.running.count:
    description: Number of current running tasks. This metric is only available if the `TaskCountStatsMonitor` module is included.
    unit: "{tasks}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [task_data_source]
    enabled: true
  apachedruid.task.pending.count:
    description: Number of current pending tasks. This metric is only available if the `TaskCountStatsMonitor` module is included.
    unit: "{tasks}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [task_data_source]
    enabled: true
  apachedruid.task.waiting.count:
    description: Number of current waiting tasks. This metric is only available if the `TaskCountStatsMonitor` module is included.
    unit: "{tasks}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [task_data_source]
    enabled: true
  apachedruid.task_slot.total.count:
    description: Number of total task slots per emission period. This metric is only available if the `TaskSlotCountStatsMonitor` module is included.
    unit: "{slots}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [taskSlot_category]
    enabled: true
  apachedruid.task_slot.idle.count:
    description: Number of idle task slots per emission period. This metric is only available if the `TaskSlotCountStatsMonitor` module is included.
    unit: "{slots}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [taskSlot_category]
    enabled: true
  apachedruid.task_slot.used.count:
    description: Number of busy task slots per emission period. This metric is only available if the `TaskSlotCountStatsMonitor` module is included.
    unit: "{slots}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [taskSlot_category]
    enabled: true
  apachedruid.task_slot.lazy.count:
    description: Number of total task slots in lazy marked Middle Managers and Indexers per emission period. This metric is only available if the `TaskSlotCountStatsMonitor` module is included.
    unit: "{slots}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [taskSlot_category]
    enabled: true
  apachedruid.task_slot.blacklisted.count:
    description: Number of total task slots in blacklisted Middle Managers and Indexers per emission period. This metric is only available if the `TaskSlotCountStatsMonitor` module is included.
    unit: "{slots}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [taskSlot_category]
    enabled: true
  apachedruid.worker.task.failed.count:
    description: Number of failed tasks run on the reporting worker per emission period. This metric is only available if the `WorkerTaskCountStatsMonitor` module is included, and is only supported for Middle Manager nodes.
    unit: "{tasks}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [worker_category, worker_version]
    enabled: true
  apachedruid.worker.task.success.count:
    description: Number of successful tasks run on the reporting worker per emission period. This metric is only available if the `WorkerTaskCountStatsMonitor` module is included, and is only supported for Middle Manager nodes.
    unit: "{tasks}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [worker_category, worker_version]
    enabled: true
  apachedruid.worker.task_slot.idle.count:
    description: Number of idle task slots on the reporting worker per emission period. This metric is only available if the `WorkerTaskCountStatsMonitor` module is included, and is only supported for Middle Manager nodes.
    unit: "{slots}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [worker_category, worker_version]
    enabled: true
  apachedruid.worker.task_slot.total.count:
    description: Number of total task slots on the reporting worker per emission period. This metric is only available if the `WorkerTaskCountStatsMonitor` module is included.
    unit: "{slots}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [worker_category, worker_version]
    enabled: true
  apachedruid.worker.task_slot.used.count:
    description: Number of busy task slots on the reporting worker per emission period. This metric is only available if the `WorkerTaskCountStatsMonitor` module is included.
    unit: "{slots}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [worker_category, worker_version]
    enabled: true
  apachedruid.ingest.shuffle.bytes:
    description: Number of bytes shuffled per emission period.
    unit: By
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [ingest_supervisor_task_id]
    enabled: true
  apachedruid.ingest.shuffle.requests:
    description: Number of shuffle requests per emission period.
    unit: "{requests}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [ingest_supervisor_task_id]
    enabled: true
  apachedruid.segment.assigned.count:
    description: Number of segments assigned to be loaded in the cluster.
    unit: "{segments}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [segment_tier, segment_data_source]
    enabled: true
  apachedruid.segment.moved.count:
    description: Number of segments moved in the cluster.
    unit: "{segments}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [segment_tier, segment_data_source]
    enabled: true
  apachedruid.segment.dropped.count:
    description: Number of segments chosen to be dropped from the cluster due to being over-replicated.
    unit: "{segments}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [segment_tier, segment_data_source]
    enabled: true
  apachedruid.segment.deleted.count:
    description: Number of segments marked as unused due to drop rules.
    unit: "{segments}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [segment_data_source]
    enabled: true
  apachedruid.segment.unneeded.count:
    description: Number of segments dropped due to being marked as unused.
    unit: "{segments}"
    gauge:
      value_type: int
    attributes: [segment_tier, segment_data_source]
    enabled: true
  apachedruid.segment.assign_skipped.count:
    description: Number of segments that could not be assigned to any server for loading. This can occur due to replication throttling, no available disk space, or a full load queue.
    unit: "{segments}"
    gauge:
      value_type: int
    attributes: [segment_description, segment_tier, segment_data_source]
    enabled: true
  apachedruid.segment.move_skipped.count:
    description: Number of segments that were chosen for balancing but could not be moved. This can occur when segments are already optimally placed.
    unit: "{segments}"
    gauge:
      value_type: int
    attributes: [segment_description, segment_tier, segment_data_source]
    enabled: true
  apachedruid.segment.drop_skipped.count:
    description: Number of segments that could not be dropped from any server.
    unit: "{segments}"
    gauge:
      value_type: int
    attributes: [segment_description, segment_tier, segment_data_source]
    enabled: true
  apachedruid.segment.load_queue.size:
    description: Size in bytes of segments to load.
    unit: By
    gauge:
      value_type: int
    attributes: [segment_server]
    enabled: true
  apachedruid.segment.load_queue.count:
    description: Number of segments to load.
    unit: "{segments}"
    gauge:
      value_type: int
    attributes: [segment_server]
    enabled: true
  apachedruid.segment.drop_queue.count:
    description: Number of segments to drop.
    unit: "{segments}"
    gauge:
      value_type: int
    attributes: [segment_server]
    enabled: true
  apachedruid.segment.load_queue.assigned:
    description: Number of segments assigned for load or drop to the load queue of a server.
    unit: "{segments}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [segment_server, segment_data_source]
    enabled: true
  apachedruid.segment.load_queue.success:
    description: Number of segment assignments that completed successfully.
    unit: 1
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [segment_server, segment_data_source]
    enabled: true
  apachedruid.segment.load_queue.failed:
    description: Number of segment assignments that failed to complete.
    unit: 1
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [segment_server, segment_data_source]
    enabled: true
  apachedruid.segment.load_queue.cancelled:
    description: Number of segment assignments that were canceled before completion.
    unit: 1
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [segment_server, segment_data_source]
    enabled: true
  apachedruid.segment.size:
    description: Total size of used segments in a data source. Emitted only for data sources to which at least one used segment belongs.
    unit: 1
    gauge:
      value_type: int
    attributes: [segment_data_source]
    enabled: true
  apachedruid.segment.count:
    description: Number of used segments belonging to a data source. Emitted only for data sources to which at least one used segment belongs.
    unit: "{segments}"
    gauge:
      value_type: int
    attributes: [segment_priority, segment_tier, segment_data_source]
    enabled: true
  apachedruid.segment.over_shadowed.count:
    description: Number of segments marked as unused due to being overshadowed.
    unit: "{segments}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.segment.unavailable.count:
    description: Number of unique segments left to load until all used segments are available for queries.
    unit: "{segments}"
    gauge:
      value_type: int
    attributes: [segment_data_source]
    enabled: true
  apachedruid.segment.under_replicated.count:
    description: Number of segments, including replicas, left to load until all used segments are available for queries.
    unit: "{segments}"
    gauge:
      value_type: int
    attributes: [segment_tier, segment_data_source]
    enabled: true
  apachedruid.tier.historical.count:
    description: Number of available historical nodes in each tier.
    unit: 1
    gauge:
      value_type: int
    attributes: [tier]
    enabled: true
  apachedruid.tier.replication.factor:
    description: Configured maximum replication factor in each tier.
    unit: 1
    gauge:
      value_type: int
    attributes: [tier]
    enabled: true
  apachedruid.tier.required.capacity:
    description: Total capacity in bytes required in each tier.
    unit: By
    gauge:
      value_type: int
    attributes: [tier]
    enabled: true
  apachedruid.tier.total.capacity:
    description: Total capacity in bytes available in each tier.
    unit: By
    gauge:
      value_type: int
    attributes: [tier]
    enabled: true
  apachedruid.compact.task.count:
    description: Number of tasks issued in the auto compaction run.
    unit: "{tasks}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.compact_task.max_slot.count:
    description: Maximum number of task slots available for auto compaction tasks in the auto compaction run.
    unit: "{slots}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.compact_task.available_slot.count:
    description: Number of available task slots that can be used for auto compaction tasks in the auto compaction run. This is the max number of task slots minus any currently running compaction tasks.
    unit: "{slots}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.kill_task.available_slot.count:
    description: Number of available task slots that can be used for auto kill tasks in the auto kill run. This is the max number of task slots minus any currently running auto kill tasks.
    unit: "{slots}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.kill_task.max_slot.count:
    description: Maximum number of task slots available for auto kill tasks in the auto kill run.
    unit: "{slots}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.kill.task.count:
    description: Number of tasks issued in the auto kill run.
    unit: "{tasks}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.kill.pending_segments.count:
    description: Number of stale pending segments deleted from the metadata store.
    unit: "{segments}"
    gauge:
      value_type: int
    attributes: [kill_data_source]
    enabled: true
  apachedruid.segment.wait_compact.bytes:
    description: Total bytes of this datasource waiting to be compacted by the auto compaction (only consider intervals/segments that are eligible for auto compaction).
    unit: By
    gauge:
      value_type: int
    attributes: [segment_data_source]
    enabled: true
  apachedruid.segment.wait_compact.count:
    description: Total number of segments of this datasource waiting to be compacted by the auto compaction (only consider intervals/segments that are eligible for auto compaction).
    unit: "{segments}"
    gauge:
      value_type: int
    attributes: [segment_data_source]
    enabled: true
  apachedruid.interval.wait_compact.count:
    description: Total number of intervals of this datasource waiting to be compacted by the auto compaction (only consider intervals/segments that are eligible for auto compaction).
    unit: "{intervals}"
    gauge:
      value_type: int
    attributes: [interval_data_source]
    enabled: true
  apachedruid.segment.compacted.bytes:
    description: Total bytes of this datasource that are already compacted with the spec set in the auto compaction config.
    unit: By
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [segment_data_source]
    enabled: true
  apachedruid.segment.compacted.count:
    description: Total number of segments of this datasource that are already compacted with the spec set in the auto compaction config.
    unit: "{segments}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [segment_data_source]
    enabled: true
  apachedruid.interval.compacted.count:
    description: Total number of intervals of this datasource that are already compacted with the spec set in the auto compaction config.
    unit: "{intervals}"
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [interval_data_source]
    enabled: true
  apachedruid.segment.skip_compact.bytes:
    description: Total bytes of this datasource that are skipped (not eligible for auto compaction) by the auto compaction.
    unit: By
    gauge:
      value_type: int
    attributes: [segment_data_source]
    enabled: true
  apachedruid.segment.skip_compact.count:
    description: Total number of segments of this datasource that are skipped (not eligible for auto compaction) by the auto compaction.
    unit: "{segments}"
    gauge:
      value_type: int
    attributes: [segment_data_source]
    enabled: true
  apachedruid.interval.skip_compact.count:
    description: Total number of intervals of this datasource that are skipped (not eligible for auto compaction) by the auto compaction.
    unit: "{intervals}"
    gauge:
      value_type: int
    attributes: [interval_data_source]
    enabled: true
  apachedruid.coordinator.time:
    description: Approximate Coordinator duty runtime in milliseconds.
    unit: ms
    gauge:
      value_type: int
    attributes: [coordinator_duty]
    enabled: true
  apachedruid.coordinator.global.time:
    description: Approximate runtime of a full coordination cycle in milliseconds. The `dutyGroup` dimension indicates what type of coordination this run was. For example, Historical Management or Indexing.
    unit: ms
    gauge:
      value_type: int
    attributes: [coordinator_duty_group]
    enabled: true
  apachedruid.metadata.kill.supervisor.count:
    description: Total number of terminated supervisors that were automatically deleted from metadata store per each Coordinator kill supervisor duty run. This metric can help adjust `druid.coordinator.kill.supervisor.durationToRetain` configuration based on whether more or less terminated supervisors need to be deleted per cycle. This metric is only emitted when `druid.coordinator.kill.supervisor.on` is set to true.
    unit: "{supervisors}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.metadata.kill.audit.count:
    description: Total number of audit logs that were automatically deleted from metadata store per each Coordinator kill audit duty run. This metric can help adjust `druid.coordinator.kill.audit.durationToRetain` configuration based on whether more or less audit logs need to be deleted per cycle. This metric is emitted only when `druid.coordinator.kill.audit.on` is set to true.
    unit: 1
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: []
    enabled: true
  apachedruid.metadata.kill.compaction.count:
    description: Total number of compaction configurations that were automatically deleted from metadata store per each Coordinator kill compaction configuration duty run. This metric is only emitted when `druid.coordinator.kill.compaction.on` is set to true.
    unit: 1
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.metadata.kill.rule.count:
    description: Total number of rules that were automatically deleted from metadata store per each Coordinator kill rule duty run. This metric can help adjust `druid.coordinator.kill.rule.durationToRetain` configuration based on whether more or less rules need to be deleted per cycle. This metric is only emitted when `druid.coordinator.kill.rule.on` is set to true.
    unit: "{rules}"
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.metadata.kill.datasource.count:
    description: Total number of datasource metadata that were automatically deleted from metadata store per each Coordinator kill datasource duty run. Note that datasource metadata only exists for datasource created from supervisor. This metric can help adjust `druid.coordinator.kill.datasource.durationToRetain` configuration based on whether more or less datasource metadata need to be deleted per cycle. This metric is only emitted when `druid.coordinator.kill.datasource.on` is set to true.
    unit: 1
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.segment.max:
    description: Maximum byte limit available for segments.
    unit: 1
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.segment.used:
    description: Bytes used for served segments.
    unit: By
    gauge:
      value_type: int
    attributes: [segment_priority, segment_tier, segment_data_source]
    enabled: true
  apachedruid.segment.used_percent:
    description: Percentage of space used by served segments.
    unit: 1.0
    gauge:
      value_type: double
    attributes: [segment_priority, segment_tier, segment_data_source]
    enabled: true
  apachedruid.segment.pending_delete:
    description: On-disk size in bytes of segments that are waiting to be cleared out.
    unit: By
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.segment.row_count.avg:
    description: The average number of rows per segment on a historical. `SegmentStatsMonitor` must be enabled.
    unit: "{rows}"
    gauge:
      value_type: int
    attributes: [segment_priority, segment_tier, segment_data_source]
    enabled: true
  apachedruid.segment.row_count.range.count:
    description: The number of segments in a bucket. `SegmentStatsMonitor` must be enabled.
    unit: "{segments}"
    gauge:
      value_type: int
    attributes:
      [segment_priority, segment_tier, segment_data_source, segment_range]
    enabled: true
  apachedruid.jvm.pool.committed:
    description: Committed pool.
    unit: By
    gauge:
      value_type: int
    attributes: [jvm_pool_name, jvm_pool_kind]
    enabled: true
  apachedruid.jvm.pool.init:
    description: Initial pool.
    unit: By
    gauge:
      value_type: int
    attributes: [jvm_pool_name, jvm_pool_kind]
    enabled: true
  apachedruid.jvm.pool.max:
    description: Max pool.
    unit: By
    gauge:
      value_type: int
    attributes: [jvm_pool_name, jvm_pool_kind]
    enabled: true
  apachedruid.jvm.pool.used:
    description: Pool used.
    unit: By
    gauge:
      value_type: int
    attributes: [jvm_pool_name, jvm_pool_kind]
    enabled: true
  apachedruid.jvm.bufferpool.count:
    description: Bufferpool count.
    unit: 1
    gauge:
      value_type: int
    attributes: [jvm_bufferpool_name]
    enabled: true
  apachedruid.jvm.bufferpool.used:
    description: Bufferpool used.
    unit: 1
    gauge:
      value_type: int
    attributes: [jvm_bufferpool_name]
    enabled: true
  apachedruid.jvm.bufferpool.capacity:
    description: Bufferpool capacity.
    unit: 1
    gauge:
      value_type: int
    attributes: [jvm_bufferpool_name]
    enabled: true
  apachedruid.jvm.mem.init:
    description: Initial memory.
    unit: By
    gauge:
      value_type: int
    attributes: [jvm_mem_kind]
    enabled: true
  apachedruid.jvm.mem.max:
    description: Max memory.
    unit: By
    gauge:
      value_type: int
    attributes: [jvm_mem_kind]
    enabled: true
  apachedruid.jvm.mem.used:
    description: Used memory.
    unit: By
    gauge:
      value_type: int
    attributes: [jvm_mem_kind]
    enabled: true
  apachedruid.jvm.mem.committed:
    description: Committed memory.
    unit: By
    gauge:
      value_type: int
    attributes: [jvm_mem_kind]
    enabled: true
  apachedruid.jvm.gc.count:
    description: Garbage collection count.
    unit: 1
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [jvm_gc_gen, jvm_gc_name]
    enabled: true
  apachedruid.jvm.gc.cpu:
    description: Count of CPU time in Nanoseconds spent on garbage collection. Note, `jvm/gc/cpu` represents the total time over multiple GC cycles; divide by `jvm/gc/count` to get the mean GC time per cycle.
    unit: ns
    sum:
      monotonic: true
      aggregation_temporality: delta
      value_type: int
    attributes: [jvm_gc_gen, jvm_gc_name]
    enabled: true
  apachedruid.zk.connected:
    description: Indicator of connection status. `1` for connected, `0` for disconnected. Emitted once per monitor period.
    unit: 1
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.zk.reconnect.time:
    description: Amount of time, in milliseconds, that a server was disconnected from ZooKeeper before reconnecting. Emitted on reconnection. Not emitted if connection to ZooKeeper is permanently lost, because in this case, there is no reconnection.
    unit: ms
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.ingest.events.buffered:
    description: Number of events queued in the `EventReceiverFirehose` buffer.
    unit: "{events}"
    gauge:
      value_type: int
    attributes:
      [
        ingest_task_type,
        ingest_data_source,
        ingest_service_name,
        ingest_buffer_capacity,
        ingest_task_id,
      ]
    enabled: true
  apachedruid.ingest.bytes.received:
    description: Number of bytes received by the `EventReceiverFirehose`.
    unit: By
    gauge:
      value_type: int
    attributes:
      [
        ingest_task_type,
        ingest_task_id,
        ingest_data_source,
        ingest_service_name,
      ]
    enabled: true
  apachedruid.sys.swap.free:
    description: Free swap.
    unit: By
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.sys.swap.max:
    description: Max swap.
    unit: By
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.sys.swap.page_in:
    description: Paged in swap.
    unit: 1
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.sys.swap.page_out:
    description: Paged out swap.
    unit: 1
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.sys.disk.write.count:
    description: Writes to disk.
    unit: 1
    gauge:
      value_type: int
    attributes: [sys_disk_name]
    enabled: true
  apachedruid.sys.disk.read.count:
    description: Reads from disk.
    unit: 1
    gauge:
      value_type: int
    attributes: [sys_disk_name]
    enabled: true
  apachedruid.sys.disk.write.size:
    description: Bytes written to disk. One indicator of the amount of paging occurring for segments.
    unit: By
    gauge:
      value_type: int
    attributes: [sys_disk_name]
    enabled: true
  apachedruid.sys.disk.read.size:
    description: Bytes read from disk. One indicator of the amount of paging occurring for segments.
    unit: By
    gauge:
      value_type: int
    attributes: [sys_disk_name]
    enabled: true
  apachedruid.sys.disk.queue:
    description: Disk queue length. Measures number of requests waiting to be processed by disk.
    unit: 1
    gauge:
      value_type: int
    attributes: [sys_disk_name]
    enabled: true
  apachedruid.sys.disk.transfer_time:
    description: Transfer time to read from or write to disk.
    unit: ms
    gauge:
      value_type: int
    attributes: [sys_disk_name]
    enabled: true
  apachedruid.sys.net.write.size:
    description: Bytes written to the network.
    unit: By
    gauge:
      value_type: int
    attributes: [sys_net_hwaddr, sys_net_name, sys_net_address]
    enabled: true
  apachedruid.sys.net.read.size:
    description: Bytes read from the network.
    unit: By
    gauge:
      value_type: int
    attributes: [sys_net_hwaddr, sys_net_name, sys_net_address]
    enabled: true
  apachedruid.sys.net.read.packets:
    description: Total packets read from the network.
    unit: 1
    gauge:
      value_type: int
    attributes: [sys_net_hwaddr, sys_net_name, sys_net_address]
    enabled: true
  apachedruid.sys.net.write.packets:
    description: Total packets written to the network.
    unit: 1
    gauge:
      value_type: int
    attributes: [sys_net_hwaddr, sys_net_name, sys_net_address]
    enabled: true
  apachedruid.sys.net.read.errors:
    description: Total network read errors.
    unit: 1
    gauge:
      value_type: int
    attributes: [sys_net_hwaddr, sys_net_name, sys_net_address]
    enabled: true
  apachedruid.sys.net.write.errors:
    description: Total network write errors.
    unit: 1
    gauge:
      value_type: int
    attributes: [sys_net_hwaddr, sys_net_name, sys_net_address]
    enabled: true
  apachedruid.sys.net.read.dropped:
    description: Total packets dropped coming from network.
    unit: 1
    gauge:
      value_type: int
    attributes: [sys_net_hwaddr, sys_net_name, sys_net_address]
    enabled: true
  apachedruid.sys.net.write.collisions:
    description: Total network write collisions.
    unit: 1
    gauge:
      value_type: int
    attributes: [sys_net_hwaddr, sys_net_name, sys_net_address]
    enabled: true
  apachedruid.sys.fs.used:
    description: Filesystem bytes used.
    unit: By
    gauge:
      value_type: int
    attributes: [sys_fs_dir_name, sys_fs_dev_name]
    enabled: true
  apachedruid.sys.fs.max:
    description: Filesystem bytes max.
    unit: By
    gauge:
      value_type: int
    attributes: [sys_fs_dir_name, sys_fs_dev_name]
    enabled: true
  apachedruid.sys.fs.files.count:
    description: Filesystem total IO nodes.
    unit: 1
    gauge:
      value_type: int
    attributes: [sys_fs_dir_name, sys_fs_dev_name]
    enabled: true
  apachedruid.sys.fs.files.free:
    description: Filesystem free IO nodes.
    unit: 1
    gauge:
      value_type: int
    attributes: [sys_fs_dir_name, sys_fs_dev_name]
    enabled: true
  apachedruid.sys.mem.used:
    description: Memory used.
    unit: By
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.sys.mem.max:
    description: Memory max.
    unit: By
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.sys.mem.free:
    description: Memory free.
    unit: By
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.sys.storage.used:
    description: Disk space used.
    unit: 1
    gauge:
      value_type: int
    attributes: [sys_fs_dir_name]
    enabled: true
  apachedruid.sys.cpu:
    description: CPU used.
    unit: 1
    gauge:
      value_type: int
    attributes: [sys_cpu_time, sys_cpu_name]
    enabled: true
  apachedruid.sys.uptime:
    description: Total system uptime.
    unit: s
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.sys.la.1:
    description: System CPU load averages over past `i` minutes, where `i={1,5,15}`.
    unit: 1
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.sys.la.5:
    description: System CPU load averages over past `i` minutes, where `i={1,5,15}`.
    unit: 1
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.sys.la.15:
    description: System CPU load averages over past `i` minutes, where `i={1,5,15}`.
    unit: 1
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.sys.tcpv4.active_opens:
    description: Total TCP active open connections.
    unit: 1
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.sys.tcpv4.passive_opens:
    description: Total TCP passive open connections.
    unit: 1
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.sys.tcpv4.attempt_fails:
    description: Total TCP active connection failures.
    unit: 1
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.sys.tcpv4.estab_resets:
    description: Total TCP connection resets.
    unit: 1
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.sys.tcpv4.in.segs:
    description: Total segments received in connection.
    unit: 1
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.sys.tcpv4.in.errs:
    description: Errors while reading segments.
    unit: 1
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.sys.tcpv4.out.segs:
    description: Total segments sent.
    unit: 1
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.sys.tcpv4.out.rsts:
    description: Total `out reset` packets sent to reset the connection.
    unit: 1
    gauge:
      value_type: int
    attributes: []
    enabled: true
  apachedruid.sys.tcpv4.retrans.segs:
    description: Total segments re-transmitted.
    unit: 1
    gauge:
      value_type: int
    attributes: []
    enabled: true
