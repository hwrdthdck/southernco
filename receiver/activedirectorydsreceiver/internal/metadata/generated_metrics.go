// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/confmap"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`

	enabledProvidedByUser bool
}

// IsEnabledProvidedByUser returns true if `enabled` option is explicitly set in user settings to any value.
func (ms *MetricSettings) IsEnabledProvidedByUser() bool {
	return ms.enabledProvidedByUser
}

func (ms *MetricSettings) Unmarshal(parser *confmap.Conf) error {
	if parser == nil {
		return nil
	}
	err := parser.Unmarshal(ms, confmap.WithErrorUnused())
	if err != nil {
		return err
	}
	ms.enabledProvidedByUser = parser.IsSet("enabled")
	return nil
}

// MetricsSettings provides settings for activedirectorydsreceiver metrics.
type MetricsSettings struct {
	ActiveDirectoryDsBindRate                                  MetricSettings `mapstructure:"active_directory.ds.bind.rate"`
	ActiveDirectoryDsLdapBindLastSuccessfulTime                MetricSettings `mapstructure:"active_directory.ds.ldap.bind.last_successful.time"`
	ActiveDirectoryDsLdapBindRate                              MetricSettings `mapstructure:"active_directory.ds.ldap.bind.rate"`
	ActiveDirectoryDsLdapClientSessionCount                    MetricSettings `mapstructure:"active_directory.ds.ldap.client.session.count"`
	ActiveDirectoryDsLdapSearchRate                            MetricSettings `mapstructure:"active_directory.ds.ldap.search.rate"`
	ActiveDirectoryDsNameCacheHitRate                          MetricSettings `mapstructure:"active_directory.ds.name_cache.hit_rate"`
	ActiveDirectoryDsNotificationQueued                        MetricSettings `mapstructure:"active_directory.ds.notification.queued"`
	ActiveDirectoryDsOperationRate                             MetricSettings `mapstructure:"active_directory.ds.operation.rate"`
	ActiveDirectoryDsReplicationNetworkIo                      MetricSettings `mapstructure:"active_directory.ds.replication.network.io"`
	ActiveDirectoryDsReplicationObjectRate                     MetricSettings `mapstructure:"active_directory.ds.replication.object.rate"`
	ActiveDirectoryDsReplicationOperationPending               MetricSettings `mapstructure:"active_directory.ds.replication.operation.pending"`
	ActiveDirectoryDsReplicationPropertyRate                   MetricSettings `mapstructure:"active_directory.ds.replication.property.rate"`
	ActiveDirectoryDsReplicationSyncObjectPending              MetricSettings `mapstructure:"active_directory.ds.replication.sync.object.pending"`
	ActiveDirectoryDsReplicationSyncRequestCount               MetricSettings `mapstructure:"active_directory.ds.replication.sync.request.count"`
	ActiveDirectoryDsReplicationValueRate                      MetricSettings `mapstructure:"active_directory.ds.replication.value.rate"`
	ActiveDirectoryDsSecurityDescriptorPropagationsEventQueued MetricSettings `mapstructure:"active_directory.ds.security_descriptor_propagations_event.queued"`
	ActiveDirectoryDsSuboperationRate                          MetricSettings `mapstructure:"active_directory.ds.suboperation.rate"`
	ActiveDirectoryDsThreadCount                               MetricSettings `mapstructure:"active_directory.ds.thread.count"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		ActiveDirectoryDsBindRate: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsLdapBindLastSuccessfulTime: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsLdapBindRate: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsLdapClientSessionCount: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsLdapSearchRate: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsNameCacheHitRate: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsNotificationQueued: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsOperationRate: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsReplicationNetworkIo: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsReplicationObjectRate: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsReplicationOperationPending: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsReplicationPropertyRate: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsReplicationSyncObjectPending: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsReplicationSyncRequestCount: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsReplicationValueRate: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsSecurityDescriptorPropagationsEventQueued: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsSuboperationRate: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsThreadCount: MetricSettings{
			Enabled: true,
		},
	}
}

type attributeClient struct{}

func (av attributeClient) String() string {
	return "client"
}

type attributeCompressed struct{}

func (av attributeCompressed) String() string {
	return "compressed"
}

type attributeDistingushedNames struct{}

func (av attributeDistingushedNames) String() string {
	return "distingushed_names"
}

type attributeOther struct{}

func (av attributeOther) String() string {
	return "other"
}

type attributeRead struct{}

func (av attributeRead) String() string {
	return "read"
}

type attributeReceived struct{}

func (av attributeReceived) String() string {
	return "received"
}

type attributeSchemaMismatch struct{}

func (av attributeSchemaMismatch) String() string {
	return "schema_mismatch"
}

type attributeSearch struct{}

func (av attributeSearch) String() string {
	return "search"
}

type attributeSecurityDescriptorPropagationsEvent struct{}

func (av attributeSecurityDescriptorPropagationsEvent) String() string {
	return "security_descriptor_propagations_event"
}

type attributeSent struct{}

func (av attributeSent) String() string {
	return "sent"
}

type attributeServer struct{}

func (av attributeServer) String() string {
	return "server"
}

type attributeSuccess struct{}

func (av attributeSuccess) String() string {
	return "success"
}

type attributeUncompressed struct{}

func (av attributeUncompressed) String() string {
	return "uncompressed"
}

type attributeWrite struct{}

func (av attributeWrite) String() string {
	return "write"
}

var (
	AttributeClient                              = attributeClient{}
	AttributeCompressed                          = attributeCompressed{}
	AttributeDistingushedNames                   = attributeDistingushedNames{}
	AttributeOther                               = attributeOther{}
	AttributeRead                                = attributeRead{}
	AttributeReceived                            = attributeReceived{}
	AttributeSchemaMismatch                      = attributeSchemaMismatch{}
	AttributeSearch                              = attributeSearch{}
	AttributeSecurityDescriptorPropagationsEvent = attributeSecurityDescriptorPropagationsEvent{}
	AttributeSent                                = attributeSent{}
	AttributeServer                              = attributeServer{}
	AttributeSuccess                             = attributeSuccess{}
	AttributeUncompressed                        = attributeUncompressed{}
	AttributeWrite                               = attributeWrite{}
)

type metricActiveDirectoryDsBindRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.bind.rate metric with initial data.
func (m *metricActiveDirectoryDsBindRate) init() {
	m.data.SetName("active_directory.ds.bind.rate")
	m.data.SetDescription("The number of binds per second serviced by this domain controller.")
	m.data.SetUnit("{binds}/s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

// ActiveDirectoryDsBindRateAttributeType specifies the a value type attribute of active_directory.ds.bind.rate metric.
type ActiveDirectoryDsBindRateAttributeType interface {
	activeDirectoryDsBindRateAttributeType()
	String() string
}

func (av attributeServer) activeDirectoryDsBindRateAttributeType() {}
func (av attributeClient) activeDirectoryDsBindRateAttributeType() {}

// ActiveDirectoryDsBindRateAttributeTypeMap is a helper map to get ActiveDirectoryDsBindRateAttributeType from an attribute value.
var ActiveDirectoryDsBindRateAttributeTypeMap = map[string]ActiveDirectoryDsBindRateAttributeType{
	"server": AttributeServer,
	"client": AttributeClient,
}

func (m *metricActiveDirectoryDsBindRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, typeAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("type", typeAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsBindRate) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsBindRate) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsBindRate(settings MetricSettings) metricActiveDirectoryDsBindRate {
	m := metricActiveDirectoryDsBindRate{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsLdapBindLastSuccessfulTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.ldap.bind.last_successful.time metric with initial data.
func (m *metricActiveDirectoryDsLdapBindLastSuccessfulTime) init() {
	m.data.SetName("active_directory.ds.ldap.bind.last_successful.time")
	m.data.SetDescription("The amount of time taken for the last successful LDAP bind.")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
}

func (m *metricActiveDirectoryDsLdapBindLastSuccessfulTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsLdapBindLastSuccessfulTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsLdapBindLastSuccessfulTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsLdapBindLastSuccessfulTime(settings MetricSettings) metricActiveDirectoryDsLdapBindLastSuccessfulTime {
	m := metricActiveDirectoryDsLdapBindLastSuccessfulTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsLdapBindRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.ldap.bind.rate metric with initial data.
func (m *metricActiveDirectoryDsLdapBindRate) init() {
	m.data.SetName("active_directory.ds.ldap.bind.rate")
	m.data.SetDescription("The number of successful LDAP binds per second.")
	m.data.SetUnit("{binds}/s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricActiveDirectoryDsLdapBindRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsLdapBindRate) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsLdapBindRate) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsLdapBindRate(settings MetricSettings) metricActiveDirectoryDsLdapBindRate {
	m := metricActiveDirectoryDsLdapBindRate{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsLdapClientSessionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.ldap.client.session.count metric with initial data.
func (m *metricActiveDirectoryDsLdapClientSessionCount) init() {
	m.data.SetName("active_directory.ds.ldap.client.session.count")
	m.data.SetDescription("The number of connected LDAP client sessions.")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricActiveDirectoryDsLdapClientSessionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsLdapClientSessionCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsLdapClientSessionCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsLdapClientSessionCount(settings MetricSettings) metricActiveDirectoryDsLdapClientSessionCount {
	m := metricActiveDirectoryDsLdapClientSessionCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsLdapSearchRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.ldap.search.rate metric with initial data.
func (m *metricActiveDirectoryDsLdapSearchRate) init() {
	m.data.SetName("active_directory.ds.ldap.search.rate")
	m.data.SetDescription("The number of LDAP searches per second.")
	m.data.SetUnit("{searches}/s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricActiveDirectoryDsLdapSearchRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsLdapSearchRate) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsLdapSearchRate) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsLdapSearchRate(settings MetricSettings) metricActiveDirectoryDsLdapSearchRate {
	m := metricActiveDirectoryDsLdapSearchRate{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsNameCacheHitRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.name_cache.hit_rate metric with initial data.
func (m *metricActiveDirectoryDsNameCacheHitRate) init() {
	m.data.SetName("active_directory.ds.name_cache.hit_rate")
	m.data.SetDescription("The percentage of directory object name component lookups that are satisfied by the Directory System Agent's name cache.")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricActiveDirectoryDsNameCacheHitRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsNameCacheHitRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsNameCacheHitRate) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsNameCacheHitRate(settings MetricSettings) metricActiveDirectoryDsNameCacheHitRate {
	m := metricActiveDirectoryDsNameCacheHitRate{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsNotificationQueued struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.notification.queued metric with initial data.
func (m *metricActiveDirectoryDsNotificationQueued) init() {
	m.data.SetName("active_directory.ds.notification.queued")
	m.data.SetDescription("The number of pending update notifications that have been queued to push to clients.")
	m.data.SetUnit("{notifications}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricActiveDirectoryDsNotificationQueued) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsNotificationQueued) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsNotificationQueued) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsNotificationQueued(settings MetricSettings) metricActiveDirectoryDsNotificationQueued {
	m := metricActiveDirectoryDsNotificationQueued{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsOperationRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.operation.rate metric with initial data.
func (m *metricActiveDirectoryDsOperationRate) init() {
	m.data.SetName("active_directory.ds.operation.rate")
	m.data.SetDescription("The number of operations performed per second.")
	m.data.SetUnit("{operations}/s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

// ActiveDirectoryDsOperationRateAttributeType specifies the a value type attribute of active_directory.ds.operation.rate metric.
type ActiveDirectoryDsOperationRateAttributeType interface {
	activeDirectoryDsOperationRateAttributeType()
	String() string
}

func (av attributeRead) activeDirectoryDsOperationRateAttributeType()   {}
func (av attributeWrite) activeDirectoryDsOperationRateAttributeType()  {}
func (av attributeSearch) activeDirectoryDsOperationRateAttributeType() {}

// ActiveDirectoryDsOperationRateAttributeTypeMap is a helper map to get ActiveDirectoryDsOperationRateAttributeType from an attribute value.
var ActiveDirectoryDsOperationRateAttributeTypeMap = map[string]ActiveDirectoryDsOperationRateAttributeType{
	"read":   AttributeRead,
	"write":  AttributeWrite,
	"search": AttributeSearch,
}

func (m *metricActiveDirectoryDsOperationRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, typeAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("type", typeAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsOperationRate) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsOperationRate) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsOperationRate(settings MetricSettings) metricActiveDirectoryDsOperationRate {
	m := metricActiveDirectoryDsOperationRate{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsReplicationNetworkIo struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.replication.network.io metric with initial data.
func (m *metricActiveDirectoryDsReplicationNetworkIo) init() {
	m.data.SetName("active_directory.ds.replication.network.io")
	m.data.SetDescription("The amount of network data transmitted by the Directory Replication Agent.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

// ActiveDirectoryDsReplicationNetworkIoAttributeDirection specifies the a value direction attribute of active_directory.ds.replication.network.io metric.
type ActiveDirectoryDsReplicationNetworkIoAttributeDirection interface {
	activeDirectoryDsReplicationNetworkIoAttributeDirection()
	String() string
}

func (av attributeSent) activeDirectoryDsReplicationNetworkIoAttributeDirection()     {}
func (av attributeReceived) activeDirectoryDsReplicationNetworkIoAttributeDirection() {}

// ActiveDirectoryDsReplicationNetworkIoAttributeDirectionMap is a helper map to get ActiveDirectoryDsReplicationNetworkIoAttributeDirection from an attribute value.
var ActiveDirectoryDsReplicationNetworkIoAttributeDirectionMap = map[string]ActiveDirectoryDsReplicationNetworkIoAttributeDirection{
	"sent":     AttributeSent,
	"received": AttributeReceived,
}

// ActiveDirectoryDsReplicationNetworkIoAttributeType specifies the a value type attribute of active_directory.ds.replication.network.io metric.
type ActiveDirectoryDsReplicationNetworkIoAttributeType interface {
	activeDirectoryDsReplicationNetworkIoAttributeType()
	String() string
}

func (av attributeCompressed) activeDirectoryDsReplicationNetworkIoAttributeType()   {}
func (av attributeUncompressed) activeDirectoryDsReplicationNetworkIoAttributeType() {}

// ActiveDirectoryDsReplicationNetworkIoAttributeTypeMap is a helper map to get ActiveDirectoryDsReplicationNetworkIoAttributeType from an attribute value.
var ActiveDirectoryDsReplicationNetworkIoAttributeTypeMap = map[string]ActiveDirectoryDsReplicationNetworkIoAttributeType{
	"compressed":   AttributeCompressed,
	"uncompressed": AttributeUncompressed,
}

func (m *metricActiveDirectoryDsReplicationNetworkIo) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, directionAttribute string, typeAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("direction", directionAttribute)
	dp.Attributes().PutStr("type", typeAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsReplicationNetworkIo) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsReplicationNetworkIo) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsReplicationNetworkIo(settings MetricSettings) metricActiveDirectoryDsReplicationNetworkIo {
	m := metricActiveDirectoryDsReplicationNetworkIo{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsReplicationObjectRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.replication.object.rate metric with initial data.
func (m *metricActiveDirectoryDsReplicationObjectRate) init() {
	m.data.SetName("active_directory.ds.replication.object.rate")
	m.data.SetDescription("The number of objects transmitted by the Directory Replication Agent per second.")
	m.data.SetUnit("{objects}/s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

// ActiveDirectoryDsReplicationObjectRateAttributeDirection specifies the a value direction attribute of active_directory.ds.replication.object.rate metric.
type ActiveDirectoryDsReplicationObjectRateAttributeDirection interface {
	activeDirectoryDsReplicationObjectRateAttributeDirection()
	String() string
}

func (av attributeSent) activeDirectoryDsReplicationObjectRateAttributeDirection()     {}
func (av attributeReceived) activeDirectoryDsReplicationObjectRateAttributeDirection() {}

// ActiveDirectoryDsReplicationObjectRateAttributeDirectionMap is a helper map to get ActiveDirectoryDsReplicationObjectRateAttributeDirection from an attribute value.
var ActiveDirectoryDsReplicationObjectRateAttributeDirectionMap = map[string]ActiveDirectoryDsReplicationObjectRateAttributeDirection{
	"sent":     AttributeSent,
	"received": AttributeReceived,
}

func (m *metricActiveDirectoryDsReplicationObjectRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, directionAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("direction", directionAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsReplicationObjectRate) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsReplicationObjectRate) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsReplicationObjectRate(settings MetricSettings) metricActiveDirectoryDsReplicationObjectRate {
	m := metricActiveDirectoryDsReplicationObjectRate{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsReplicationOperationPending struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.replication.operation.pending metric with initial data.
func (m *metricActiveDirectoryDsReplicationOperationPending) init() {
	m.data.SetName("active_directory.ds.replication.operation.pending")
	m.data.SetDescription("The number of pending replication operations for the Directory Replication Agent.")
	m.data.SetUnit("{operations}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricActiveDirectoryDsReplicationOperationPending) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsReplicationOperationPending) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsReplicationOperationPending) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsReplicationOperationPending(settings MetricSettings) metricActiveDirectoryDsReplicationOperationPending {
	m := metricActiveDirectoryDsReplicationOperationPending{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsReplicationPropertyRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.replication.property.rate metric with initial data.
func (m *metricActiveDirectoryDsReplicationPropertyRate) init() {
	m.data.SetName("active_directory.ds.replication.property.rate")
	m.data.SetDescription("The number of properties transmitted by the Directory Replication Agent per second.")
	m.data.SetUnit("{properties}/s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

// ActiveDirectoryDsReplicationPropertyRateAttributeDirection specifies the a value direction attribute of active_directory.ds.replication.property.rate metric.
type ActiveDirectoryDsReplicationPropertyRateAttributeDirection interface {
	activeDirectoryDsReplicationPropertyRateAttributeDirection()
	String() string
}

func (av attributeSent) activeDirectoryDsReplicationPropertyRateAttributeDirection()     {}
func (av attributeReceived) activeDirectoryDsReplicationPropertyRateAttributeDirection() {}

// ActiveDirectoryDsReplicationPropertyRateAttributeDirectionMap is a helper map to get ActiveDirectoryDsReplicationPropertyRateAttributeDirection from an attribute value.
var ActiveDirectoryDsReplicationPropertyRateAttributeDirectionMap = map[string]ActiveDirectoryDsReplicationPropertyRateAttributeDirection{
	"sent":     AttributeSent,
	"received": AttributeReceived,
}

func (m *metricActiveDirectoryDsReplicationPropertyRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, directionAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("direction", directionAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsReplicationPropertyRate) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsReplicationPropertyRate) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsReplicationPropertyRate(settings MetricSettings) metricActiveDirectoryDsReplicationPropertyRate {
	m := metricActiveDirectoryDsReplicationPropertyRate{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsReplicationSyncObjectPending struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.replication.sync.object.pending metric with initial data.
func (m *metricActiveDirectoryDsReplicationSyncObjectPending) init() {
	m.data.SetName("active_directory.ds.replication.sync.object.pending")
	m.data.SetDescription("The number of objects remaining until the full sync completes for the Directory Replication Agent.")
	m.data.SetUnit("{objects}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricActiveDirectoryDsReplicationSyncObjectPending) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsReplicationSyncObjectPending) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsReplicationSyncObjectPending) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsReplicationSyncObjectPending(settings MetricSettings) metricActiveDirectoryDsReplicationSyncObjectPending {
	m := metricActiveDirectoryDsReplicationSyncObjectPending{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsReplicationSyncRequestCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.replication.sync.request.count metric with initial data.
func (m *metricActiveDirectoryDsReplicationSyncRequestCount) init() {
	m.data.SetName("active_directory.ds.replication.sync.request.count")
	m.data.SetDescription("The number of sync requests made by the Directory Replication Agent.")
	m.data.SetUnit("{requests}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

// ActiveDirectoryDsReplicationSyncRequestCountAttributeResult specifies the a value result attribute of active_directory.ds.replication.sync.request.count metric.
type ActiveDirectoryDsReplicationSyncRequestCountAttributeResult interface {
	activeDirectoryDsReplicationSyncRequestCountAttributeResult()
	String() string
}

func (av attributeSuccess) activeDirectoryDsReplicationSyncRequestCountAttributeResult()        {}
func (av attributeSchemaMismatch) activeDirectoryDsReplicationSyncRequestCountAttributeResult() {}
func (av attributeOther) activeDirectoryDsReplicationSyncRequestCountAttributeResult()          {}

// ActiveDirectoryDsReplicationSyncRequestCountAttributeResultMap is a helper map to get ActiveDirectoryDsReplicationSyncRequestCountAttributeResult from an attribute value.
var ActiveDirectoryDsReplicationSyncRequestCountAttributeResultMap = map[string]ActiveDirectoryDsReplicationSyncRequestCountAttributeResult{
	"success":         AttributeSuccess,
	"schema_mismatch": AttributeSchemaMismatch,
	"other":           AttributeOther,
}

func (m *metricActiveDirectoryDsReplicationSyncRequestCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, resultAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("result", resultAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsReplicationSyncRequestCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsReplicationSyncRequestCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsReplicationSyncRequestCount(settings MetricSettings) metricActiveDirectoryDsReplicationSyncRequestCount {
	m := metricActiveDirectoryDsReplicationSyncRequestCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsReplicationValueRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.replication.value.rate metric with initial data.
func (m *metricActiveDirectoryDsReplicationValueRate) init() {
	m.data.SetName("active_directory.ds.replication.value.rate")
	m.data.SetDescription("The number of values transmitted by the Directory Replication Agent per second.")
	m.data.SetUnit("{values}/s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

// ActiveDirectoryDsReplicationValueRateAttributeDirection specifies the a value direction attribute of active_directory.ds.replication.value.rate metric.
type ActiveDirectoryDsReplicationValueRateAttributeDirection interface {
	activeDirectoryDsReplicationValueRateAttributeDirection()
	String() string
}

func (av attributeSent) activeDirectoryDsReplicationValueRateAttributeDirection()     {}
func (av attributeReceived) activeDirectoryDsReplicationValueRateAttributeDirection() {}

// ActiveDirectoryDsReplicationValueRateAttributeDirectionMap is a helper map to get ActiveDirectoryDsReplicationValueRateAttributeDirection from an attribute value.
var ActiveDirectoryDsReplicationValueRateAttributeDirectionMap = map[string]ActiveDirectoryDsReplicationValueRateAttributeDirection{
	"sent":     AttributeSent,
	"received": AttributeReceived,
}

// ActiveDirectoryDsReplicationValueRateAttributeType specifies the a value type attribute of active_directory.ds.replication.value.rate metric.
type ActiveDirectoryDsReplicationValueRateAttributeType interface {
	activeDirectoryDsReplicationValueRateAttributeType()
	String() string
}

func (av attributeDistingushedNames) activeDirectoryDsReplicationValueRateAttributeType() {}
func (av attributeOther) activeDirectoryDsReplicationValueRateAttributeType()             {}

// ActiveDirectoryDsReplicationValueRateAttributeTypeMap is a helper map to get ActiveDirectoryDsReplicationValueRateAttributeType from an attribute value.
var ActiveDirectoryDsReplicationValueRateAttributeTypeMap = map[string]ActiveDirectoryDsReplicationValueRateAttributeType{
	"distingushed_names": AttributeDistingushedNames,
	"other":              AttributeOther,
}

func (m *metricActiveDirectoryDsReplicationValueRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, directionAttribute string, typeAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("direction", directionAttribute)
	dp.Attributes().PutStr("type", typeAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsReplicationValueRate) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsReplicationValueRate) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsReplicationValueRate(settings MetricSettings) metricActiveDirectoryDsReplicationValueRate {
	m := metricActiveDirectoryDsReplicationValueRate{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.security_descriptor_propagations_event.queued metric with initial data.
func (m *metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued) init() {
	m.data.SetName("active_directory.ds.security_descriptor_propagations_event.queued")
	m.data.SetDescription("The number of security descriptor propagation events that are queued for processing.")
	m.data.SetUnit("{events}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued(settings MetricSettings) metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued {
	m := metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsSuboperationRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.suboperation.rate metric with initial data.
func (m *metricActiveDirectoryDsSuboperationRate) init() {
	m.data.SetName("active_directory.ds.suboperation.rate")
	m.data.SetDescription("The rate of sub-operations performed.")
	m.data.SetUnit("{suboperations}/s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

// ActiveDirectoryDsSuboperationRateAttributeType specifies the a value type attribute of active_directory.ds.suboperation.rate metric.
type ActiveDirectoryDsSuboperationRateAttributeType interface {
	activeDirectoryDsSuboperationRateAttributeType()
	String() string
}

func (av attributeSecurityDescriptorPropagationsEvent) activeDirectoryDsSuboperationRateAttributeType() {
}
func (av attributeSearch) activeDirectoryDsSuboperationRateAttributeType() {}

// ActiveDirectoryDsSuboperationRateAttributeTypeMap is a helper map to get ActiveDirectoryDsSuboperationRateAttributeType from an attribute value.
var ActiveDirectoryDsSuboperationRateAttributeTypeMap = map[string]ActiveDirectoryDsSuboperationRateAttributeType{
	"security_descriptor_propagations_event": AttributeSecurityDescriptorPropagationsEvent,
	"search":                                 AttributeSearch,
}

func (m *metricActiveDirectoryDsSuboperationRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, typeAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("type", typeAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsSuboperationRate) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsSuboperationRate) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsSuboperationRate(settings MetricSettings) metricActiveDirectoryDsSuboperationRate {
	m := metricActiveDirectoryDsSuboperationRate{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsThreadCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.thread.count metric with initial data.
func (m *metricActiveDirectoryDsThreadCount) init() {
	m.data.SetName("active_directory.ds.thread.count")
	m.data.SetDescription("The number of threads in use by the directory service.")
	m.data.SetUnit("{threads}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricActiveDirectoryDsThreadCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsThreadCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsThreadCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsThreadCount(settings MetricSettings) metricActiveDirectoryDsThreadCount {
	m := metricActiveDirectoryDsThreadCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                                                        pcommon.Timestamp   // start time that will be applied to all recorded data points.
	metricsCapacity                                                  int                 // maximum observed number of metrics per resource.
	resourceCapacity                                                 int                 // maximum observed number of resource attributes.
	metricsBuffer                                                    pmetric.Metrics     // accumulates metrics data before emitting.
	buildInfo                                                        component.BuildInfo // contains version information
	metricActiveDirectoryDsBindRate                                  metricActiveDirectoryDsBindRate
	metricActiveDirectoryDsLdapBindLastSuccessfulTime                metricActiveDirectoryDsLdapBindLastSuccessfulTime
	metricActiveDirectoryDsLdapBindRate                              metricActiveDirectoryDsLdapBindRate
	metricActiveDirectoryDsLdapClientSessionCount                    metricActiveDirectoryDsLdapClientSessionCount
	metricActiveDirectoryDsLdapSearchRate                            metricActiveDirectoryDsLdapSearchRate
	metricActiveDirectoryDsNameCacheHitRate                          metricActiveDirectoryDsNameCacheHitRate
	metricActiveDirectoryDsNotificationQueued                        metricActiveDirectoryDsNotificationQueued
	metricActiveDirectoryDsOperationRate                             metricActiveDirectoryDsOperationRate
	metricActiveDirectoryDsReplicationNetworkIo                      metricActiveDirectoryDsReplicationNetworkIo
	metricActiveDirectoryDsReplicationObjectRate                     metricActiveDirectoryDsReplicationObjectRate
	metricActiveDirectoryDsReplicationOperationPending               metricActiveDirectoryDsReplicationOperationPending
	metricActiveDirectoryDsReplicationPropertyRate                   metricActiveDirectoryDsReplicationPropertyRate
	metricActiveDirectoryDsReplicationSyncObjectPending              metricActiveDirectoryDsReplicationSyncObjectPending
	metricActiveDirectoryDsReplicationSyncRequestCount               metricActiveDirectoryDsReplicationSyncRequestCount
	metricActiveDirectoryDsReplicationValueRate                      metricActiveDirectoryDsReplicationValueRate
	metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued
	metricActiveDirectoryDsSuboperationRate                          metricActiveDirectoryDsSuboperationRate
	metricActiveDirectoryDsThreadCount                               metricActiveDirectoryDsThreadCount
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(settings MetricsSettings, buildInfo component.BuildInfo, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                       pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                   pmetric.NewMetrics(),
		buildInfo:                       buildInfo,
		metricActiveDirectoryDsBindRate: newMetricActiveDirectoryDsBindRate(settings.ActiveDirectoryDsBindRate),
		metricActiveDirectoryDsLdapBindLastSuccessfulTime:                newMetricActiveDirectoryDsLdapBindLastSuccessfulTime(settings.ActiveDirectoryDsLdapBindLastSuccessfulTime),
		metricActiveDirectoryDsLdapBindRate:                              newMetricActiveDirectoryDsLdapBindRate(settings.ActiveDirectoryDsLdapBindRate),
		metricActiveDirectoryDsLdapClientSessionCount:                    newMetricActiveDirectoryDsLdapClientSessionCount(settings.ActiveDirectoryDsLdapClientSessionCount),
		metricActiveDirectoryDsLdapSearchRate:                            newMetricActiveDirectoryDsLdapSearchRate(settings.ActiveDirectoryDsLdapSearchRate),
		metricActiveDirectoryDsNameCacheHitRate:                          newMetricActiveDirectoryDsNameCacheHitRate(settings.ActiveDirectoryDsNameCacheHitRate),
		metricActiveDirectoryDsNotificationQueued:                        newMetricActiveDirectoryDsNotificationQueued(settings.ActiveDirectoryDsNotificationQueued),
		metricActiveDirectoryDsOperationRate:                             newMetricActiveDirectoryDsOperationRate(settings.ActiveDirectoryDsOperationRate),
		metricActiveDirectoryDsReplicationNetworkIo:                      newMetricActiveDirectoryDsReplicationNetworkIo(settings.ActiveDirectoryDsReplicationNetworkIo),
		metricActiveDirectoryDsReplicationObjectRate:                     newMetricActiveDirectoryDsReplicationObjectRate(settings.ActiveDirectoryDsReplicationObjectRate),
		metricActiveDirectoryDsReplicationOperationPending:               newMetricActiveDirectoryDsReplicationOperationPending(settings.ActiveDirectoryDsReplicationOperationPending),
		metricActiveDirectoryDsReplicationPropertyRate:                   newMetricActiveDirectoryDsReplicationPropertyRate(settings.ActiveDirectoryDsReplicationPropertyRate),
		metricActiveDirectoryDsReplicationSyncObjectPending:              newMetricActiveDirectoryDsReplicationSyncObjectPending(settings.ActiveDirectoryDsReplicationSyncObjectPending),
		metricActiveDirectoryDsReplicationSyncRequestCount:               newMetricActiveDirectoryDsReplicationSyncRequestCount(settings.ActiveDirectoryDsReplicationSyncRequestCount),
		metricActiveDirectoryDsReplicationValueRate:                      newMetricActiveDirectoryDsReplicationValueRate(settings.ActiveDirectoryDsReplicationValueRate),
		metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued: newMetricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued(settings.ActiveDirectoryDsSecurityDescriptorPropagationsEventQueued),
		metricActiveDirectoryDsSuboperationRate:                          newMetricActiveDirectoryDsSuboperationRate(settings.ActiveDirectoryDsSuboperationRate),
		metricActiveDirectoryDsThreadCount:                               newMetricActiveDirectoryDsThreadCount(settings.ActiveDirectoryDsThreadCount),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
	if mb.resourceCapacity < rm.Resource().Attributes().Len() {
		mb.resourceCapacity = rm.Resource().Attributes().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption func(pmetric.ResourceMetrics)

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	}
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(rmo ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	rm.Resource().Attributes().EnsureCapacity(mb.resourceCapacity)
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("otelcol/activedirectorydsreceiver")
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricActiveDirectoryDsBindRate.emit(ils.Metrics())
	mb.metricActiveDirectoryDsLdapBindLastSuccessfulTime.emit(ils.Metrics())
	mb.metricActiveDirectoryDsLdapBindRate.emit(ils.Metrics())
	mb.metricActiveDirectoryDsLdapClientSessionCount.emit(ils.Metrics())
	mb.metricActiveDirectoryDsLdapSearchRate.emit(ils.Metrics())
	mb.metricActiveDirectoryDsNameCacheHitRate.emit(ils.Metrics())
	mb.metricActiveDirectoryDsNotificationQueued.emit(ils.Metrics())
	mb.metricActiveDirectoryDsOperationRate.emit(ils.Metrics())
	mb.metricActiveDirectoryDsReplicationNetworkIo.emit(ils.Metrics())
	mb.metricActiveDirectoryDsReplicationObjectRate.emit(ils.Metrics())
	mb.metricActiveDirectoryDsReplicationOperationPending.emit(ils.Metrics())
	mb.metricActiveDirectoryDsReplicationPropertyRate.emit(ils.Metrics())
	mb.metricActiveDirectoryDsReplicationSyncObjectPending.emit(ils.Metrics())
	mb.metricActiveDirectoryDsReplicationSyncRequestCount.emit(ils.Metrics())
	mb.metricActiveDirectoryDsReplicationValueRate.emit(ils.Metrics())
	mb.metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued.emit(ils.Metrics())
	mb.metricActiveDirectoryDsSuboperationRate.emit(ils.Metrics())
	mb.metricActiveDirectoryDsThreadCount.emit(ils.Metrics())
	for _, op := range rmo {
		op(rm)
	}
	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user settings, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(rmo ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(rmo...)
	metrics := pmetric.NewMetrics()
	mb.metricsBuffer.MoveTo(metrics)
	return metrics
}

// RecordActiveDirectoryDsBindRateDataPoint adds a data point to active_directory.ds.bind.rate metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsBindRateDataPoint(ts pcommon.Timestamp, val float64, typeAttribute ActiveDirectoryDsBindRateAttributeType) {
	mb.metricActiveDirectoryDsBindRate.recordDataPoint(mb.startTime, ts, val, typeAttribute.String())
}

// RecordActiveDirectoryDsLdapBindLastSuccessfulTimeDataPoint adds a data point to active_directory.ds.ldap.bind.last_successful.time metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsLdapBindLastSuccessfulTimeDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricActiveDirectoryDsLdapBindLastSuccessfulTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordActiveDirectoryDsLdapBindRateDataPoint adds a data point to active_directory.ds.ldap.bind.rate metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsLdapBindRateDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricActiveDirectoryDsLdapBindRate.recordDataPoint(mb.startTime, ts, val)
}

// RecordActiveDirectoryDsLdapClientSessionCountDataPoint adds a data point to active_directory.ds.ldap.client.session.count metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsLdapClientSessionCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricActiveDirectoryDsLdapClientSessionCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordActiveDirectoryDsLdapSearchRateDataPoint adds a data point to active_directory.ds.ldap.search.rate metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsLdapSearchRateDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricActiveDirectoryDsLdapSearchRate.recordDataPoint(mb.startTime, ts, val)
}

// RecordActiveDirectoryDsNameCacheHitRateDataPoint adds a data point to active_directory.ds.name_cache.hit_rate metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsNameCacheHitRateDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricActiveDirectoryDsNameCacheHitRate.recordDataPoint(mb.startTime, ts, val)
}

// RecordActiveDirectoryDsNotificationQueuedDataPoint adds a data point to active_directory.ds.notification.queued metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsNotificationQueuedDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricActiveDirectoryDsNotificationQueued.recordDataPoint(mb.startTime, ts, val)
}

// RecordActiveDirectoryDsOperationRateDataPoint adds a data point to active_directory.ds.operation.rate metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsOperationRateDataPoint(ts pcommon.Timestamp, val float64, typeAttribute ActiveDirectoryDsOperationRateAttributeType) {
	mb.metricActiveDirectoryDsOperationRate.recordDataPoint(mb.startTime, ts, val, typeAttribute.String())
}

// RecordActiveDirectoryDsReplicationNetworkIoDataPoint adds a data point to active_directory.ds.replication.network.io metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsReplicationNetworkIoDataPoint(ts pcommon.Timestamp, val int64, directionAttribute ActiveDirectoryDsReplicationNetworkIoAttributeDirection, typeAttribute ActiveDirectoryDsReplicationNetworkIoAttributeType) {
	mb.metricActiveDirectoryDsReplicationNetworkIo.recordDataPoint(mb.startTime, ts, val, directionAttribute.String(), typeAttribute.String())
}

// RecordActiveDirectoryDsReplicationObjectRateDataPoint adds a data point to active_directory.ds.replication.object.rate metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsReplicationObjectRateDataPoint(ts pcommon.Timestamp, val float64, directionAttribute ActiveDirectoryDsReplicationObjectRateAttributeDirection) {
	mb.metricActiveDirectoryDsReplicationObjectRate.recordDataPoint(mb.startTime, ts, val, directionAttribute.String())
}

// RecordActiveDirectoryDsReplicationOperationPendingDataPoint adds a data point to active_directory.ds.replication.operation.pending metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsReplicationOperationPendingDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricActiveDirectoryDsReplicationOperationPending.recordDataPoint(mb.startTime, ts, val)
}

// RecordActiveDirectoryDsReplicationPropertyRateDataPoint adds a data point to active_directory.ds.replication.property.rate metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsReplicationPropertyRateDataPoint(ts pcommon.Timestamp, val float64, directionAttribute ActiveDirectoryDsReplicationPropertyRateAttributeDirection) {
	mb.metricActiveDirectoryDsReplicationPropertyRate.recordDataPoint(mb.startTime, ts, val, directionAttribute.String())
}

// RecordActiveDirectoryDsReplicationSyncObjectPendingDataPoint adds a data point to active_directory.ds.replication.sync.object.pending metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsReplicationSyncObjectPendingDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricActiveDirectoryDsReplicationSyncObjectPending.recordDataPoint(mb.startTime, ts, val)
}

// RecordActiveDirectoryDsReplicationSyncRequestCountDataPoint adds a data point to active_directory.ds.replication.sync.request.count metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsReplicationSyncRequestCountDataPoint(ts pcommon.Timestamp, val int64, resultAttribute ActiveDirectoryDsReplicationSyncRequestCountAttributeResult) {
	mb.metricActiveDirectoryDsReplicationSyncRequestCount.recordDataPoint(mb.startTime, ts, val, resultAttribute.String())
}

// RecordActiveDirectoryDsReplicationValueRateDataPoint adds a data point to active_directory.ds.replication.value.rate metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsReplicationValueRateDataPoint(ts pcommon.Timestamp, val float64, directionAttribute ActiveDirectoryDsReplicationValueRateAttributeDirection, typeAttribute ActiveDirectoryDsReplicationValueRateAttributeType) {
	mb.metricActiveDirectoryDsReplicationValueRate.recordDataPoint(mb.startTime, ts, val, directionAttribute.String(), typeAttribute.String())
}

// RecordActiveDirectoryDsSecurityDescriptorPropagationsEventQueuedDataPoint adds a data point to active_directory.ds.security_descriptor_propagations_event.queued metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsSecurityDescriptorPropagationsEventQueuedDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued.recordDataPoint(mb.startTime, ts, val)
}

// RecordActiveDirectoryDsSuboperationRateDataPoint adds a data point to active_directory.ds.suboperation.rate metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsSuboperationRateDataPoint(ts pcommon.Timestamp, val float64, typeAttribute ActiveDirectoryDsSuboperationRateAttributeType) {
	mb.metricActiveDirectoryDsSuboperationRate.recordDataPoint(mb.startTime, ts, val, typeAttribute.String())
}

// RecordActiveDirectoryDsThreadCountDataPoint adds a data point to active_directory.ds.thread.count metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsThreadCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricActiveDirectoryDsThreadCount.recordDataPoint(mb.startTime, ts, val)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}
