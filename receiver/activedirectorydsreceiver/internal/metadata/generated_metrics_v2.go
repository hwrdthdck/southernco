// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`
}

// MetricsSettings provides settings for activedirectorydsreceiver metrics.
type MetricsSettings struct {
	ActiveDirectoryDsBindRate                                  MetricSettings `mapstructure:"active_directory.ds.bind.rate"`
	ActiveDirectoryDsLdapBindLastSuccessfulTime                MetricSettings `mapstructure:"active_directory.ds.ldap.bind.last_successful.time"`
	ActiveDirectoryDsLdapBindRate                              MetricSettings `mapstructure:"active_directory.ds.ldap.bind.rate"`
	ActiveDirectoryDsLdapClientSessionCount                    MetricSettings `mapstructure:"active_directory.ds.ldap.client.session.count"`
	ActiveDirectoryDsLdapSearchRate                            MetricSettings `mapstructure:"active_directory.ds.ldap.search.rate"`
	ActiveDirectoryDsNameCacheHitRate                          MetricSettings `mapstructure:"active_directory.ds.name_cache.hit_rate"`
	ActiveDirectoryDsNotificationQueued                        MetricSettings `mapstructure:"active_directory.ds.notification.queued"`
	ActiveDirectoryDsOperationRate                             MetricSettings `mapstructure:"active_directory.ds.operation.rate"`
	ActiveDirectoryDsReplicationNetworkIo                      MetricSettings `mapstructure:"active_directory.ds.replication.network.io"`
	ActiveDirectoryDsReplicationObjectRate                     MetricSettings `mapstructure:"active_directory.ds.replication.object.rate"`
	ActiveDirectoryDsReplicationOperationPending               MetricSettings `mapstructure:"active_directory.ds.replication.operation.pending"`
	ActiveDirectoryDsReplicationPropertyRate                   MetricSettings `mapstructure:"active_directory.ds.replication.property.rate"`
	ActiveDirectoryDsReplicationSyncObjectPending              MetricSettings `mapstructure:"active_directory.ds.replication.sync.object.pending"`
	ActiveDirectoryDsReplicationSyncRequestCount               MetricSettings `mapstructure:"active_directory.ds.replication.sync.request.count"`
	ActiveDirectoryDsReplicationValueRate                      MetricSettings `mapstructure:"active_directory.ds.replication.value.rate"`
	ActiveDirectoryDsSecurityDescriptorPropagationsEventQueued MetricSettings `mapstructure:"active_directory.ds.security_descriptor_propagations_event.queued"`
	ActiveDirectoryDsSuboperationRate                          MetricSettings `mapstructure:"active_directory.ds.suboperation.rate"`
	ActiveDirectoryDsThreadCount                               MetricSettings `mapstructure:"active_directory.ds.thread.count"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		ActiveDirectoryDsBindRate: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsLdapBindLastSuccessfulTime: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsLdapBindRate: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsLdapClientSessionCount: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsLdapSearchRate: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsNameCacheHitRate: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsNotificationQueued: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsOperationRate: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsReplicationNetworkIo: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsReplicationObjectRate: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsReplicationOperationPending: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsReplicationPropertyRate: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsReplicationSyncObjectPending: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsReplicationSyncRequestCount: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsReplicationValueRate: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsSecurityDescriptorPropagationsEventQueued: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsSuboperationRate: MetricSettings{
			Enabled: true,
		},
		ActiveDirectoryDsThreadCount: MetricSettings{
			Enabled: true,
		},
	}
}

type metricActiveDirectoryDsBindRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.bind.rate metric with initial data.
func (m *metricActiveDirectoryDsBindRate) init() {
	m.data.SetName("active_directory.ds.bind.rate")
	m.data.SetDescription("The number of binds per second serviced by this domain controller.")
	m.data.SetUnit("{binds}/s")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricActiveDirectoryDsBindRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, bindTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.BindType, pcommon.NewValueString(bindTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsBindRate) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsBindRate) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsBindRate(settings MetricSettings) metricActiveDirectoryDsBindRate {
	m := metricActiveDirectoryDsBindRate{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsLdapBindLastSuccessfulTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.ldap.bind.last_successful.time metric with initial data.
func (m *metricActiveDirectoryDsLdapBindLastSuccessfulTime) init() {
	m.data.SetName("active_directory.ds.ldap.bind.last_successful.time")
	m.data.SetDescription("The amount of time taken for the last successful LDAP bind.")
	m.data.SetUnit("ms")
	m.data.SetDataType(pmetric.MetricDataTypeGauge)
}

func (m *metricActiveDirectoryDsLdapBindLastSuccessfulTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsLdapBindLastSuccessfulTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsLdapBindLastSuccessfulTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsLdapBindLastSuccessfulTime(settings MetricSettings) metricActiveDirectoryDsLdapBindLastSuccessfulTime {
	m := metricActiveDirectoryDsLdapBindLastSuccessfulTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsLdapBindRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.ldap.bind.rate metric with initial data.
func (m *metricActiveDirectoryDsLdapBindRate) init() {
	m.data.SetName("active_directory.ds.ldap.bind.rate")
	m.data.SetDescription("The number of successful LDAP binds per second.")
	m.data.SetUnit("{binds}/s")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricActiveDirectoryDsLdapBindRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsLdapBindRate) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsLdapBindRate) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsLdapBindRate(settings MetricSettings) metricActiveDirectoryDsLdapBindRate {
	m := metricActiveDirectoryDsLdapBindRate{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsLdapClientSessionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.ldap.client.session.count metric with initial data.
func (m *metricActiveDirectoryDsLdapClientSessionCount) init() {
	m.data.SetName("active_directory.ds.ldap.client.session.count")
	m.data.SetDescription("The number of connected LDAP client sessions.")
	m.data.SetUnit("{sessions}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricActiveDirectoryDsLdapClientSessionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsLdapClientSessionCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsLdapClientSessionCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsLdapClientSessionCount(settings MetricSettings) metricActiveDirectoryDsLdapClientSessionCount {
	m := metricActiveDirectoryDsLdapClientSessionCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsLdapSearchRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.ldap.search.rate metric with initial data.
func (m *metricActiveDirectoryDsLdapSearchRate) init() {
	m.data.SetName("active_directory.ds.ldap.search.rate")
	m.data.SetDescription("The number of LDAP searches per second.")
	m.data.SetUnit("{searches}/s")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricActiveDirectoryDsLdapSearchRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsLdapSearchRate) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsLdapSearchRate) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsLdapSearchRate(settings MetricSettings) metricActiveDirectoryDsLdapSearchRate {
	m := metricActiveDirectoryDsLdapSearchRate{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsNameCacheHitRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.name_cache.hit_rate metric with initial data.
func (m *metricActiveDirectoryDsNameCacheHitRate) init() {
	m.data.SetName("active_directory.ds.name_cache.hit_rate")
	m.data.SetDescription("The percentage of directory object name component lookups that are satisfied by the Directory System Agent's name cache.")
	m.data.SetUnit("%")
	m.data.SetDataType(pmetric.MetricDataTypeGauge)
}

func (m *metricActiveDirectoryDsNameCacheHitRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsNameCacheHitRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsNameCacheHitRate) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsNameCacheHitRate(settings MetricSettings) metricActiveDirectoryDsNameCacheHitRate {
	m := metricActiveDirectoryDsNameCacheHitRate{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsNotificationQueued struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.notification.queued metric with initial data.
func (m *metricActiveDirectoryDsNotificationQueued) init() {
	m.data.SetName("active_directory.ds.notification.queued")
	m.data.SetDescription("The number of pending update notifications that have been queued to push to clients.")
	m.data.SetUnit("{notifications}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricActiveDirectoryDsNotificationQueued) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsNotificationQueued) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsNotificationQueued) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsNotificationQueued(settings MetricSettings) metricActiveDirectoryDsNotificationQueued {
	m := metricActiveDirectoryDsNotificationQueued{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsOperationRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.operation.rate metric with initial data.
func (m *metricActiveDirectoryDsOperationRate) init() {
	m.data.SetName("active_directory.ds.operation.rate")
	m.data.SetDescription("The number of operations performed per second.")
	m.data.SetUnit("{operations}/s")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricActiveDirectoryDsOperationRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, operationTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.OperationType, pcommon.NewValueString(operationTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsOperationRate) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsOperationRate) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsOperationRate(settings MetricSettings) metricActiveDirectoryDsOperationRate {
	m := metricActiveDirectoryDsOperationRate{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsReplicationNetworkIo struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.replication.network.io metric with initial data.
func (m *metricActiveDirectoryDsReplicationNetworkIo) init() {
	m.data.SetName("active_directory.ds.replication.network.io")
	m.data.SetDescription("The amount of network data transmitted by the Directory Replication Agent.")
	m.data.SetUnit("By")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricActiveDirectoryDsReplicationNetworkIo) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, directionAttributeValue string, networkDataTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Direction, pcommon.NewValueString(directionAttributeValue))
	dp.Attributes().Insert(A.NetworkDataType, pcommon.NewValueString(networkDataTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsReplicationNetworkIo) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsReplicationNetworkIo) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsReplicationNetworkIo(settings MetricSettings) metricActiveDirectoryDsReplicationNetworkIo {
	m := metricActiveDirectoryDsReplicationNetworkIo{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsReplicationObjectRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.replication.object.rate metric with initial data.
func (m *metricActiveDirectoryDsReplicationObjectRate) init() {
	m.data.SetName("active_directory.ds.replication.object.rate")
	m.data.SetDescription("The number of objects transmitted by the Directory Replication Agent per second.")
	m.data.SetUnit("{objects}/s")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricActiveDirectoryDsReplicationObjectRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, directionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.Direction, pcommon.NewValueString(directionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsReplicationObjectRate) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsReplicationObjectRate) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsReplicationObjectRate(settings MetricSettings) metricActiveDirectoryDsReplicationObjectRate {
	m := metricActiveDirectoryDsReplicationObjectRate{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsReplicationOperationPending struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.replication.operation.pending metric with initial data.
func (m *metricActiveDirectoryDsReplicationOperationPending) init() {
	m.data.SetName("active_directory.ds.replication.operation.pending")
	m.data.SetDescription("The number of pending replication operations for the Directory Replication Agent.")
	m.data.SetUnit("{operations}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricActiveDirectoryDsReplicationOperationPending) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsReplicationOperationPending) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsReplicationOperationPending) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsReplicationOperationPending(settings MetricSettings) metricActiveDirectoryDsReplicationOperationPending {
	m := metricActiveDirectoryDsReplicationOperationPending{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsReplicationPropertyRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.replication.property.rate metric with initial data.
func (m *metricActiveDirectoryDsReplicationPropertyRate) init() {
	m.data.SetName("active_directory.ds.replication.property.rate")
	m.data.SetDescription("The number of properties transmitted by the Directory Replication Agent per second.")
	m.data.SetUnit("{properties}/s")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricActiveDirectoryDsReplicationPropertyRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, directionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.Direction, pcommon.NewValueString(directionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsReplicationPropertyRate) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsReplicationPropertyRate) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsReplicationPropertyRate(settings MetricSettings) metricActiveDirectoryDsReplicationPropertyRate {
	m := metricActiveDirectoryDsReplicationPropertyRate{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsReplicationSyncObjectPending struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.replication.sync.object.pending metric with initial data.
func (m *metricActiveDirectoryDsReplicationSyncObjectPending) init() {
	m.data.SetName("active_directory.ds.replication.sync.object.pending")
	m.data.SetDescription("The number of objects remaining until the full sync completes for the Directory Replication Agent.")
	m.data.SetUnit("{objects}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricActiveDirectoryDsReplicationSyncObjectPending) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsReplicationSyncObjectPending) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsReplicationSyncObjectPending) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsReplicationSyncObjectPending(settings MetricSettings) metricActiveDirectoryDsReplicationSyncObjectPending {
	m := metricActiveDirectoryDsReplicationSyncObjectPending{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsReplicationSyncRequestCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.replication.sync.request.count metric with initial data.
func (m *metricActiveDirectoryDsReplicationSyncRequestCount) init() {
	m.data.SetName("active_directory.ds.replication.sync.request.count")
	m.data.SetDescription("The number of sync requests made by the Directory Replication Agent.")
	m.data.SetUnit("{requests}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricActiveDirectoryDsReplicationSyncRequestCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, syncResultAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.SyncResult, pcommon.NewValueString(syncResultAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsReplicationSyncRequestCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsReplicationSyncRequestCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsReplicationSyncRequestCount(settings MetricSettings) metricActiveDirectoryDsReplicationSyncRequestCount {
	m := metricActiveDirectoryDsReplicationSyncRequestCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsReplicationValueRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.replication.value.rate metric with initial data.
func (m *metricActiveDirectoryDsReplicationValueRate) init() {
	m.data.SetName("active_directory.ds.replication.value.rate")
	m.data.SetDescription("The number of values transmitted by the Directory Replication Agent per second.")
	m.data.SetUnit("{values}/s")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricActiveDirectoryDsReplicationValueRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, directionAttributeValue string, valueTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.Direction, pcommon.NewValueString(directionAttributeValue))
	dp.Attributes().Insert(A.ValueType, pcommon.NewValueString(valueTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsReplicationValueRate) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsReplicationValueRate) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsReplicationValueRate(settings MetricSettings) metricActiveDirectoryDsReplicationValueRate {
	m := metricActiveDirectoryDsReplicationValueRate{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.security_descriptor_propagations_event.queued metric with initial data.
func (m *metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued) init() {
	m.data.SetName("active_directory.ds.security_descriptor_propagations_event.queued")
	m.data.SetDescription("The number of security descriptor propagation events that are queued for processing.")
	m.data.SetUnit("{events}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued(settings MetricSettings) metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued {
	m := metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsSuboperationRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.suboperation.rate metric with initial data.
func (m *metricActiveDirectoryDsSuboperationRate) init() {
	m.data.SetName("active_directory.ds.suboperation.rate")
	m.data.SetDescription("The rate of sub-operations performed.")
	m.data.SetUnit("{suboperations}/s")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricActiveDirectoryDsSuboperationRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, suboperationTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.SuboperationType, pcommon.NewValueString(suboperationTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsSuboperationRate) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsSuboperationRate) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsSuboperationRate(settings MetricSettings) metricActiveDirectoryDsSuboperationRate {
	m := metricActiveDirectoryDsSuboperationRate{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricActiveDirectoryDsThreadCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active_directory.ds.thread.count metric with initial data.
func (m *metricActiveDirectoryDsThreadCount) init() {
	m.data.SetName("active_directory.ds.thread.count")
	m.data.SetDescription("The number of threads in use by the directory service.")
	m.data.SetUnit("{threads}")
	m.data.SetDataType(pmetric.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricActiveDirectoryDsThreadCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveDirectoryDsThreadCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveDirectoryDsThreadCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveDirectoryDsThreadCount(settings MetricSettings) metricActiveDirectoryDsThreadCount {
	m := metricActiveDirectoryDsThreadCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                                                        pcommon.Timestamp // start time that will be applied to all recorded data points.
	metricsCapacity                                                  int               // maximum observed number of metrics per resource.
	resourceCapacity                                                 int               // maximum observed number of resource attributes.
	metricsBuffer                                                    pmetric.Metrics   // accumulates metrics data before emitting.
	metricActiveDirectoryDsBindRate                                  metricActiveDirectoryDsBindRate
	metricActiveDirectoryDsLdapBindLastSuccessfulTime                metricActiveDirectoryDsLdapBindLastSuccessfulTime
	metricActiveDirectoryDsLdapBindRate                              metricActiveDirectoryDsLdapBindRate
	metricActiveDirectoryDsLdapClientSessionCount                    metricActiveDirectoryDsLdapClientSessionCount
	metricActiveDirectoryDsLdapSearchRate                            metricActiveDirectoryDsLdapSearchRate
	metricActiveDirectoryDsNameCacheHitRate                          metricActiveDirectoryDsNameCacheHitRate
	metricActiveDirectoryDsNotificationQueued                        metricActiveDirectoryDsNotificationQueued
	metricActiveDirectoryDsOperationRate                             metricActiveDirectoryDsOperationRate
	metricActiveDirectoryDsReplicationNetworkIo                      metricActiveDirectoryDsReplicationNetworkIo
	metricActiveDirectoryDsReplicationObjectRate                     metricActiveDirectoryDsReplicationObjectRate
	metricActiveDirectoryDsReplicationOperationPending               metricActiveDirectoryDsReplicationOperationPending
	metricActiveDirectoryDsReplicationPropertyRate                   metricActiveDirectoryDsReplicationPropertyRate
	metricActiveDirectoryDsReplicationSyncObjectPending              metricActiveDirectoryDsReplicationSyncObjectPending
	metricActiveDirectoryDsReplicationSyncRequestCount               metricActiveDirectoryDsReplicationSyncRequestCount
	metricActiveDirectoryDsReplicationValueRate                      metricActiveDirectoryDsReplicationValueRate
	metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued
	metricActiveDirectoryDsSuboperationRate                          metricActiveDirectoryDsSuboperationRate
	metricActiveDirectoryDsThreadCount                               metricActiveDirectoryDsThreadCount
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(settings MetricsSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                       pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                   pmetric.NewMetrics(),
		metricActiveDirectoryDsBindRate: newMetricActiveDirectoryDsBindRate(settings.ActiveDirectoryDsBindRate),
		metricActiveDirectoryDsLdapBindLastSuccessfulTime:                newMetricActiveDirectoryDsLdapBindLastSuccessfulTime(settings.ActiveDirectoryDsLdapBindLastSuccessfulTime),
		metricActiveDirectoryDsLdapBindRate:                              newMetricActiveDirectoryDsLdapBindRate(settings.ActiveDirectoryDsLdapBindRate),
		metricActiveDirectoryDsLdapClientSessionCount:                    newMetricActiveDirectoryDsLdapClientSessionCount(settings.ActiveDirectoryDsLdapClientSessionCount),
		metricActiveDirectoryDsLdapSearchRate:                            newMetricActiveDirectoryDsLdapSearchRate(settings.ActiveDirectoryDsLdapSearchRate),
		metricActiveDirectoryDsNameCacheHitRate:                          newMetricActiveDirectoryDsNameCacheHitRate(settings.ActiveDirectoryDsNameCacheHitRate),
		metricActiveDirectoryDsNotificationQueued:                        newMetricActiveDirectoryDsNotificationQueued(settings.ActiveDirectoryDsNotificationQueued),
		metricActiveDirectoryDsOperationRate:                             newMetricActiveDirectoryDsOperationRate(settings.ActiveDirectoryDsOperationRate),
		metricActiveDirectoryDsReplicationNetworkIo:                      newMetricActiveDirectoryDsReplicationNetworkIo(settings.ActiveDirectoryDsReplicationNetworkIo),
		metricActiveDirectoryDsReplicationObjectRate:                     newMetricActiveDirectoryDsReplicationObjectRate(settings.ActiveDirectoryDsReplicationObjectRate),
		metricActiveDirectoryDsReplicationOperationPending:               newMetricActiveDirectoryDsReplicationOperationPending(settings.ActiveDirectoryDsReplicationOperationPending),
		metricActiveDirectoryDsReplicationPropertyRate:                   newMetricActiveDirectoryDsReplicationPropertyRate(settings.ActiveDirectoryDsReplicationPropertyRate),
		metricActiveDirectoryDsReplicationSyncObjectPending:              newMetricActiveDirectoryDsReplicationSyncObjectPending(settings.ActiveDirectoryDsReplicationSyncObjectPending),
		metricActiveDirectoryDsReplicationSyncRequestCount:               newMetricActiveDirectoryDsReplicationSyncRequestCount(settings.ActiveDirectoryDsReplicationSyncRequestCount),
		metricActiveDirectoryDsReplicationValueRate:                      newMetricActiveDirectoryDsReplicationValueRate(settings.ActiveDirectoryDsReplicationValueRate),
		metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued: newMetricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued(settings.ActiveDirectoryDsSecurityDescriptorPropagationsEventQueued),
		metricActiveDirectoryDsSuboperationRate:                          newMetricActiveDirectoryDsSuboperationRate(settings.ActiveDirectoryDsSuboperationRate),
		metricActiveDirectoryDsThreadCount:                               newMetricActiveDirectoryDsThreadCount(settings.ActiveDirectoryDsThreadCount),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
	if mb.resourceCapacity < rm.Resource().Attributes().Len() {
		mb.resourceCapacity = rm.Resource().Attributes().Len()
	}
}

// ResourceOption applies changes to provided resource.
type ResourceOption func(pcommon.Resource)

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead. Resource attributes should be provided as ResourceOption arguments.
func (mb *MetricsBuilder) EmitForResource(ro ...ResourceOption) {
	rm := pmetric.NewResourceMetrics()
	rm.Resource().Attributes().EnsureCapacity(mb.resourceCapacity)
	for _, op := range ro {
		op(rm.Resource())
	}
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("otelcol/activedirectorydsreceiver")
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricActiveDirectoryDsBindRate.emit(ils.Metrics())
	mb.metricActiveDirectoryDsLdapBindLastSuccessfulTime.emit(ils.Metrics())
	mb.metricActiveDirectoryDsLdapBindRate.emit(ils.Metrics())
	mb.metricActiveDirectoryDsLdapClientSessionCount.emit(ils.Metrics())
	mb.metricActiveDirectoryDsLdapSearchRate.emit(ils.Metrics())
	mb.metricActiveDirectoryDsNameCacheHitRate.emit(ils.Metrics())
	mb.metricActiveDirectoryDsNotificationQueued.emit(ils.Metrics())
	mb.metricActiveDirectoryDsOperationRate.emit(ils.Metrics())
	mb.metricActiveDirectoryDsReplicationNetworkIo.emit(ils.Metrics())
	mb.metricActiveDirectoryDsReplicationObjectRate.emit(ils.Metrics())
	mb.metricActiveDirectoryDsReplicationOperationPending.emit(ils.Metrics())
	mb.metricActiveDirectoryDsReplicationPropertyRate.emit(ils.Metrics())
	mb.metricActiveDirectoryDsReplicationSyncObjectPending.emit(ils.Metrics())
	mb.metricActiveDirectoryDsReplicationSyncRequestCount.emit(ils.Metrics())
	mb.metricActiveDirectoryDsReplicationValueRate.emit(ils.Metrics())
	mb.metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued.emit(ils.Metrics())
	mb.metricActiveDirectoryDsSuboperationRate.emit(ils.Metrics())
	mb.metricActiveDirectoryDsThreadCount.emit(ils.Metrics())
	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user settings, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(ro ...ResourceOption) pmetric.Metrics {
	mb.EmitForResource(ro...)
	metrics := pmetric.NewMetrics()
	mb.metricsBuffer.MoveTo(metrics)
	return metrics
}

// RecordActiveDirectoryDsBindRateDataPoint adds a data point to active_directory.ds.bind.rate metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsBindRateDataPoint(ts pcommon.Timestamp, val float64, bindTypeAttributeValue string) {
	mb.metricActiveDirectoryDsBindRate.recordDataPoint(mb.startTime, ts, val, bindTypeAttributeValue)
}

// RecordActiveDirectoryDsLdapBindLastSuccessfulTimeDataPoint adds a data point to active_directory.ds.ldap.bind.last_successful.time metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsLdapBindLastSuccessfulTimeDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricActiveDirectoryDsLdapBindLastSuccessfulTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordActiveDirectoryDsLdapBindRateDataPoint adds a data point to active_directory.ds.ldap.bind.rate metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsLdapBindRateDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricActiveDirectoryDsLdapBindRate.recordDataPoint(mb.startTime, ts, val)
}

// RecordActiveDirectoryDsLdapClientSessionCountDataPoint adds a data point to active_directory.ds.ldap.client.session.count metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsLdapClientSessionCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricActiveDirectoryDsLdapClientSessionCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordActiveDirectoryDsLdapSearchRateDataPoint adds a data point to active_directory.ds.ldap.search.rate metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsLdapSearchRateDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricActiveDirectoryDsLdapSearchRate.recordDataPoint(mb.startTime, ts, val)
}

// RecordActiveDirectoryDsNameCacheHitRateDataPoint adds a data point to active_directory.ds.name_cache.hit_rate metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsNameCacheHitRateDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricActiveDirectoryDsNameCacheHitRate.recordDataPoint(mb.startTime, ts, val)
}

// RecordActiveDirectoryDsNotificationQueuedDataPoint adds a data point to active_directory.ds.notification.queued metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsNotificationQueuedDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricActiveDirectoryDsNotificationQueued.recordDataPoint(mb.startTime, ts, val)
}

// RecordActiveDirectoryDsOperationRateDataPoint adds a data point to active_directory.ds.operation.rate metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsOperationRateDataPoint(ts pcommon.Timestamp, val float64, operationTypeAttributeValue string) {
	mb.metricActiveDirectoryDsOperationRate.recordDataPoint(mb.startTime, ts, val, operationTypeAttributeValue)
}

// RecordActiveDirectoryDsReplicationNetworkIoDataPoint adds a data point to active_directory.ds.replication.network.io metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsReplicationNetworkIoDataPoint(ts pcommon.Timestamp, val int64, directionAttributeValue string, networkDataTypeAttributeValue string) {
	mb.metricActiveDirectoryDsReplicationNetworkIo.recordDataPoint(mb.startTime, ts, val, directionAttributeValue, networkDataTypeAttributeValue)
}

// RecordActiveDirectoryDsReplicationObjectRateDataPoint adds a data point to active_directory.ds.replication.object.rate metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsReplicationObjectRateDataPoint(ts pcommon.Timestamp, val float64, directionAttributeValue string) {
	mb.metricActiveDirectoryDsReplicationObjectRate.recordDataPoint(mb.startTime, ts, val, directionAttributeValue)
}

// RecordActiveDirectoryDsReplicationOperationPendingDataPoint adds a data point to active_directory.ds.replication.operation.pending metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsReplicationOperationPendingDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricActiveDirectoryDsReplicationOperationPending.recordDataPoint(mb.startTime, ts, val)
}

// RecordActiveDirectoryDsReplicationPropertyRateDataPoint adds a data point to active_directory.ds.replication.property.rate metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsReplicationPropertyRateDataPoint(ts pcommon.Timestamp, val float64, directionAttributeValue string) {
	mb.metricActiveDirectoryDsReplicationPropertyRate.recordDataPoint(mb.startTime, ts, val, directionAttributeValue)
}

// RecordActiveDirectoryDsReplicationSyncObjectPendingDataPoint adds a data point to active_directory.ds.replication.sync.object.pending metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsReplicationSyncObjectPendingDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricActiveDirectoryDsReplicationSyncObjectPending.recordDataPoint(mb.startTime, ts, val)
}

// RecordActiveDirectoryDsReplicationSyncRequestCountDataPoint adds a data point to active_directory.ds.replication.sync.request.count metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsReplicationSyncRequestCountDataPoint(ts pcommon.Timestamp, val int64, syncResultAttributeValue string) {
	mb.metricActiveDirectoryDsReplicationSyncRequestCount.recordDataPoint(mb.startTime, ts, val, syncResultAttributeValue)
}

// RecordActiveDirectoryDsReplicationValueRateDataPoint adds a data point to active_directory.ds.replication.value.rate metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsReplicationValueRateDataPoint(ts pcommon.Timestamp, val float64, directionAttributeValue string, valueTypeAttributeValue string) {
	mb.metricActiveDirectoryDsReplicationValueRate.recordDataPoint(mb.startTime, ts, val, directionAttributeValue, valueTypeAttributeValue)
}

// RecordActiveDirectoryDsSecurityDescriptorPropagationsEventQueuedDataPoint adds a data point to active_directory.ds.security_descriptor_propagations_event.queued metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsSecurityDescriptorPropagationsEventQueuedDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricActiveDirectoryDsSecurityDescriptorPropagationsEventQueued.recordDataPoint(mb.startTime, ts, val)
}

// RecordActiveDirectoryDsSuboperationRateDataPoint adds a data point to active_directory.ds.suboperation.rate metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsSuboperationRateDataPoint(ts pcommon.Timestamp, val float64, suboperationTypeAttributeValue string) {
	mb.metricActiveDirectoryDsSuboperationRate.recordDataPoint(mb.startTime, ts, val, suboperationTypeAttributeValue)
}

// RecordActiveDirectoryDsThreadCountDataPoint adds a data point to active_directory.ds.thread.count metric.
func (mb *MetricsBuilder) RecordActiveDirectoryDsThreadCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricActiveDirectoryDsThreadCount.recordDataPoint(mb.startTime, ts, val)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}

// Attributes contains the possible metric attributes that can be used.
var Attributes = struct {
	// BindType (The type of bind to the domain server.)
	BindType string
	// Direction (The direction of data flow.)
	Direction string
	// NetworkDataType (The type of network data sent.)
	NetworkDataType string
	// OperationType (The type of operation.)
	OperationType string
	// SuboperationType (The type of suboperation.)
	SuboperationType string
	// SyncResult (The result status of the sync request.)
	SyncResult string
	// ValueType (The type of value sent.)
	ValueType string
}{
	"type",
	"direction",
	"type",
	"type",
	"type",
	"result",
	"type",
}

// A is an alias for Attributes.
var A = Attributes

// AttributeBindType are the possible values that the attribute "bind_type" can have.
var AttributeBindType = struct {
	Server string
	Client string
}{
	"server",
	"client",
}

// AttributeDirection are the possible values that the attribute "direction" can have.
var AttributeDirection = struct {
	Sent     string
	Received string
}{
	"sent",
	"received",
}

// AttributeNetworkDataType are the possible values that the attribute "network_data_type" can have.
var AttributeNetworkDataType = struct {
	Compressed   string
	Uncompressed string
}{
	"compressed",
	"uncompressed",
}

// AttributeOperationType are the possible values that the attribute "operation_type" can have.
var AttributeOperationType = struct {
	Read   string
	Write  string
	Search string
}{
	"read",
	"write",
	"search",
}

// AttributeSuboperationType are the possible values that the attribute "suboperation_type" can have.
var AttributeSuboperationType = struct {
	SecurityDescriptorPropagationsEvent string
	Search                              string
}{
	"security_descriptor_propagations_event",
	"search",
}

// AttributeSyncResult are the possible values that the attribute "sync_result" can have.
var AttributeSyncResult = struct {
	Success        string
	SchemaMismatch string
	Other          string
}{
	"success",
	"schema_mismatch",
	"other",
}

// AttributeValueType are the possible values that the attribute "value_type" can have.
var AttributeValueType = struct {
	DistingushedNames string
	Other             string
}{
	"distingushed_names",
	"other",
}
