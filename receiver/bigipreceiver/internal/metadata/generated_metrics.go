// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/confmap"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`

	enabledProvidedByUser bool
}

// IsEnabledProvidedByUser returns true if `enabled` option is explicitly set in user settings to any value.
func (ms *MetricSettings) IsEnabledProvidedByUser() bool {
	return ms.enabledProvidedByUser
}

func (ms *MetricSettings) Unmarshal(parser *confmap.Conf) error {
	if parser == nil {
		return nil
	}
	err := parser.Unmarshal(ms, confmap.WithErrorUnused())
	if err != nil {
		return err
	}
	ms.enabledProvidedByUser = parser.IsSet("enabled")
	return nil
}

// MetricsSettings provides settings for bigipreceiver metrics.
type MetricsSettings struct {
	BigipNodeAvailability             MetricSettings `mapstructure:"bigip.node.availability"`
	BigipNodeConnectionCount          MetricSettings `mapstructure:"bigip.node.connection.count"`
	BigipNodeDataTransmitted          MetricSettings `mapstructure:"bigip.node.data.transmitted"`
	BigipNodeEnabled                  MetricSettings `mapstructure:"bigip.node.enabled"`
	BigipNodePacketCount              MetricSettings `mapstructure:"bigip.node.packet.count"`
	BigipNodeRequestCount             MetricSettings `mapstructure:"bigip.node.request.count"`
	BigipNodeSessionCount             MetricSettings `mapstructure:"bigip.node.session.count"`
	BigipPoolAvailability             MetricSettings `mapstructure:"bigip.pool.availability"`
	BigipPoolConnectionCount          MetricSettings `mapstructure:"bigip.pool.connection.count"`
	BigipPoolDataTransmitted          MetricSettings `mapstructure:"bigip.pool.data.transmitted"`
	BigipPoolEnabled                  MetricSettings `mapstructure:"bigip.pool.enabled"`
	BigipPoolMemberCount              MetricSettings `mapstructure:"bigip.pool.member.count"`
	BigipPoolPacketCount              MetricSettings `mapstructure:"bigip.pool.packet.count"`
	BigipPoolRequestCount             MetricSettings `mapstructure:"bigip.pool.request.count"`
	BigipPoolMemberAvailability       MetricSettings `mapstructure:"bigip.pool_member.availability"`
	BigipPoolMemberConnectionCount    MetricSettings `mapstructure:"bigip.pool_member.connection.count"`
	BigipPoolMemberDataTransmitted    MetricSettings `mapstructure:"bigip.pool_member.data.transmitted"`
	BigipPoolMemberEnabled            MetricSettings `mapstructure:"bigip.pool_member.enabled"`
	BigipPoolMemberPacketCount        MetricSettings `mapstructure:"bigip.pool_member.packet.count"`
	BigipPoolMemberRequestCount       MetricSettings `mapstructure:"bigip.pool_member.request.count"`
	BigipPoolMemberSessionCount       MetricSettings `mapstructure:"bigip.pool_member.session.count"`
	BigipVirtualServerAvailability    MetricSettings `mapstructure:"bigip.virtual_server.availability"`
	BigipVirtualServerConnectionCount MetricSettings `mapstructure:"bigip.virtual_server.connection.count"`
	BigipVirtualServerDataTransmitted MetricSettings `mapstructure:"bigip.virtual_server.data.transmitted"`
	BigipVirtualServerEnabled         MetricSettings `mapstructure:"bigip.virtual_server.enabled"`
	BigipVirtualServerPacketCount     MetricSettings `mapstructure:"bigip.virtual_server.packet.count"`
	BigipVirtualServerRequestCount    MetricSettings `mapstructure:"bigip.virtual_server.request.count"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		BigipNodeAvailability: MetricSettings{
			Enabled: true,
		},
		BigipNodeConnectionCount: MetricSettings{
			Enabled: true,
		},
		BigipNodeDataTransmitted: MetricSettings{
			Enabled: true,
		},
		BigipNodeEnabled: MetricSettings{
			Enabled: true,
		},
		BigipNodePacketCount: MetricSettings{
			Enabled: true,
		},
		BigipNodeRequestCount: MetricSettings{
			Enabled: true,
		},
		BigipNodeSessionCount: MetricSettings{
			Enabled: true,
		},
		BigipPoolAvailability: MetricSettings{
			Enabled: true,
		},
		BigipPoolConnectionCount: MetricSettings{
			Enabled: true,
		},
		BigipPoolDataTransmitted: MetricSettings{
			Enabled: true,
		},
		BigipPoolEnabled: MetricSettings{
			Enabled: true,
		},
		BigipPoolMemberCount: MetricSettings{
			Enabled: true,
		},
		BigipPoolPacketCount: MetricSettings{
			Enabled: true,
		},
		BigipPoolRequestCount: MetricSettings{
			Enabled: true,
		},
		BigipPoolMemberAvailability: MetricSettings{
			Enabled: true,
		},
		BigipPoolMemberConnectionCount: MetricSettings{
			Enabled: true,
		},
		BigipPoolMemberDataTransmitted: MetricSettings{
			Enabled: true,
		},
		BigipPoolMemberEnabled: MetricSettings{
			Enabled: true,
		},
		BigipPoolMemberPacketCount: MetricSettings{
			Enabled: true,
		},
		BigipPoolMemberRequestCount: MetricSettings{
			Enabled: true,
		},
		BigipPoolMemberSessionCount: MetricSettings{
			Enabled: true,
		},
		BigipVirtualServerAvailability: MetricSettings{
			Enabled: true,
		},
		BigipVirtualServerConnectionCount: MetricSettings{
			Enabled: true,
		},
		BigipVirtualServerDataTransmitted: MetricSettings{
			Enabled: true,
		},
		BigipVirtualServerEnabled: MetricSettings{
			Enabled: true,
		},
		BigipVirtualServerPacketCount: MetricSettings{
			Enabled: true,
		},
		BigipVirtualServerRequestCount: MetricSettings{
			Enabled: true,
		},
	}
}

type attributeActive struct{}

func (av attributeActive) String() string {
	return "active"
}

type attributeAvailable struct{}

func (av attributeAvailable) String() string {
	return "available"
}

type attributeDisabled struct{}

func (av attributeDisabled) String() string {
	return "disabled"
}

type attributeEnabled struct{}

func (av attributeEnabled) String() string {
	return "enabled"
}

type attributeInactive struct{}

func (av attributeInactive) String() string {
	return "inactive"
}

type attributeOffline struct{}

func (av attributeOffline) String() string {
	return "offline"
}

type attributeReceived struct{}

func (av attributeReceived) String() string {
	return "received"
}

type attributeSent struct{}

func (av attributeSent) String() string {
	return "sent"
}

type attributeUnknown struct{}

func (av attributeUnknown) String() string {
	return "unknown"
}

var (
	AttributeActive    = attributeActive{}
	AttributeAvailable = attributeAvailable{}
	AttributeDisabled  = attributeDisabled{}
	AttributeEnabled   = attributeEnabled{}
	AttributeInactive  = attributeInactive{}
	AttributeOffline   = attributeOffline{}
	AttributeReceived  = attributeReceived{}
	AttributeSent      = attributeSent{}
	AttributeUnknown   = attributeUnknown{}
)

type metricBigipNodeAvailability struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.node.availability metric with initial data.
func (m *metricBigipNodeAvailability) init() {
	m.data.SetName("bigip.node.availability")
	m.data.SetDescription("Availability of the node.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

// BigipNodeAvailabilityAttributeStatus specifies the a value status attribute of bigip.node.availability metric.
type BigipNodeAvailabilityAttributeStatus interface {
	bigipNodeAvailabilityAttributeStatus()
	String() string
}

func (av attributeOffline) bigipNodeAvailabilityAttributeStatus()   {}
func (av attributeUnknown) bigipNodeAvailabilityAttributeStatus()   {}
func (av attributeAvailable) bigipNodeAvailabilityAttributeStatus() {}

// BigipNodeAvailabilityAttributeStatusMap is a helper map to get BigipNodeAvailabilityAttributeStatus from an attribute value.
var BigipNodeAvailabilityAttributeStatusMap = map[string]BigipNodeAvailabilityAttributeStatus{
	"offline":   AttributeOffline,
	"unknown":   AttributeUnknown,
	"available": AttributeAvailable,
}

func (m *metricBigipNodeAvailability) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, statusAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("status", statusAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipNodeAvailability) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipNodeAvailability) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipNodeAvailability(settings MetricSettings) metricBigipNodeAvailability {
	m := metricBigipNodeAvailability{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipNodeConnectionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.node.connection.count metric with initial data.
func (m *metricBigipNodeConnectionCount) init() {
	m.data.SetName("bigip.node.connection.count")
	m.data.SetDescription("Current number of connections to the node.")
	m.data.SetUnit("{connections}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricBigipNodeConnectionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipNodeConnectionCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipNodeConnectionCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipNodeConnectionCount(settings MetricSettings) metricBigipNodeConnectionCount {
	m := metricBigipNodeConnectionCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipNodeDataTransmitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.node.data.transmitted metric with initial data.
func (m *metricBigipNodeDataTransmitted) init() {
	m.data.SetName("bigip.node.data.transmitted")
	m.data.SetDescription("Amount of data transmitted to and from the node.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

// BigipNodeDataTransmittedAttributeDirection specifies the a value direction attribute of bigip.node.data.transmitted metric.
type BigipNodeDataTransmittedAttributeDirection interface {
	bigipNodeDataTransmittedAttributeDirection()
	String() string
}

func (av attributeSent) bigipNodeDataTransmittedAttributeDirection()     {}
func (av attributeReceived) bigipNodeDataTransmittedAttributeDirection() {}

// BigipNodeDataTransmittedAttributeDirectionMap is a helper map to get BigipNodeDataTransmittedAttributeDirection from an attribute value.
var BigipNodeDataTransmittedAttributeDirectionMap = map[string]BigipNodeDataTransmittedAttributeDirection{
	"sent":     AttributeSent,
	"received": AttributeReceived,
}

func (m *metricBigipNodeDataTransmitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, directionAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("direction", directionAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipNodeDataTransmitted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipNodeDataTransmitted) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipNodeDataTransmitted(settings MetricSettings) metricBigipNodeDataTransmitted {
	m := metricBigipNodeDataTransmitted{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipNodeEnabled struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.node.enabled metric with initial data.
func (m *metricBigipNodeEnabled) init() {
	m.data.SetName("bigip.node.enabled")
	m.data.SetDescription("Enabled state of of the node.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

// BigipNodeEnabledAttributeStatus specifies the a value status attribute of bigip.node.enabled metric.
type BigipNodeEnabledAttributeStatus interface {
	bigipNodeEnabledAttributeStatus()
	String() string
}

func (av attributeDisabled) bigipNodeEnabledAttributeStatus() {}
func (av attributeEnabled) bigipNodeEnabledAttributeStatus()  {}

// BigipNodeEnabledAttributeStatusMap is a helper map to get BigipNodeEnabledAttributeStatus from an attribute value.
var BigipNodeEnabledAttributeStatusMap = map[string]BigipNodeEnabledAttributeStatus{
	"disabled": AttributeDisabled,
	"enabled":  AttributeEnabled,
}

func (m *metricBigipNodeEnabled) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, statusAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("status", statusAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipNodeEnabled) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipNodeEnabled) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipNodeEnabled(settings MetricSettings) metricBigipNodeEnabled {
	m := metricBigipNodeEnabled{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipNodePacketCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.node.packet.count metric with initial data.
func (m *metricBigipNodePacketCount) init() {
	m.data.SetName("bigip.node.packet.count")
	m.data.SetDescription("Number of packets transmitted to and from the node.")
	m.data.SetUnit("{packets}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

// BigipNodePacketCountAttributeDirection specifies the a value direction attribute of bigip.node.packet.count metric.
type BigipNodePacketCountAttributeDirection interface {
	bigipNodePacketCountAttributeDirection()
	String() string
}

func (av attributeSent) bigipNodePacketCountAttributeDirection()     {}
func (av attributeReceived) bigipNodePacketCountAttributeDirection() {}

// BigipNodePacketCountAttributeDirectionMap is a helper map to get BigipNodePacketCountAttributeDirection from an attribute value.
var BigipNodePacketCountAttributeDirectionMap = map[string]BigipNodePacketCountAttributeDirection{
	"sent":     AttributeSent,
	"received": AttributeReceived,
}

func (m *metricBigipNodePacketCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, directionAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("direction", directionAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipNodePacketCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipNodePacketCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipNodePacketCount(settings MetricSettings) metricBigipNodePacketCount {
	m := metricBigipNodePacketCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipNodeRequestCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.node.request.count metric with initial data.
func (m *metricBigipNodeRequestCount) init() {
	m.data.SetName("bigip.node.request.count")
	m.data.SetDescription("Number of requests to the node.")
	m.data.SetUnit("{requests}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricBigipNodeRequestCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipNodeRequestCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipNodeRequestCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipNodeRequestCount(settings MetricSettings) metricBigipNodeRequestCount {
	m := metricBigipNodeRequestCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipNodeSessionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.node.session.count metric with initial data.
func (m *metricBigipNodeSessionCount) init() {
	m.data.SetName("bigip.node.session.count")
	m.data.SetDescription("Current number of sessions for the node.")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricBigipNodeSessionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipNodeSessionCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipNodeSessionCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipNodeSessionCount(settings MetricSettings) metricBigipNodeSessionCount {
	m := metricBigipNodeSessionCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipPoolAvailability struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.pool.availability metric with initial data.
func (m *metricBigipPoolAvailability) init() {
	m.data.SetName("bigip.pool.availability")
	m.data.SetDescription("Availability of the pool.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

// BigipPoolAvailabilityAttributeStatus specifies the a value status attribute of bigip.pool.availability metric.
type BigipPoolAvailabilityAttributeStatus interface {
	bigipPoolAvailabilityAttributeStatus()
	String() string
}

func (av attributeOffline) bigipPoolAvailabilityAttributeStatus()   {}
func (av attributeUnknown) bigipPoolAvailabilityAttributeStatus()   {}
func (av attributeAvailable) bigipPoolAvailabilityAttributeStatus() {}

// BigipPoolAvailabilityAttributeStatusMap is a helper map to get BigipPoolAvailabilityAttributeStatus from an attribute value.
var BigipPoolAvailabilityAttributeStatusMap = map[string]BigipPoolAvailabilityAttributeStatus{
	"offline":   AttributeOffline,
	"unknown":   AttributeUnknown,
	"available": AttributeAvailable,
}

func (m *metricBigipPoolAvailability) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, statusAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("status", statusAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipPoolAvailability) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipPoolAvailability) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipPoolAvailability(settings MetricSettings) metricBigipPoolAvailability {
	m := metricBigipPoolAvailability{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipPoolConnectionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.pool.connection.count metric with initial data.
func (m *metricBigipPoolConnectionCount) init() {
	m.data.SetName("bigip.pool.connection.count")
	m.data.SetDescription("Current number of connections to the pool.")
	m.data.SetUnit("{connections}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricBigipPoolConnectionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipPoolConnectionCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipPoolConnectionCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipPoolConnectionCount(settings MetricSettings) metricBigipPoolConnectionCount {
	m := metricBigipPoolConnectionCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipPoolDataTransmitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.pool.data.transmitted metric with initial data.
func (m *metricBigipPoolDataTransmitted) init() {
	m.data.SetName("bigip.pool.data.transmitted")
	m.data.SetDescription("Amount of data transmitted to and from the pool.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

// BigipPoolDataTransmittedAttributeDirection specifies the a value direction attribute of bigip.pool.data.transmitted metric.
type BigipPoolDataTransmittedAttributeDirection interface {
	bigipPoolDataTransmittedAttributeDirection()
	String() string
}

func (av attributeSent) bigipPoolDataTransmittedAttributeDirection()     {}
func (av attributeReceived) bigipPoolDataTransmittedAttributeDirection() {}

// BigipPoolDataTransmittedAttributeDirectionMap is a helper map to get BigipPoolDataTransmittedAttributeDirection from an attribute value.
var BigipPoolDataTransmittedAttributeDirectionMap = map[string]BigipPoolDataTransmittedAttributeDirection{
	"sent":     AttributeSent,
	"received": AttributeReceived,
}

func (m *metricBigipPoolDataTransmitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, directionAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("direction", directionAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipPoolDataTransmitted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipPoolDataTransmitted) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipPoolDataTransmitted(settings MetricSettings) metricBigipPoolDataTransmitted {
	m := metricBigipPoolDataTransmitted{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipPoolEnabled struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.pool.enabled metric with initial data.
func (m *metricBigipPoolEnabled) init() {
	m.data.SetName("bigip.pool.enabled")
	m.data.SetDescription("Enabled state of of the pool.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

// BigipPoolEnabledAttributeStatus specifies the a value status attribute of bigip.pool.enabled metric.
type BigipPoolEnabledAttributeStatus interface {
	bigipPoolEnabledAttributeStatus()
	String() string
}

func (av attributeDisabled) bigipPoolEnabledAttributeStatus() {}
func (av attributeEnabled) bigipPoolEnabledAttributeStatus()  {}

// BigipPoolEnabledAttributeStatusMap is a helper map to get BigipPoolEnabledAttributeStatus from an attribute value.
var BigipPoolEnabledAttributeStatusMap = map[string]BigipPoolEnabledAttributeStatus{
	"disabled": AttributeDisabled,
	"enabled":  AttributeEnabled,
}

func (m *metricBigipPoolEnabled) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, statusAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("status", statusAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipPoolEnabled) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipPoolEnabled) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipPoolEnabled(settings MetricSettings) metricBigipPoolEnabled {
	m := metricBigipPoolEnabled{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipPoolMemberCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.pool.member.count metric with initial data.
func (m *metricBigipPoolMemberCount) init() {
	m.data.SetName("bigip.pool.member.count")
	m.data.SetDescription("Total number of pool members.")
	m.data.SetUnit("{members}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

// BigipPoolMemberCountAttributeStatus specifies the a value status attribute of bigip.pool.member.count metric.
type BigipPoolMemberCountAttributeStatus interface {
	bigipPoolMemberCountAttributeStatus()
	String() string
}

func (av attributeActive) bigipPoolMemberCountAttributeStatus()   {}
func (av attributeInactive) bigipPoolMemberCountAttributeStatus() {}

// BigipPoolMemberCountAttributeStatusMap is a helper map to get BigipPoolMemberCountAttributeStatus from an attribute value.
var BigipPoolMemberCountAttributeStatusMap = map[string]BigipPoolMemberCountAttributeStatus{
	"active":   AttributeActive,
	"inactive": AttributeInactive,
}

func (m *metricBigipPoolMemberCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, statusAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("status", statusAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipPoolMemberCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipPoolMemberCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipPoolMemberCount(settings MetricSettings) metricBigipPoolMemberCount {
	m := metricBigipPoolMemberCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipPoolPacketCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.pool.packet.count metric with initial data.
func (m *metricBigipPoolPacketCount) init() {
	m.data.SetName("bigip.pool.packet.count")
	m.data.SetDescription("Number of packets transmitted to and from the pool.")
	m.data.SetUnit("{packets}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

// BigipPoolPacketCountAttributeDirection specifies the a value direction attribute of bigip.pool.packet.count metric.
type BigipPoolPacketCountAttributeDirection interface {
	bigipPoolPacketCountAttributeDirection()
	String() string
}

func (av attributeSent) bigipPoolPacketCountAttributeDirection()     {}
func (av attributeReceived) bigipPoolPacketCountAttributeDirection() {}

// BigipPoolPacketCountAttributeDirectionMap is a helper map to get BigipPoolPacketCountAttributeDirection from an attribute value.
var BigipPoolPacketCountAttributeDirectionMap = map[string]BigipPoolPacketCountAttributeDirection{
	"sent":     AttributeSent,
	"received": AttributeReceived,
}

func (m *metricBigipPoolPacketCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, directionAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("direction", directionAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipPoolPacketCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipPoolPacketCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipPoolPacketCount(settings MetricSettings) metricBigipPoolPacketCount {
	m := metricBigipPoolPacketCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipPoolRequestCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.pool.request.count metric with initial data.
func (m *metricBigipPoolRequestCount) init() {
	m.data.SetName("bigip.pool.request.count")
	m.data.SetDescription("Number of requests to the pool.")
	m.data.SetUnit("{requests}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricBigipPoolRequestCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipPoolRequestCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipPoolRequestCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipPoolRequestCount(settings MetricSettings) metricBigipPoolRequestCount {
	m := metricBigipPoolRequestCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipPoolMemberAvailability struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.pool_member.availability metric with initial data.
func (m *metricBigipPoolMemberAvailability) init() {
	m.data.SetName("bigip.pool_member.availability")
	m.data.SetDescription("Availability of the pool member.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

// BigipPoolMemberAvailabilityAttributeStatus specifies the a value status attribute of bigip.pool_member.availability metric.
type BigipPoolMemberAvailabilityAttributeStatus interface {
	bigipPoolMemberAvailabilityAttributeStatus()
	String() string
}

func (av attributeOffline) bigipPoolMemberAvailabilityAttributeStatus()   {}
func (av attributeUnknown) bigipPoolMemberAvailabilityAttributeStatus()   {}
func (av attributeAvailable) bigipPoolMemberAvailabilityAttributeStatus() {}

// BigipPoolMemberAvailabilityAttributeStatusMap is a helper map to get BigipPoolMemberAvailabilityAttributeStatus from an attribute value.
var BigipPoolMemberAvailabilityAttributeStatusMap = map[string]BigipPoolMemberAvailabilityAttributeStatus{
	"offline":   AttributeOffline,
	"unknown":   AttributeUnknown,
	"available": AttributeAvailable,
}

func (m *metricBigipPoolMemberAvailability) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, statusAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("status", statusAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipPoolMemberAvailability) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipPoolMemberAvailability) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipPoolMemberAvailability(settings MetricSettings) metricBigipPoolMemberAvailability {
	m := metricBigipPoolMemberAvailability{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipPoolMemberConnectionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.pool_member.connection.count metric with initial data.
func (m *metricBigipPoolMemberConnectionCount) init() {
	m.data.SetName("bigip.pool_member.connection.count")
	m.data.SetDescription("Current number of connections to the pool member.")
	m.data.SetUnit("{connections}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricBigipPoolMemberConnectionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipPoolMemberConnectionCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipPoolMemberConnectionCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipPoolMemberConnectionCount(settings MetricSettings) metricBigipPoolMemberConnectionCount {
	m := metricBigipPoolMemberConnectionCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipPoolMemberDataTransmitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.pool_member.data.transmitted metric with initial data.
func (m *metricBigipPoolMemberDataTransmitted) init() {
	m.data.SetName("bigip.pool_member.data.transmitted")
	m.data.SetDescription("Amount of data transmitted to and from the pool member.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

// BigipPoolMemberDataTransmittedAttributeDirection specifies the a value direction attribute of bigip.pool_member.data.transmitted metric.
type BigipPoolMemberDataTransmittedAttributeDirection interface {
	bigipPoolMemberDataTransmittedAttributeDirection()
	String() string
}

func (av attributeSent) bigipPoolMemberDataTransmittedAttributeDirection()     {}
func (av attributeReceived) bigipPoolMemberDataTransmittedAttributeDirection() {}

// BigipPoolMemberDataTransmittedAttributeDirectionMap is a helper map to get BigipPoolMemberDataTransmittedAttributeDirection from an attribute value.
var BigipPoolMemberDataTransmittedAttributeDirectionMap = map[string]BigipPoolMemberDataTransmittedAttributeDirection{
	"sent":     AttributeSent,
	"received": AttributeReceived,
}

func (m *metricBigipPoolMemberDataTransmitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, directionAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("direction", directionAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipPoolMemberDataTransmitted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipPoolMemberDataTransmitted) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipPoolMemberDataTransmitted(settings MetricSettings) metricBigipPoolMemberDataTransmitted {
	m := metricBigipPoolMemberDataTransmitted{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipPoolMemberEnabled struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.pool_member.enabled metric with initial data.
func (m *metricBigipPoolMemberEnabled) init() {
	m.data.SetName("bigip.pool_member.enabled")
	m.data.SetDescription("Enabled state of of the pool member.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

// BigipPoolMemberEnabledAttributeStatus specifies the a value status attribute of bigip.pool_member.enabled metric.
type BigipPoolMemberEnabledAttributeStatus interface {
	bigipPoolMemberEnabledAttributeStatus()
	String() string
}

func (av attributeDisabled) bigipPoolMemberEnabledAttributeStatus() {}
func (av attributeEnabled) bigipPoolMemberEnabledAttributeStatus()  {}

// BigipPoolMemberEnabledAttributeStatusMap is a helper map to get BigipPoolMemberEnabledAttributeStatus from an attribute value.
var BigipPoolMemberEnabledAttributeStatusMap = map[string]BigipPoolMemberEnabledAttributeStatus{
	"disabled": AttributeDisabled,
	"enabled":  AttributeEnabled,
}

func (m *metricBigipPoolMemberEnabled) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, statusAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("status", statusAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipPoolMemberEnabled) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipPoolMemberEnabled) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipPoolMemberEnabled(settings MetricSettings) metricBigipPoolMemberEnabled {
	m := metricBigipPoolMemberEnabled{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipPoolMemberPacketCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.pool_member.packet.count metric with initial data.
func (m *metricBigipPoolMemberPacketCount) init() {
	m.data.SetName("bigip.pool_member.packet.count")
	m.data.SetDescription("Number of packets transmitted to and from the pool member.")
	m.data.SetUnit("{packets}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

// BigipPoolMemberPacketCountAttributeDirection specifies the a value direction attribute of bigip.pool_member.packet.count metric.
type BigipPoolMemberPacketCountAttributeDirection interface {
	bigipPoolMemberPacketCountAttributeDirection()
	String() string
}

func (av attributeSent) bigipPoolMemberPacketCountAttributeDirection()     {}
func (av attributeReceived) bigipPoolMemberPacketCountAttributeDirection() {}

// BigipPoolMemberPacketCountAttributeDirectionMap is a helper map to get BigipPoolMemberPacketCountAttributeDirection from an attribute value.
var BigipPoolMemberPacketCountAttributeDirectionMap = map[string]BigipPoolMemberPacketCountAttributeDirection{
	"sent":     AttributeSent,
	"received": AttributeReceived,
}

func (m *metricBigipPoolMemberPacketCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, directionAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("direction", directionAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipPoolMemberPacketCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipPoolMemberPacketCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipPoolMemberPacketCount(settings MetricSettings) metricBigipPoolMemberPacketCount {
	m := metricBigipPoolMemberPacketCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipPoolMemberRequestCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.pool_member.request.count metric with initial data.
func (m *metricBigipPoolMemberRequestCount) init() {
	m.data.SetName("bigip.pool_member.request.count")
	m.data.SetDescription("Number of requests to the pool member.")
	m.data.SetUnit("{requests}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricBigipPoolMemberRequestCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipPoolMemberRequestCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipPoolMemberRequestCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipPoolMemberRequestCount(settings MetricSettings) metricBigipPoolMemberRequestCount {
	m := metricBigipPoolMemberRequestCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipPoolMemberSessionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.pool_member.session.count metric with initial data.
func (m *metricBigipPoolMemberSessionCount) init() {
	m.data.SetName("bigip.pool_member.session.count")
	m.data.SetDescription("Current number of sessions for the pool member.")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricBigipPoolMemberSessionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipPoolMemberSessionCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipPoolMemberSessionCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipPoolMemberSessionCount(settings MetricSettings) metricBigipPoolMemberSessionCount {
	m := metricBigipPoolMemberSessionCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipVirtualServerAvailability struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.virtual_server.availability metric with initial data.
func (m *metricBigipVirtualServerAvailability) init() {
	m.data.SetName("bigip.virtual_server.availability")
	m.data.SetDescription("Availability of the virtual server.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

// BigipVirtualServerAvailabilityAttributeStatus specifies the a value status attribute of bigip.virtual_server.availability metric.
type BigipVirtualServerAvailabilityAttributeStatus interface {
	bigipVirtualServerAvailabilityAttributeStatus()
	String() string
}

func (av attributeOffline) bigipVirtualServerAvailabilityAttributeStatus()   {}
func (av attributeUnknown) bigipVirtualServerAvailabilityAttributeStatus()   {}
func (av attributeAvailable) bigipVirtualServerAvailabilityAttributeStatus() {}

// BigipVirtualServerAvailabilityAttributeStatusMap is a helper map to get BigipVirtualServerAvailabilityAttributeStatus from an attribute value.
var BigipVirtualServerAvailabilityAttributeStatusMap = map[string]BigipVirtualServerAvailabilityAttributeStatus{
	"offline":   AttributeOffline,
	"unknown":   AttributeUnknown,
	"available": AttributeAvailable,
}

func (m *metricBigipVirtualServerAvailability) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, statusAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("status", statusAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipVirtualServerAvailability) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipVirtualServerAvailability) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipVirtualServerAvailability(settings MetricSettings) metricBigipVirtualServerAvailability {
	m := metricBigipVirtualServerAvailability{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipVirtualServerConnectionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.virtual_server.connection.count metric with initial data.
func (m *metricBigipVirtualServerConnectionCount) init() {
	m.data.SetName("bigip.virtual_server.connection.count")
	m.data.SetDescription("Current number of connections to the virtual server.")
	m.data.SetUnit("{connections}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricBigipVirtualServerConnectionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipVirtualServerConnectionCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipVirtualServerConnectionCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipVirtualServerConnectionCount(settings MetricSettings) metricBigipVirtualServerConnectionCount {
	m := metricBigipVirtualServerConnectionCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipVirtualServerDataTransmitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.virtual_server.data.transmitted metric with initial data.
func (m *metricBigipVirtualServerDataTransmitted) init() {
	m.data.SetName("bigip.virtual_server.data.transmitted")
	m.data.SetDescription("Amount of data transmitted to and from the virtual server.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

// BigipVirtualServerDataTransmittedAttributeDirection specifies the a value direction attribute of bigip.virtual_server.data.transmitted metric.
type BigipVirtualServerDataTransmittedAttributeDirection interface {
	bigipVirtualServerDataTransmittedAttributeDirection()
	String() string
}

func (av attributeSent) bigipVirtualServerDataTransmittedAttributeDirection()     {}
func (av attributeReceived) bigipVirtualServerDataTransmittedAttributeDirection() {}

// BigipVirtualServerDataTransmittedAttributeDirectionMap is a helper map to get BigipVirtualServerDataTransmittedAttributeDirection from an attribute value.
var BigipVirtualServerDataTransmittedAttributeDirectionMap = map[string]BigipVirtualServerDataTransmittedAttributeDirection{
	"sent":     AttributeSent,
	"received": AttributeReceived,
}

func (m *metricBigipVirtualServerDataTransmitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, directionAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("direction", directionAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipVirtualServerDataTransmitted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipVirtualServerDataTransmitted) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipVirtualServerDataTransmitted(settings MetricSettings) metricBigipVirtualServerDataTransmitted {
	m := metricBigipVirtualServerDataTransmitted{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipVirtualServerEnabled struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.virtual_server.enabled metric with initial data.
func (m *metricBigipVirtualServerEnabled) init() {
	m.data.SetName("bigip.virtual_server.enabled")
	m.data.SetDescription("Enabled state of of the virtual server.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

// BigipVirtualServerEnabledAttributeStatus specifies the a value status attribute of bigip.virtual_server.enabled metric.
type BigipVirtualServerEnabledAttributeStatus interface {
	bigipVirtualServerEnabledAttributeStatus()
	String() string
}

func (av attributeDisabled) bigipVirtualServerEnabledAttributeStatus() {}
func (av attributeEnabled) bigipVirtualServerEnabledAttributeStatus()  {}

// BigipVirtualServerEnabledAttributeStatusMap is a helper map to get BigipVirtualServerEnabledAttributeStatus from an attribute value.
var BigipVirtualServerEnabledAttributeStatusMap = map[string]BigipVirtualServerEnabledAttributeStatus{
	"disabled": AttributeDisabled,
	"enabled":  AttributeEnabled,
}

func (m *metricBigipVirtualServerEnabled) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, statusAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("status", statusAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipVirtualServerEnabled) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipVirtualServerEnabled) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipVirtualServerEnabled(settings MetricSettings) metricBigipVirtualServerEnabled {
	m := metricBigipVirtualServerEnabled{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipVirtualServerPacketCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.virtual_server.packet.count metric with initial data.
func (m *metricBigipVirtualServerPacketCount) init() {
	m.data.SetName("bigip.virtual_server.packet.count")
	m.data.SetDescription("Number of packets transmitted to and from the virtual server.")
	m.data.SetUnit("{packets}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

// BigipVirtualServerPacketCountAttributeDirection specifies the a value direction attribute of bigip.virtual_server.packet.count metric.
type BigipVirtualServerPacketCountAttributeDirection interface {
	bigipVirtualServerPacketCountAttributeDirection()
	String() string
}

func (av attributeSent) bigipVirtualServerPacketCountAttributeDirection()     {}
func (av attributeReceived) bigipVirtualServerPacketCountAttributeDirection() {}

// BigipVirtualServerPacketCountAttributeDirectionMap is a helper map to get BigipVirtualServerPacketCountAttributeDirection from an attribute value.
var BigipVirtualServerPacketCountAttributeDirectionMap = map[string]BigipVirtualServerPacketCountAttributeDirection{
	"sent":     AttributeSent,
	"received": AttributeReceived,
}

func (m *metricBigipVirtualServerPacketCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, directionAttribute string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("direction", directionAttribute)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipVirtualServerPacketCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipVirtualServerPacketCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipVirtualServerPacketCount(settings MetricSettings) metricBigipVirtualServerPacketCount {
	m := metricBigipVirtualServerPacketCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBigipVirtualServerRequestCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills bigip.virtual_server.request.count metric with initial data.
func (m *metricBigipVirtualServerRequestCount) init() {
	m.data.SetName("bigip.virtual_server.request.count")
	m.data.SetDescription("Number of requests to the virtual server.")
	m.data.SetUnit("{requests}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricBigipVirtualServerRequestCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBigipVirtualServerRequestCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBigipVirtualServerRequestCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBigipVirtualServerRequestCount(settings MetricSettings) metricBigipVirtualServerRequestCount {
	m := metricBigipVirtualServerRequestCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                               pcommon.Timestamp   // start time that will be applied to all recorded data points.
	metricsCapacity                         int                 // maximum observed number of metrics per resource.
	resourceCapacity                        int                 // maximum observed number of resource attributes.
	metricsBuffer                           pmetric.Metrics     // accumulates metrics data before emitting.
	buildInfo                               component.BuildInfo // contains version information
	metricBigipNodeAvailability             metricBigipNodeAvailability
	metricBigipNodeConnectionCount          metricBigipNodeConnectionCount
	metricBigipNodeDataTransmitted          metricBigipNodeDataTransmitted
	metricBigipNodeEnabled                  metricBigipNodeEnabled
	metricBigipNodePacketCount              metricBigipNodePacketCount
	metricBigipNodeRequestCount             metricBigipNodeRequestCount
	metricBigipNodeSessionCount             metricBigipNodeSessionCount
	metricBigipPoolAvailability             metricBigipPoolAvailability
	metricBigipPoolConnectionCount          metricBigipPoolConnectionCount
	metricBigipPoolDataTransmitted          metricBigipPoolDataTransmitted
	metricBigipPoolEnabled                  metricBigipPoolEnabled
	metricBigipPoolMemberCount              metricBigipPoolMemberCount
	metricBigipPoolPacketCount              metricBigipPoolPacketCount
	metricBigipPoolRequestCount             metricBigipPoolRequestCount
	metricBigipPoolMemberAvailability       metricBigipPoolMemberAvailability
	metricBigipPoolMemberConnectionCount    metricBigipPoolMemberConnectionCount
	metricBigipPoolMemberDataTransmitted    metricBigipPoolMemberDataTransmitted
	metricBigipPoolMemberEnabled            metricBigipPoolMemberEnabled
	metricBigipPoolMemberPacketCount        metricBigipPoolMemberPacketCount
	metricBigipPoolMemberRequestCount       metricBigipPoolMemberRequestCount
	metricBigipPoolMemberSessionCount       metricBigipPoolMemberSessionCount
	metricBigipVirtualServerAvailability    metricBigipVirtualServerAvailability
	metricBigipVirtualServerConnectionCount metricBigipVirtualServerConnectionCount
	metricBigipVirtualServerDataTransmitted metricBigipVirtualServerDataTransmitted
	metricBigipVirtualServerEnabled         metricBigipVirtualServerEnabled
	metricBigipVirtualServerPacketCount     metricBigipVirtualServerPacketCount
	metricBigipVirtualServerRequestCount    metricBigipVirtualServerRequestCount
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(settings MetricsSettings, buildInfo component.BuildInfo, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                               pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                           pmetric.NewMetrics(),
		buildInfo:                               buildInfo,
		metricBigipNodeAvailability:             newMetricBigipNodeAvailability(settings.BigipNodeAvailability),
		metricBigipNodeConnectionCount:          newMetricBigipNodeConnectionCount(settings.BigipNodeConnectionCount),
		metricBigipNodeDataTransmitted:          newMetricBigipNodeDataTransmitted(settings.BigipNodeDataTransmitted),
		metricBigipNodeEnabled:                  newMetricBigipNodeEnabled(settings.BigipNodeEnabled),
		metricBigipNodePacketCount:              newMetricBigipNodePacketCount(settings.BigipNodePacketCount),
		metricBigipNodeRequestCount:             newMetricBigipNodeRequestCount(settings.BigipNodeRequestCount),
		metricBigipNodeSessionCount:             newMetricBigipNodeSessionCount(settings.BigipNodeSessionCount),
		metricBigipPoolAvailability:             newMetricBigipPoolAvailability(settings.BigipPoolAvailability),
		metricBigipPoolConnectionCount:          newMetricBigipPoolConnectionCount(settings.BigipPoolConnectionCount),
		metricBigipPoolDataTransmitted:          newMetricBigipPoolDataTransmitted(settings.BigipPoolDataTransmitted),
		metricBigipPoolEnabled:                  newMetricBigipPoolEnabled(settings.BigipPoolEnabled),
		metricBigipPoolMemberCount:              newMetricBigipPoolMemberCount(settings.BigipPoolMemberCount),
		metricBigipPoolPacketCount:              newMetricBigipPoolPacketCount(settings.BigipPoolPacketCount),
		metricBigipPoolRequestCount:             newMetricBigipPoolRequestCount(settings.BigipPoolRequestCount),
		metricBigipPoolMemberAvailability:       newMetricBigipPoolMemberAvailability(settings.BigipPoolMemberAvailability),
		metricBigipPoolMemberConnectionCount:    newMetricBigipPoolMemberConnectionCount(settings.BigipPoolMemberConnectionCount),
		metricBigipPoolMemberDataTransmitted:    newMetricBigipPoolMemberDataTransmitted(settings.BigipPoolMemberDataTransmitted),
		metricBigipPoolMemberEnabled:            newMetricBigipPoolMemberEnabled(settings.BigipPoolMemberEnabled),
		metricBigipPoolMemberPacketCount:        newMetricBigipPoolMemberPacketCount(settings.BigipPoolMemberPacketCount),
		metricBigipPoolMemberRequestCount:       newMetricBigipPoolMemberRequestCount(settings.BigipPoolMemberRequestCount),
		metricBigipPoolMemberSessionCount:       newMetricBigipPoolMemberSessionCount(settings.BigipPoolMemberSessionCount),
		metricBigipVirtualServerAvailability:    newMetricBigipVirtualServerAvailability(settings.BigipVirtualServerAvailability),
		metricBigipVirtualServerConnectionCount: newMetricBigipVirtualServerConnectionCount(settings.BigipVirtualServerConnectionCount),
		metricBigipVirtualServerDataTransmitted: newMetricBigipVirtualServerDataTransmitted(settings.BigipVirtualServerDataTransmitted),
		metricBigipVirtualServerEnabled:         newMetricBigipVirtualServerEnabled(settings.BigipVirtualServerEnabled),
		metricBigipVirtualServerPacketCount:     newMetricBigipVirtualServerPacketCount(settings.BigipVirtualServerPacketCount),
		metricBigipVirtualServerRequestCount:    newMetricBigipVirtualServerRequestCount(settings.BigipVirtualServerRequestCount),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
	if mb.resourceCapacity < rm.Resource().Attributes().Len() {
		mb.resourceCapacity = rm.Resource().Attributes().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption func(pmetric.ResourceMetrics)

// WithBigipNodeIPAddress sets provided value as "bigip.node.ip_address" attribute for current resource.
func WithBigipNodeIPAddress(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().PutStr("bigip.node.ip_address", val)
	}
}

// WithBigipNodeName sets provided value as "bigip.node.name" attribute for current resource.
func WithBigipNodeName(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().PutStr("bigip.node.name", val)
	}
}

// WithBigipPoolName sets provided value as "bigip.pool.name" attribute for current resource.
func WithBigipPoolName(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().PutStr("bigip.pool.name", val)
	}
}

// WithBigipPoolMemberIPAddress sets provided value as "bigip.pool_member.ip_address" attribute for current resource.
func WithBigipPoolMemberIPAddress(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().PutStr("bigip.pool_member.ip_address", val)
	}
}

// WithBigipPoolMemberName sets provided value as "bigip.pool_member.name" attribute for current resource.
func WithBigipPoolMemberName(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().PutStr("bigip.pool_member.name", val)
	}
}

// WithBigipVirtualServerDestination sets provided value as "bigip.virtual_server.destination" attribute for current resource.
func WithBigipVirtualServerDestination(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().PutStr("bigip.virtual_server.destination", val)
	}
}

// WithBigipVirtualServerName sets provided value as "bigip.virtual_server.name" attribute for current resource.
func WithBigipVirtualServerName(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().PutStr("bigip.virtual_server.name", val)
	}
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	}
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(rmo ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	rm.Resource().Attributes().EnsureCapacity(mb.resourceCapacity)
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("otelcol/bigipreceiver")
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricBigipNodeAvailability.emit(ils.Metrics())
	mb.metricBigipNodeConnectionCount.emit(ils.Metrics())
	mb.metricBigipNodeDataTransmitted.emit(ils.Metrics())
	mb.metricBigipNodeEnabled.emit(ils.Metrics())
	mb.metricBigipNodePacketCount.emit(ils.Metrics())
	mb.metricBigipNodeRequestCount.emit(ils.Metrics())
	mb.metricBigipNodeSessionCount.emit(ils.Metrics())
	mb.metricBigipPoolAvailability.emit(ils.Metrics())
	mb.metricBigipPoolConnectionCount.emit(ils.Metrics())
	mb.metricBigipPoolDataTransmitted.emit(ils.Metrics())
	mb.metricBigipPoolEnabled.emit(ils.Metrics())
	mb.metricBigipPoolMemberCount.emit(ils.Metrics())
	mb.metricBigipPoolPacketCount.emit(ils.Metrics())
	mb.metricBigipPoolRequestCount.emit(ils.Metrics())
	mb.metricBigipPoolMemberAvailability.emit(ils.Metrics())
	mb.metricBigipPoolMemberConnectionCount.emit(ils.Metrics())
	mb.metricBigipPoolMemberDataTransmitted.emit(ils.Metrics())
	mb.metricBigipPoolMemberEnabled.emit(ils.Metrics())
	mb.metricBigipPoolMemberPacketCount.emit(ils.Metrics())
	mb.metricBigipPoolMemberRequestCount.emit(ils.Metrics())
	mb.metricBigipPoolMemberSessionCount.emit(ils.Metrics())
	mb.metricBigipVirtualServerAvailability.emit(ils.Metrics())
	mb.metricBigipVirtualServerConnectionCount.emit(ils.Metrics())
	mb.metricBigipVirtualServerDataTransmitted.emit(ils.Metrics())
	mb.metricBigipVirtualServerEnabled.emit(ils.Metrics())
	mb.metricBigipVirtualServerPacketCount.emit(ils.Metrics())
	mb.metricBigipVirtualServerRequestCount.emit(ils.Metrics())
	for _, op := range rmo {
		op(rm)
	}
	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user settings, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(rmo ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(rmo...)
	metrics := pmetric.NewMetrics()
	mb.metricsBuffer.MoveTo(metrics)
	return metrics
}

// RecordBigipNodeAvailabilityDataPoint adds a data point to bigip.node.availability metric.
func (mb *MetricsBuilder) RecordBigipNodeAvailabilityDataPoint(ts pcommon.Timestamp, val int64, statusAttribute BigipNodeAvailabilityAttributeStatus) {
	mb.metricBigipNodeAvailability.recordDataPoint(mb.startTime, ts, val, statusAttribute.String())
}

// RecordBigipNodeConnectionCountDataPoint adds a data point to bigip.node.connection.count metric.
func (mb *MetricsBuilder) RecordBigipNodeConnectionCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricBigipNodeConnectionCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordBigipNodeDataTransmittedDataPoint adds a data point to bigip.node.data.transmitted metric.
func (mb *MetricsBuilder) RecordBigipNodeDataTransmittedDataPoint(ts pcommon.Timestamp, val int64, directionAttribute BigipNodeDataTransmittedAttributeDirection) {
	mb.metricBigipNodeDataTransmitted.recordDataPoint(mb.startTime, ts, val, directionAttribute.String())
}

// RecordBigipNodeEnabledDataPoint adds a data point to bigip.node.enabled metric.
func (mb *MetricsBuilder) RecordBigipNodeEnabledDataPoint(ts pcommon.Timestamp, val int64, statusAttribute BigipNodeEnabledAttributeStatus) {
	mb.metricBigipNodeEnabled.recordDataPoint(mb.startTime, ts, val, statusAttribute.String())
}

// RecordBigipNodePacketCountDataPoint adds a data point to bigip.node.packet.count metric.
func (mb *MetricsBuilder) RecordBigipNodePacketCountDataPoint(ts pcommon.Timestamp, val int64, directionAttribute BigipNodePacketCountAttributeDirection) {
	mb.metricBigipNodePacketCount.recordDataPoint(mb.startTime, ts, val, directionAttribute.String())
}

// RecordBigipNodeRequestCountDataPoint adds a data point to bigip.node.request.count metric.
func (mb *MetricsBuilder) RecordBigipNodeRequestCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricBigipNodeRequestCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordBigipNodeSessionCountDataPoint adds a data point to bigip.node.session.count metric.
func (mb *MetricsBuilder) RecordBigipNodeSessionCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricBigipNodeSessionCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordBigipPoolAvailabilityDataPoint adds a data point to bigip.pool.availability metric.
func (mb *MetricsBuilder) RecordBigipPoolAvailabilityDataPoint(ts pcommon.Timestamp, val int64, statusAttribute BigipPoolAvailabilityAttributeStatus) {
	mb.metricBigipPoolAvailability.recordDataPoint(mb.startTime, ts, val, statusAttribute.String())
}

// RecordBigipPoolConnectionCountDataPoint adds a data point to bigip.pool.connection.count metric.
func (mb *MetricsBuilder) RecordBigipPoolConnectionCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricBigipPoolConnectionCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordBigipPoolDataTransmittedDataPoint adds a data point to bigip.pool.data.transmitted metric.
func (mb *MetricsBuilder) RecordBigipPoolDataTransmittedDataPoint(ts pcommon.Timestamp, val int64, directionAttribute BigipPoolDataTransmittedAttributeDirection) {
	mb.metricBigipPoolDataTransmitted.recordDataPoint(mb.startTime, ts, val, directionAttribute.String())
}

// RecordBigipPoolEnabledDataPoint adds a data point to bigip.pool.enabled metric.
func (mb *MetricsBuilder) RecordBigipPoolEnabledDataPoint(ts pcommon.Timestamp, val int64, statusAttribute BigipPoolEnabledAttributeStatus) {
	mb.metricBigipPoolEnabled.recordDataPoint(mb.startTime, ts, val, statusAttribute.String())
}

// RecordBigipPoolMemberCountDataPoint adds a data point to bigip.pool.member.count metric.
func (mb *MetricsBuilder) RecordBigipPoolMemberCountDataPoint(ts pcommon.Timestamp, val int64, statusAttribute BigipPoolMemberCountAttributeStatus) {
	mb.metricBigipPoolMemberCount.recordDataPoint(mb.startTime, ts, val, statusAttribute.String())
}

// RecordBigipPoolPacketCountDataPoint adds a data point to bigip.pool.packet.count metric.
func (mb *MetricsBuilder) RecordBigipPoolPacketCountDataPoint(ts pcommon.Timestamp, val int64, directionAttribute BigipPoolPacketCountAttributeDirection) {
	mb.metricBigipPoolPacketCount.recordDataPoint(mb.startTime, ts, val, directionAttribute.String())
}

// RecordBigipPoolRequestCountDataPoint adds a data point to bigip.pool.request.count metric.
func (mb *MetricsBuilder) RecordBigipPoolRequestCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricBigipPoolRequestCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordBigipPoolMemberAvailabilityDataPoint adds a data point to bigip.pool_member.availability metric.
func (mb *MetricsBuilder) RecordBigipPoolMemberAvailabilityDataPoint(ts pcommon.Timestamp, val int64, statusAttribute BigipPoolMemberAvailabilityAttributeStatus) {
	mb.metricBigipPoolMemberAvailability.recordDataPoint(mb.startTime, ts, val, statusAttribute.String())
}

// RecordBigipPoolMemberConnectionCountDataPoint adds a data point to bigip.pool_member.connection.count metric.
func (mb *MetricsBuilder) RecordBigipPoolMemberConnectionCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricBigipPoolMemberConnectionCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordBigipPoolMemberDataTransmittedDataPoint adds a data point to bigip.pool_member.data.transmitted metric.
func (mb *MetricsBuilder) RecordBigipPoolMemberDataTransmittedDataPoint(ts pcommon.Timestamp, val int64, directionAttribute BigipPoolMemberDataTransmittedAttributeDirection) {
	mb.metricBigipPoolMemberDataTransmitted.recordDataPoint(mb.startTime, ts, val, directionAttribute.String())
}

// RecordBigipPoolMemberEnabledDataPoint adds a data point to bigip.pool_member.enabled metric.
func (mb *MetricsBuilder) RecordBigipPoolMemberEnabledDataPoint(ts pcommon.Timestamp, val int64, statusAttribute BigipPoolMemberEnabledAttributeStatus) {
	mb.metricBigipPoolMemberEnabled.recordDataPoint(mb.startTime, ts, val, statusAttribute.String())
}

// RecordBigipPoolMemberPacketCountDataPoint adds a data point to bigip.pool_member.packet.count metric.
func (mb *MetricsBuilder) RecordBigipPoolMemberPacketCountDataPoint(ts pcommon.Timestamp, val int64, directionAttribute BigipPoolMemberPacketCountAttributeDirection) {
	mb.metricBigipPoolMemberPacketCount.recordDataPoint(mb.startTime, ts, val, directionAttribute.String())
}

// RecordBigipPoolMemberRequestCountDataPoint adds a data point to bigip.pool_member.request.count metric.
func (mb *MetricsBuilder) RecordBigipPoolMemberRequestCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricBigipPoolMemberRequestCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordBigipPoolMemberSessionCountDataPoint adds a data point to bigip.pool_member.session.count metric.
func (mb *MetricsBuilder) RecordBigipPoolMemberSessionCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricBigipPoolMemberSessionCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordBigipVirtualServerAvailabilityDataPoint adds a data point to bigip.virtual_server.availability metric.
func (mb *MetricsBuilder) RecordBigipVirtualServerAvailabilityDataPoint(ts pcommon.Timestamp, val int64, statusAttribute BigipVirtualServerAvailabilityAttributeStatus) {
	mb.metricBigipVirtualServerAvailability.recordDataPoint(mb.startTime, ts, val, statusAttribute.String())
}

// RecordBigipVirtualServerConnectionCountDataPoint adds a data point to bigip.virtual_server.connection.count metric.
func (mb *MetricsBuilder) RecordBigipVirtualServerConnectionCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricBigipVirtualServerConnectionCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordBigipVirtualServerDataTransmittedDataPoint adds a data point to bigip.virtual_server.data.transmitted metric.
func (mb *MetricsBuilder) RecordBigipVirtualServerDataTransmittedDataPoint(ts pcommon.Timestamp, val int64, directionAttribute BigipVirtualServerDataTransmittedAttributeDirection) {
	mb.metricBigipVirtualServerDataTransmitted.recordDataPoint(mb.startTime, ts, val, directionAttribute.String())
}

// RecordBigipVirtualServerEnabledDataPoint adds a data point to bigip.virtual_server.enabled metric.
func (mb *MetricsBuilder) RecordBigipVirtualServerEnabledDataPoint(ts pcommon.Timestamp, val int64, statusAttribute BigipVirtualServerEnabledAttributeStatus) {
	mb.metricBigipVirtualServerEnabled.recordDataPoint(mb.startTime, ts, val, statusAttribute.String())
}

// RecordBigipVirtualServerPacketCountDataPoint adds a data point to bigip.virtual_server.packet.count metric.
func (mb *MetricsBuilder) RecordBigipVirtualServerPacketCountDataPoint(ts pcommon.Timestamp, val int64, directionAttribute BigipVirtualServerPacketCountAttributeDirection) {
	mb.metricBigipVirtualServerPacketCount.recordDataPoint(mb.startTime, ts, val, directionAttribute.String())
}

// RecordBigipVirtualServerRequestCountDataPoint adds a data point to bigip.virtual_server.request.count metric.
func (mb *MetricsBuilder) RecordBigipVirtualServerRequestCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricBigipVirtualServerRequestCount.recordDataPoint(mb.startTime, ts, val)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}
