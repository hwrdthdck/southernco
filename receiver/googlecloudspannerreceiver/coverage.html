
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>googlecloudspannerreceiver: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/config.go (100.0%)</option>
				
				<option value="file1">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/factory.go (87.5%)</option>
				
				<option value="file2">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/datasource/database.go (100.0%)</option>
				
				<option value="file3">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/datasource/databaseid.go (100.0%)</option>
				
				<option value="file4">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/filter/itemcardinality.go (94.5%)</option>
				
				<option value="file5">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/filter/nopitemcardinality.go (100.0%)</option>
				
				<option value="file6">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/filterfactory/filterbuilder.go (96.0%)</option>
				
				<option value="file7">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/filterfactory/itemfilterfactory.go (100.0%)</option>
				
				<option value="file8">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata/labelvalue.go (98.7%)</option>
				
				<option value="file9">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata/metricdatatype.go (100.0%)</option>
				
				<option value="file10">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata/metricsbuilder.go (98.3%)</option>
				
				<option value="file11">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata/metricsdatapoint.go (94.3%)</option>
				
				<option value="file12">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata/metricsmetadata.go (100.0%)</option>
				
				<option value="file13">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata/metricvalue.go (97.4%)</option>
				
				<option value="file14">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadataparser/label.go (100.0%)</option>
				
				<option value="file15">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadataparser/metadata.go (100.0%)</option>
				
				<option value="file16">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadataparser/metadataparser.go (100.0%)</option>
				
				<option value="file17">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadataparser/metric.go (100.0%)</option>
				
				<option value="file18">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadataparser/metrictype.go (100.0%)</option>
				
				<option value="file19">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/statsreader/currentstatsreader.go (20.8%)</option>
				
				<option value="file20">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/statsreader/databasereader.go (95.8%)</option>
				
				<option value="file21">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/statsreader/intervalstatsreader.go (22.2%)</option>
				
				<option value="file22">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/statsreader/projectreader.go (94.1%)</option>
				
				<option value="file23">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/statsreader/statements.go (100.0%)</option>
				
				<option value="file24">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/statsreader/timestampsgenerator.go (100.0%)</option>
				
				<option value="file25">github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/receiver.go (95.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package googlecloudspannerreceiver // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver"

import (
        "errors"
        "fmt"

        "go.opentelemetry.io/collector/receiver/scraperhelper"
)

const (
        minCollectionIntervalSeconds = 60
        maxTopMetricsQueryMaxRows    = 100
)

type Config struct {
        scraperhelper.ScraperControllerSettings `mapstructure:",squash"`

        TopMetricsQueryMaxRows            int       `mapstructure:"top_metrics_query_max_rows"`
        BackfillEnabled                   bool      `mapstructure:"backfill_enabled"`
        CardinalityTotalLimit             int       `mapstructure:"cardinality_total_limit"`
        Projects                          []Project `mapstructure:"projects"`
        HideTopnLockstatsRowrangestartkey bool      `mapstructure:"hide_topn_lockstats_rowrangestartkey"`
        TruncateText                      bool      `mapstructure:"truncate_text"`
}

type Project struct {
        ID                string     `mapstructure:"project_id"`
        ServiceAccountKey string     `mapstructure:"service_account_key"`
        Instances         []Instance `mapstructure:"instances"`
}

type Instance struct {
        ID        string   `mapstructure:"instance_id"`
        Databases []string `mapstructure:"databases"`
}

func (config *Config) Validate() error <span class="cov7" title="8">{
        if config.CollectionInterval.Seconds() &lt; minCollectionIntervalSeconds </span><span class="cov1" title="1">{
                return fmt.Errorf("\"collection_interval\" must be not lower than %v seconds, current value is %v seconds", minCollectionIntervalSeconds, config.CollectionInterval.Seconds())
        }</span>

        <span class="cov6" title="7">if config.TopMetricsQueryMaxRows &lt;= 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("\"top_metrics_query_max_rows\" must be positive: %v", config.TopMetricsQueryMaxRows)
        }</span>

        <span class="cov6" title="6">if config.TopMetricsQueryMaxRows &gt; maxTopMetricsQueryMaxRows </span><span class="cov1" title="1">{
                return fmt.Errorf("\"top_metrics_query_max_rows\" must be not greater than %v, current value is %v", maxTopMetricsQueryMaxRows, config.TopMetricsQueryMaxRows)
        }</span>

        <span class="cov5" title="5">if config.CardinalityTotalLimit &lt; 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("\"cardinality_total_limit\" must be not negative, current value is %v", config.CardinalityTotalLimit)
        }</span>

        <span class="cov5" title="4">if len(config.Projects) == 0 </span><span class="cov1" title="1">{
                return errors.New("missing required field \"projects\" or its value is empty")
        }</span>

        <span class="cov4" title="3">for _, project := range config.Projects </span><span class="cov4" title="3">{
                if err := project.Validate(); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }

        <span class="cov3" title="2">return nil</span>
}

func (project Project) Validate() error <span class="cov9" title="15">{
        if project.ID == "" </span><span class="cov4" title="3">{
                return errors.New(`field "project_id" is required and cannot be empty for project configuration`)
        }</span>

        <span class="cov8" title="12">if len(project.Instances) == 0 </span><span class="cov1" title="1">{
                return errors.New("field \"instances\" is required and cannot be empty for project configuration")
        }</span>

        <span class="cov8" title="11">for _, instance := range project.Instances </span><span class="cov8" title="11">{
                if err := instance.Validate(); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }

        <span class="cov7" title="10">return nil</span>
}

func (instance Instance) Validate() error <span class="cov10" title="21">{
        if instance.ID == "" </span><span class="cov3" title="2">{
                return errors.New("field \"instance_id\" is required and cannot be empty for instance configuration")
        }</span>

        <span class="cov9" title="19">if len(instance.Databases) == 0 </span><span class="cov1" title="1">{
                return errors.New("field \"databases\" is required and cannot be empty for instance configuration")
        }</span>

        <span class="cov9" title="18">for _, database := range instance.Databases </span><span class="cov9" title="18">{
                if database == "" </span><span class="cov1" title="1">{
                        return errors.New("field \"databases\" contains empty database names")
                }</span>
        }

        <span class="cov9" title="17">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package googlecloudspannerreceiver // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver"

import (
        "context"
        "time"

        "go.opentelemetry.io/collector/component"
        "go.opentelemetry.io/collector/consumer"
        "go.opentelemetry.io/collector/receiver"
        "go.opentelemetry.io/collector/receiver/scraperhelper"

        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata"
)

const (
        defaultCollectionInterval                = 60 * time.Second
        defaultTopMetricsQueryMaxRows            = 100
        defaultBackfillEnabled                   = false
        defaultHideTopnLockstatsRowrangestartkey = false
        defaultTruncateText                      = false
)

func NewFactory() receiver.Factory <span class="cov5" title="4">{
        return receiver.NewFactory(
                metadata.Type,
                createDefaultConfig,
                receiver.WithMetrics(createMetricsReceiver, metadata.MetricsStability))
}</span>

func createDefaultConfig() component.Config <span class="cov10" title="17">{
        return &amp;Config{
                ScraperControllerSettings:         scraperhelper.NewDefaultScraperControllerSettings(metadata.Type),
                TopMetricsQueryMaxRows:            defaultTopMetricsQueryMaxRows,
                BackfillEnabled:                   defaultBackfillEnabled,
                HideTopnLockstatsRowrangestartkey: defaultHideTopnLockstatsRowrangestartkey,
                TruncateText:                      defaultTruncateText,
        }
}</span>

func createMetricsReceiver(
        _ context.Context,
        settings receiver.CreateSettings,
        baseCfg component.Config,
        consumer consumer.Metrics,
) (receiver.Metrics, error) <span class="cov3" title="2">{

        rCfg := baseCfg.(*Config)
        r := newGoogleCloudSpannerReceiver(settings.Logger, rCfg)

        scraper, err := scraperhelper.NewScraper(metadata.Type, r.Scrape, scraperhelper.WithStart(r.Start),
                scraperhelper.WithShutdown(r.Shutdown))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="2">return scraperhelper.NewScraperControllerReceiver(&amp;rCfg.ScraperControllerSettings, settings, consumer,
                scraperhelper.AddScraper(scraper))</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package datasource // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/datasource"

import (
        "context"

        "cloud.google.com/go/spanner"
        "google.golang.org/api/option"
)

type Database struct {
        client     *spanner.Client
        databaseID *DatabaseID
}

func (database *Database) Client() *spanner.Client <span class="cov10" title="3">{
        return database.client
}</span>

func (database *Database) DatabaseID() *DatabaseID <span class="cov10" title="3">{
        return database.databaseID
}</span>

func NewDatabase(ctx context.Context, databaseID *DatabaseID, credentialsFilePath string) (*Database, error) <span class="cov10" title="3">{
        var client *spanner.Client
        var err error

        if credentialsFilePath != "" </span><span class="cov6" title="2">{
                credentialsFileClientOption := option.WithCredentialsFile(credentialsFilePath)
                client, err = spanner.NewClient(ctx, databaseID.ID(), credentialsFileClientOption)
        }</span> else<span class="cov1" title="1"> {
                // Fallback to Application Default Credentials(https://google.aip.dev/auth/4110)
                client, err = spanner.NewClient(ctx, databaseID.ID())
        }</span>

        <span class="cov10" title="3">if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov6" title="2">return NewDatabaseFromClient(client, databaseID), nil</span>
}

func NewDatabaseFromClient(client *spanner.Client, databaseID *DatabaseID) *Database <span class="cov10" title="3">{
        return &amp;Database{
                client:     client,
                databaseID: databaseID,
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package datasource // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/datasource"

import "fmt"

type DatabaseID struct {
        projectID    string
        instanceID   string
        databaseName string
        id           string
}

func NewDatabaseID(projectID string, instanceID string, databaseName string) *DatabaseID <span class="cov10" title="5">{
        return &amp;DatabaseID{
                projectID:    projectID,
                instanceID:   instanceID,
                databaseName: databaseName,
                id:           fmt.Sprintf("projects/%v/instances/%v/databases/%v", projectID, instanceID, databaseName),
        }
}</span>

func (databaseID *DatabaseID) ProjectID() string <span class="cov1" title="1">{
        return databaseID.projectID
}</span>

func (databaseID *DatabaseID) InstanceID() string <span class="cov1" title="1">{
        return databaseID.instanceID
}</span>

func (databaseID *DatabaseID) DatabaseName() string <span class="cov1" title="1">{
        return databaseID.databaseName
}</span>
func (databaseID *DatabaseID) ID() string <span class="cov8" title="4">{
        return databaseID.id
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package filter // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/filter"

import (
        "errors"
        "fmt"
        "sort"
        "time"

        "github.com/ReneKroon/ttlcache/v2"
        "go.uber.org/zap"
)

type Item struct {
        SeriesKey string
        Timestamp time.Time
}

type ItemFilter interface {
        Filter(source []*Item) ([]*Item, error)
        Shutdown() error
        TotalLimit() int
        LimitByTimestamp() int
}

type ItemFilterResolver interface {
        Resolve(metricFullName string) (ItemFilter, error)
        Shutdown() error
}

type itemCardinalityFilter struct {
        metricName         string
        totalLimit         int
        limitByTimestamp   int
        itemActivityPeriod time.Duration
        logger             *zap.Logger
        cache              *ttlcache.Cache
}

type currentLimitByTimestamp struct {
        limitByTimestamp int
}

func (f *currentLimitByTimestamp) dec() <span class="cov7" title="14">{
        f.limitByTimestamp--
}</span>

func (f *currentLimitByTimestamp) get() int <span class="cov9" title="31">{
        return f.limitByTimestamp
}</span>

func NewItemCardinalityFilter(metricName string, totalLimit int, limitByTimestamp int,
        itemActivityPeriod time.Duration, logger *zap.Logger) (ItemFilter, error) <span class="cov7" title="13">{
        if limitByTimestamp &gt; totalLimit </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("total limit %q is lower or equal to limit by timestamp %q", totalLimit, limitByTimestamp)
        }</span>

        <span class="cov6" title="12">cache := ttlcache.NewCache()

        cache.SetCacheSizeLimit(totalLimit)
        cache.SkipTTLExtensionOnHit(true)

        return &amp;itemCardinalityFilter{
                metricName:         metricName,
                totalLimit:         totalLimit,
                limitByTimestamp:   limitByTimestamp,
                itemActivityPeriod: itemActivityPeriod,
                logger:             logger,
                cache:              cache,
        }, nil</span>
}

func (f *itemCardinalityFilter) TotalLimit() int <span class="cov1" title="1">{
        return f.totalLimit
}</span>

func (f *itemCardinalityFilter) LimitByTimestamp() int <span class="cov1" title="1">{
        return f.limitByTimestamp
}</span>

func (f *itemCardinalityFilter) Filter(sourceItems []*Item) ([]*Item, error) <span class="cov5" title="7">{
        var filteredItems []*Item
        groupedItems := groupByTimestamp(sourceItems)
        sortedItemKeys := sortedKeys(groupedItems)

        for _, key := range sortedItemKeys </span><span class="cov6" title="9">{
                filteredGroupedItems, err := f.filterItems(groupedItems[key])
                if err != nil </span><span class="cov2" title="2">{
                        return nil, err
                }</span>

                <span class="cov5" title="7">filteredItems = append(filteredItems, filteredGroupedItems...)</span>
        }

        <span class="cov4" title="5">return filteredItems, nil</span>
}

func (f *itemCardinalityFilter) filterItems(items []*Item) ([]*Item, error) <span class="cov6" title="11">{
        limit := currentLimitByTimestamp{
                limitByTimestamp: f.limitByTimestamp,
        }

        var filteredItems []*Item
        for _, item := range items </span><span class="cov9" title="39">{
                if included, err := f.includeItem(item, &amp;limit); err != nil </span><span class="cov2" title="2">{
                        return nil, err
                }</span> else<span class="cov9" title="37"> if included </span><span class="cov8" title="21">{
                        filteredItems = append(filteredItems, item)
                }</span>
        }

        <span class="cov6" title="9">return filteredItems, nil</span>
}

func (f *itemCardinalityFilter) includeItem(item *Item, limit *currentLimitByTimestamp) (bool, error) <span class="cov10" title="43">{
        if _, err := f.cache.Get(item.SeriesKey); err == nil </span><span class="cov6" title="10">{
                return true, nil
        }</span> else<span class="cov9" title="33"> if !errors.Is(err, ttlcache.ErrNotFound) </span><span class="cov3" title="3">{
                return false, err
        }</span>

        <span class="cov9" title="30">if !f.canIncludeNewItem(limit.get()) </span><span class="cov7" title="17">{
                f.logger.Debug("Skip item", zap.String("seriesKey", item.SeriesKey), zap.Time("timestamp", item.Timestamp))
                return false, nil
        }</span>

        <span class="cov7" title="13">if err := f.cache.SetWithTTL(item.SeriesKey, struct{}{}, f.itemActivityPeriod); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, ttlcache.ErrClosed) </span><span class="cov0" title="0">{
                        err = fmt.Errorf("set item from cache failed for metric %q because cache has been already closed: %w", f.metricName, err)
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }

        <span class="cov7" title="13">f.logger.Debug("Added item to cache", zap.String("seriesKey", item.SeriesKey), zap.Time("timestamp", item.Timestamp))

        limit.dec()

        return true, nil</span>
}

func (f *itemCardinalityFilter) canIncludeNewItem(currentLimitByTimestamp int) bool <span class="cov9" title="33">{
        return f.cache.Count() &lt; f.totalLimit &amp;&amp; currentLimitByTimestamp &gt; 0
}</span>

func (f *itemCardinalityFilter) Shutdown() error <span class="cov6" title="11">{
        return f.cache.Close()
}</span>

func groupByTimestamp(items []*Item) map[time.Time][]*Item <span class="cov5" title="8">{
        groupedItems := make(map[time.Time][]*Item)

        for _, item := range items </span><span class="cov9" title="42">{
                groupedItems[item.Timestamp] = append(groupedItems[item.Timestamp], item)
        }</span>

        <span class="cov5" title="8">return groupedItems</span>
}

func sortedKeys(groupedItems map[time.Time][]*Item) []time.Time <span class="cov5" title="8">{
        keysForSorting := make([]time.Time, len(groupedItems))

        i := 0
        for key := range groupedItems </span><span class="cov6" title="12">{
                keysForSorting[i] = key
                i++
        }</span>

        <span class="cov5" title="8">sort.Slice(keysForSorting, func(i, j int) bool </span><span class="cov4" title="5">{ return keysForSorting[i].Before(keysForSorting[j]) }</span>)

        <span class="cov5" title="8">return keysForSorting</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package filter // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/filter"

type nopItemCardinalityFilter struct {
        // No fields here
}

type nopItemFilterResolver struct {
        nopFilter *nopItemCardinalityFilter
}

func NewNopItemCardinalityFilter() ItemFilter <span class="cov1" title="1">{
        return &amp;nopItemCardinalityFilter{}
}</span>

func NewNopItemFilterResolver() ItemFilterResolver <span class="cov10" title="2">{
        return &amp;nopItemFilterResolver{
                nopFilter: &amp;nopItemCardinalityFilter{},
        }
}</span>

func (f *nopItemCardinalityFilter) Filter(sourceItems []*Item) ([]*Item, error) <span class="cov1" title="1">{
        return sourceItems, nil
}</span>

func (f *nopItemCardinalityFilter) Shutdown() error <span class="cov1" title="1">{
        return nil
}</span>

func (f *nopItemCardinalityFilter) TotalLimit() int <span class="cov1" title="1">{
        return 0
}</span>

func (f *nopItemCardinalityFilter) LimitByTimestamp() int <span class="cov1" title="1">{
        return 0
}</span>

func (r *nopItemFilterResolver) Resolve(string) (ItemFilter, error) <span class="cov1" title="1">{
        return r.nopFilter, nil
}</span>

func (r *nopItemFilterResolver) Shutdown() error <span class="cov1" title="1">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package filterfactory // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/filterfactory"

import (
        "errors"

        "go.uber.org/zap"

        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/filter"
        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata"
)

type filterBuilder struct {
        logger *zap.Logger
        config *ItemFilterFactoryConfig
}

func (b filterBuilder) buildFilterByMetricZeroTotalLimit() map[string]filter.ItemFilter <span class="cov2" title="2">{
        filterByMetric := make(map[string]filter.ItemFilter)
        nopFilter := filter.NewNopItemCardinalityFilter()

        for _, metadataItem := range b.config.MetadataItems </span><span class="cov4" title="4">{
                for _, metricValueMetadata := range metadataItem.QueryMetricValuesMetadata </span><span class="cov6" title="8">{
                        metricFullName := metadataItem.MetricNamePrefix + metricValueMetadata.Name()
                        filterByMetric[metricFullName] = nopFilter
                }</span>
        }

        <span class="cov2" title="2">return filterByMetric</span>
}

func (b filterBuilder) buildFilterByMetricPositiveTotalLimit() (map[string]filter.ItemFilter, error) <span class="cov5" title="6">{
        filterByMetric := make(map[string]filter.ItemFilter)
        groupedItems := groupByCardinality(b.config.MetadataItems)

        // Handle metric groups with low cardinality
        lowCardinalityGroups := groupedItems[false]
        newTotalLimit, err := b.handleLowCardinalityGroups(lowCardinalityGroups, b.config.TotalLimit, filterByMetric)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Handle metric groups with high cardinality
        <span class="cov5" title="6">highCardinalityGroups := groupedItems[true]
        newTotalLimit, err = b.handleHighCardinalityGroups(highCardinalityGroups, newTotalLimit, filterByMetric)
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov4" title="4">b.logger.Debug("Remaining total limit after cardinality limits calculation",
                zap.Int("remainingTotalLimit", newTotalLimit))

        return filterByMetric, nil</span>
}

func (b filterBuilder) handleLowCardinalityGroups(groups []*metadata.MetricsMetadata, remainingTotalLimit int,
        filterByMetric map[string]filter.ItemFilter) (int, error) <span class="cov6" title="8">{

        if len(groups) == 0 </span><span class="cov5" title="5">{
                return remainingTotalLimit, nil
        }</span>

        <span class="cov3" title="3">limitPerMetricByTimestamp := b.config.ProjectAmount * b.config.InstanceAmount * b.config.DatabaseAmount

        // For low cardinality metrics total limit is equal to limit by timestamp
        b.logger.Debug("Calculated cardinality limits for low cardinality metric group",
                zap.Int("limitPerMetricByTimestamp", limitPerMetricByTimestamp))

        return b.constructFiltersForGroups(limitPerMetricByTimestamp, limitPerMetricByTimestamp, groups, remainingTotalLimit, filterByMetric)</span>
}

func (b filterBuilder) handleHighCardinalityGroups(groups []*metadata.MetricsMetadata, remainingTotalLimit int,
        filterByMetric map[string]filter.ItemFilter) (int, error) <span class="cov6" title="9">{

        if len(groups) == 0 </span><span class="cov2" title="2">{
                return remainingTotalLimit, nil
        }</span>

        <span class="cov6" title="7">totalLimitPerMetric := remainingTotalLimit / countMetricsInGroups(groups)
        limitPerMetricByTimestamp := totalLimitPerMetric / defaultMetricDataPointsAmountInPeriod

        b.logger.Debug("Calculated cardinality limits for high cardinality metric group",
                zap.Int("limitPerMetricByTimestamp", limitPerMetricByTimestamp),
                zap.Int("totalLimitPerMetric", totalLimitPerMetric))

        if limitPerMetricByTimestamp &lt; 1 </span><span class="cov3" title="3">{
                return remainingTotalLimit, errors.New("limit per metric per timestamp for high cardinality metrics is lower than 1")
        }</span>

        <span class="cov4" title="4">return b.constructFiltersForGroups(totalLimitPerMetric, limitPerMetricByTimestamp, groups, remainingTotalLimit, filterByMetric)</span>
}

func (b filterBuilder) constructFiltersForGroups(totalLimitPerMetric int, limitPerMetricByTimestamp int,
        groups []*metadata.MetricsMetadata, remainingTotalLimit int, filterByMetric map[string]filter.ItemFilter) (int, error) <span class="cov6" title="8">{

        newTotalLimit := remainingTotalLimit

        for _, metadataItem := range groups </span><span class="cov8" title="14">{
                for _, metricValueMetadata := range metadataItem.QueryMetricValuesMetadata </span><span class="cov10" title="28">{
                        newTotalLimit -= totalLimitPerMetric
                        metricFullName := metadataItem.MetricNamePrefix + metricValueMetadata.Name()

                        b.logger.Debug("Setting cardinality limits for metric",
                                zap.String("metricFullName", metricFullName),
                                zap.Int("limitPerMetricByTimestamp", limitPerMetricByTimestamp),
                                zap.Int("totalLimitPerMetric", totalLimitPerMetric),
                                zap.Int("remainingTotalLimit", newTotalLimit))

                        itemFilter, err := filter.NewItemCardinalityFilter(metricFullName, totalLimitPerMetric,
                                limitPerMetricByTimestamp, defaultItemActivityPeriod, b.logger)
                        if err != nil </span><span class="cov0" title="0">{
                                return remainingTotalLimit, err
                        }</span>
                        <span class="cov10" title="28">filterByMetric[metricFullName] = itemFilter</span>
                }
        }

        <span class="cov6" title="8">return newTotalLimit, nil</span>
}

func countMetricsInGroups(metadataItems []*metadata.MetricsMetadata) (amount int) <span class="cov6" title="8">{
        for _, metadataItem := range metadataItems </span><span class="cov8" title="15">{
                amount += len(metadataItem.QueryMetricValuesMetadata)
        }</span>

        <span class="cov6" title="8">return amount</span>
}

func groupByCardinality(metadataItems []*metadata.MetricsMetadata) map[bool][]*metadata.MetricsMetadata <span class="cov6" title="7">{
        groupedItems := make(map[bool][]*metadata.MetricsMetadata)

        for _, metadataItem := range metadataItems </span><span class="cov8" title="14">{
                groupedItems[metadataItem.HighCardinality] = append(groupedItems[metadataItem.HighCardinality], metadataItem)
        }</span>

        <span class="cov6" title="7">return groupedItems</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package filterfactory // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/filterfactory"

import (
        "errors"
        "fmt"
        "time"

        "go.uber.org/zap"

        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/filter"
        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata"
)

const (
        defaultMetricDataPointsAmountInPeriod = 24 * 60
        defaultItemActivityPeriod             = 24 * time.Hour
)

type itemFilterFactory struct {
        filterByMetric map[string]filter.ItemFilter
}

type ItemFilterFactoryConfig struct {
        MetadataItems  []*metadata.MetricsMetadata
        TotalLimit     int
        ProjectAmount  int
        InstanceAmount int
        DatabaseAmount int
}

func NewItemFilterResolver(logger *zap.Logger, config *ItemFilterFactoryConfig) (filter.ItemFilterResolver, error) <span class="cov7" title="4">{
        if err := config.validate(); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov6" title="3">builder := filterBuilder{
                logger: logger,
                config: config,
        }

        if config.TotalLimit == 0 </span><span class="cov1" title="1">{
                return &amp;itemFilterFactory{
                        filterByMetric: builder.buildFilterByMetricZeroTotalLimit(),
                }, nil
        }</span>

        <span class="cov4" title="2">filterByMetric, err := builder.buildFilterByMetricPositiveTotalLimit()
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;itemFilterFactory{
                filterByMetric: filterByMetric,
        }, nil</span>
}

func (config *ItemFilterFactoryConfig) validate() error <span class="cov10" title="7">{
        if len(config.MetadataItems) == 0 </span><span class="cov1" title="1">{
                return errors.New("metadata items cannot be empty or nil")
        }</span>

        <span class="cov9" title="6">if config.TotalLimit != 0 &amp;&amp; config.TotalLimit &lt;= (config.ProjectAmount*config.InstanceAmount*config.DatabaseAmount) </span><span class="cov4" title="2">{
                return errors.New("total limit is too low and doesn't cover configured projects * instances * databases")
        }</span>

        <span class="cov7" title="4">return nil</span>
}

func (f *itemFilterFactory) Resolve(metricFullName string) (filter.ItemFilter, error) <span class="cov4" title="2">{
        itemFilter, exists := f.filterByMetric[metricFullName]

        if !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("can't find item filter for metric with full name %q", metricFullName)
        }</span>

        <span class="cov1" title="1">return itemFilter, nil</span>
}

func (f *itemFilterFactory) Shutdown() error <span class="cov4" title="2">{
        for _, itemFilter := range f.filterByMetric </span><span class="cov4" title="2">{
                err := itemFilter.Shutdown()
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package metadata // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata"

import (
        "fmt"
        "sort"
        "strings"

        "go.opentelemetry.io/collector/pdata/pcommon"
)

type newLabelValueFunction func(m LabelValueMetadata, value interface{}) LabelValue

type LabelValueMetadata interface {
        ValueMetadata
        ValueType() ValueType
        NewLabelValue(value interface{}) LabelValue
}

type LabelValue interface {
        Metadata() LabelValueMetadata
        Value() interface{}
        SetValueTo(attributes pcommon.Map)
}

type queryLabelValueMetadata struct {
        name              string
        columnName        string
        valueType         ValueType
        newLabelValueFunc newLabelValueFunction
        valueHolderFunc   valueHolderFunction
}

func (m queryLabelValueMetadata) ValueHolder() interface{} <span class="cov5" title="22">{
        return m.valueHolderFunc()
}</span>

func (m queryLabelValueMetadata) NewLabelValue(value interface{}) LabelValue <span class="cov4" title="14">{
        return m.newLabelValueFunc(m, value)
}</span>

func (m queryLabelValueMetadata) ValueType() ValueType <span class="cov5" title="18">{
        return m.valueType
}</span>

type stringLabelValue struct {
        metadata LabelValueMetadata
        value    string
}

type int64LabelValue struct {
        metadata LabelValueMetadata
        value    int64
}

type boolLabelValue struct {
        metadata LabelValueMetadata
        value    bool
}

type stringSliceLabelValue struct {
        metadata LabelValueMetadata
        value    string
}

type byteSliceLabelValue struct {
        metadata LabelValueMetadata
        value    string
}

type lockRequestSliceLabelValue struct {
        metadata LabelValueMetadata
        value    string
}

func (m queryLabelValueMetadata) Name() string <span class="cov10" title="529">{
        return m.name
}</span>

func (m queryLabelValueMetadata) ColumnName() string <span class="cov6" title="34">{
        return m.columnName
}</span>

func (v stringLabelValue) Metadata() LabelValueMetadata <span class="cov7" title="71">{
        return v.metadata
}</span>

func (v stringLabelValue) Value() interface{} <span class="cov7" title="71">{
        return v.value
}</span>

func (v stringLabelValue) SetValueTo(attributes pcommon.Map) <span class="cov5" title="19">{
        attributes.PutStr(v.metadata.Name(), v.value)
}</span>

func newStringLabelValue(metadata LabelValueMetadata, valueHolder interface{}) LabelValue <span class="cov3" title="5">{
        return stringLabelValue{
                metadata: metadata,
                value:    *valueHolder.(*string),
        }
}</span>

func (v int64LabelValue) Metadata() LabelValueMetadata <span class="cov7" title="70">{
        return v.metadata
}</span>

func (v int64LabelValue) Value() interface{} <span class="cov7" title="69">{
        return v.value
}</span>

func (v int64LabelValue) SetValueTo(attributes pcommon.Map) <span class="cov5" title="19">{
        attributes.PutInt(v.metadata.Name(), v.value)
}</span>

func newInt64LabelValue(metadata LabelValueMetadata, valueHolder interface{}) LabelValue <span class="cov2" title="3">{
        return int64LabelValue{
                metadata: metadata,
                value:    *valueHolder.(*int64),
        }
}</span>

func (v boolLabelValue) Metadata() LabelValueMetadata <span class="cov7" title="70">{
        return v.metadata
}</span>

func (v boolLabelValue) Value() interface{} <span class="cov7" title="69">{
        return v.value
}</span>

func (v boolLabelValue) SetValueTo(attributes pcommon.Map) <span class="cov5" title="19">{
        attributes.PutBool(v.metadata.Name(), v.value)
}</span>

func newBoolLabelValue(metadata LabelValueMetadata, valueHolder interface{}) LabelValue <span class="cov2" title="3">{
        return boolLabelValue{
                metadata: metadata,
                value:    *valueHolder.(*bool),
        }
}</span>

func (v stringSliceLabelValue) Metadata() LabelValueMetadata <span class="cov7" title="70">{
        return v.metadata
}</span>

func (v stringSliceLabelValue) Value() interface{} <span class="cov7" title="69">{
        return v.value
}</span>

func (v stringSliceLabelValue) SetValueTo(attributes pcommon.Map) <span class="cov5" title="19">{
        attributes.PutStr(v.metadata.Name(), v.value)
}</span>

func newStringSliceLabelValue(metadata LabelValueMetadata, valueHolder interface{}) LabelValue <span class="cov2" title="3">{
        value := *valueHolder.(*[]string)

        sort.Strings(value)

        sortedAndConstructedValue := strings.Join(value, ",")

        return stringSliceLabelValue{
                metadata: metadata,
                value:    sortedAndConstructedValue,
        }
}</span>

func (v byteSliceLabelValue) Metadata() LabelValueMetadata <span class="cov7" title="76">{
        return v.metadata
}</span>

func (v byteSliceLabelValue) Value() interface{} <span class="cov7" title="78">{
        return v.value
}</span>

func (v byteSliceLabelValue) SetValueTo(attributes pcommon.Map) <span class="cov5" title="19">{
        attributes.PutStr(v.metadata.Name(), v.value)
}</span>

func (v *byteSliceLabelValue) ModifyValue(s string) <span class="cov3" title="7">{
        v.value = s
}</span>

func (v *stringSliceLabelValue) ModifyValue(s string) <span class="cov0" title="0">{
        v.value = s
}</span>

func (v *stringLabelValue) ModifyValue(s string) <span class="cov1" title="1">{
        v.value = s
}</span>

func newByteSliceLabelValue(metadata LabelValueMetadata, valueHolder interface{}) LabelValue <span class="cov2" title="3">{
        return byteSliceLabelValue{
                metadata: metadata,
                value:    string(*valueHolder.(*[]byte)),
        }
}</span>

func (v lockRequestSliceLabelValue) Metadata() LabelValueMetadata <span class="cov7" title="70">{
        return v.metadata
}</span>

func (v lockRequestSliceLabelValue) Value() interface{} <span class="cov7" title="69">{
        return v.value
}</span>

func (v lockRequestSliceLabelValue) SetValueTo(attributes pcommon.Map) <span class="cov5" title="19">{
        attributes.PutStr(v.metadata.Name(), v.value)
}</span>

type lockRequest struct {
        LockMode       string `spanner:"lock_mode"`
        Column         string `spanner:"column"`
        TransactionTag string `spanner:"transaction_tag"`
}

func newLockRequestSliceLabelValue(metadata LabelValueMetadata, valueHolder interface{}) LabelValue <span class="cov2" title="3">{
        value := *valueHolder.(*[]*lockRequest)
        // During the specifics of this label we need to take into account only distinct values
        uniqueValueItems := make(map[string]struct{})
        var convertedValue []string

        for _, valueItem := range value </span><span class="cov3" title="7">{
                var valueItemString string
                if valueItem.TransactionTag == "" </span><span class="cov1" title="2">{
                        valueItemString = fmt.Sprintf("{%v,%v}", valueItem.LockMode, valueItem.Column)
                }</span> else<span class="cov3" title="5"> {
                        valueItemString = fmt.Sprintf("{%v,%v,%v}", valueItem.LockMode, valueItem.Column, valueItem.TransactionTag)
                }</span>

                <span class="cov3" title="7">if _, contains := uniqueValueItems[valueItemString]; !contains </span><span class="cov3" title="5">{
                        uniqueValueItems[valueItemString] = struct{}{}
                        convertedValue = append(convertedValue, valueItemString)
                }</span>
        }

        <span class="cov2" title="3">sort.Strings(convertedValue)

        constructedValue := strings.Join(convertedValue, ",")

        return lockRequestSliceLabelValue{
                metadata: metadata,
                value:    constructedValue,
        }</span>
}

func NewLabelValueMetadata(name string, columnName string, valueType ValueType) (LabelValueMetadata, error) <span class="cov7" title="114">{
        var newLabelValueFunc newLabelValueFunction
        var valueHolderFunc valueHolderFunction

        switch valueType </span>{
        case StringValueType:<span class="cov6" title="62">
                newLabelValueFunc = newStringLabelValue
                valueHolderFunc = func() interface{} </span><span class="cov3" title="7">{
                        var valueHolder string
                        return &amp;valueHolder
                }</span>
        case IntValueType:<span class="cov3" title="5">
                newLabelValueFunc = newInt64LabelValue
                valueHolderFunc = func() interface{} </span><span class="cov2" title="3">{
                        var valueHolder int64
                        return &amp;valueHolder
                }</span>
        case BoolValueType:<span class="cov5" title="18">
                newLabelValueFunc = newBoolLabelValue
                valueHolderFunc = func() interface{} </span><span class="cov2" title="3">{
                        var valueHolder bool
                        return &amp;valueHolder
                }</span>
        case StringSliceValueType:<span class="cov3" title="5">
                newLabelValueFunc = newStringSliceLabelValue
                valueHolderFunc = func() interface{} </span><span class="cov2" title="3">{
                        var valueHolder []string
                        return &amp;valueHolder
                }</span>
        case ByteSliceValueType:<span class="cov3" title="5">
                newLabelValueFunc = newByteSliceLabelValue
                valueHolderFunc = func() interface{} </span><span class="cov2" title="3">{
                        var valueHolder []byte
                        return &amp;valueHolder
                }</span>
        case LockRequestSliceValueType:<span class="cov5" title="18">
                newLabelValueFunc = newLockRequestSliceLabelValue
                valueHolderFunc = func() interface{} </span><span class="cov2" title="3">{
                        var valueHolder []*lockRequest
                        return &amp;valueHolder
                }</span>
        case UnknownValueType, FloatValueType, NullFloatValueType:<span class="cov1" title="1">
                fallthrough</span>
        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("invalid value type received for label %q", name)</span>
        }

        <span class="cov7" title="113">return queryLabelValueMetadata{
                name:              name,
                columnName:        columnName,
                valueType:         valueType,
                newLabelValueFunc: newLabelValueFunc,
                valueHolderFunc:   valueHolderFunc,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package metadata // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata"

import "go.opentelemetry.io/collector/pdata/pmetric"

type MetricType interface {
        MetricType() pmetric.MetricType
        AggregationTemporality() pmetric.AggregationTemporality
        IsMonotonic() bool
}

type metricValueDataType struct {
        dataType               pmetric.MetricType
        aggregationTemporality pmetric.AggregationTemporality
        isMonotonic            bool
}

func NewMetricType(dataType pmetric.MetricType, aggregationTemporality pmetric.AggregationTemporality,
        isMonotonic bool) MetricType <span class="cov9" title="17">{
        return metricValueDataType{
                dataType:               dataType,
                aggregationTemporality: aggregationTemporality,
                isMonotonic:            isMonotonic,
        }
}</span>

func (metricValueDataType metricValueDataType) MetricType() pmetric.MetricType <span class="cov10" title="22">{
        return metricValueDataType.dataType
}</span>

func (metricValueDataType metricValueDataType) AggregationTemporality() pmetric.AggregationTemporality <span class="cov5" title="4">{
        return metricValueDataType.aggregationTemporality
}</span>

func (metricValueDataType metricValueDataType) IsMonotonic() bool <span class="cov5" title="4">{
        return metricValueDataType.isMonotonic
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package metadata // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata"

import (
        "go.opentelemetry.io/collector/pdata/pmetric"

        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/filter"
)

const instrumentationLibraryName = "otelcol/googlecloudspannermetrics"

type MetricsBuilder interface {
        Build(dataPoints []*MetricsDataPoint) (pmetric.Metrics, error)
        Shutdown() error
}

type metricsFromDataPointBuilder struct {
        filterResolver filter.ItemFilterResolver
}

func NewMetricsFromDataPointBuilder(filterResolver filter.ItemFilterResolver) MetricsBuilder <span class="cov1" title="1">{
        return &amp;metricsFromDataPointBuilder{
                filterResolver: filterResolver,
        }
}</span>

func (b *metricsFromDataPointBuilder) Shutdown() error <span class="cov6" title="12">{
        return b.filterResolver.Shutdown()
}</span>

func (b *metricsFromDataPointBuilder) Build(dataPoints []*MetricsDataPoint) (pmetric.Metrics, error) <span class="cov4" title="4">{
        var metrics pmetric.Metrics

        groupedDataPoints, err := b.groupAndFilter(dataPoints)
        if err != nil </span><span class="cov2" title="2">{
                return pmetric.Metrics{}, err
        }</span>

        <span class="cov2" title="2">metrics = pmetric.NewMetrics()
        rms := metrics.ResourceMetrics()
        rm := rms.AppendEmpty()

        ilms := rm.ScopeMetrics()
        ilm := ilms.AppendEmpty()
        ilm.Scope().SetName(instrumentationLibraryName)

        for key, points := range groupedDataPoints </span><span class="cov4" title="4">{
                metric := ilm.Metrics().AppendEmpty()
                metric.SetName(key.MetricName)
                metric.SetUnit(key.MetricUnit)

                var dataPointSlice pmetric.NumberDataPointSlice
                switch key.MetricType.MetricType() </span>{
                case pmetric.MetricTypeGauge:<span class="cov2" title="2">
                        dataPointSlice = metric.SetEmptyGauge().DataPoints()</span>
                case pmetric.MetricTypeSum:<span class="cov2" title="2">
                        metric.SetEmptySum().SetAggregationTemporality(key.MetricType.AggregationTemporality())
                        metric.Sum().SetIsMonotonic(key.MetricType.IsMonotonic())
                        dataPointSlice = metric.Sum().DataPoints()</span>
                case pmetric.MetricTypeEmpty, pmetric.MetricTypeHistogram, pmetric.MetricTypeExponentialHistogram, pmetric.MetricTypeSummary:<span class="cov0" title="0"></span>
                }

                <span class="cov4" title="4">for _, point := range points </span><span class="cov7" title="16">{
                        point.CopyTo(dataPointSlice.AppendEmpty())
                }</span>
        }

        <span class="cov2" title="2">return metrics, nil</span>
}

func (b *metricsFromDataPointBuilder) groupAndFilter(dataPoints []*MetricsDataPoint) (map[MetricsDataPointKey][]*MetricsDataPoint, error) <span class="cov5" title="7">{
        if len(dataPoints) == 0 </span><span class="cov1" title="1">{
                return nil, nil
        }</span>

        <span class="cov5" title="6">groupedDataPoints := make(map[MetricsDataPointKey][]*MetricsDataPoint)

        for _, dataPoint := range dataPoints </span><span class="cov10" title="48">{
                groupingKey := dataPoint.GroupingKey()
                groupedDataPoints[groupingKey] = append(groupedDataPoints[groupingKey], dataPoint)
        }</span>

        // Cardinality filtering
        <span class="cov5" title="6">for groupingKey, points := range groupedDataPoints </span><span class="cov6" title="9">{
                filteredPoints, err := b.filter(groupingKey.MetricName, points)
                if err != nil </span><span class="cov3" title="3">{
                        return nil, err
                }</span>

                <span class="cov5" title="6">groupedDataPoints[groupingKey] = filteredPoints</span>
        }

        <span class="cov3" title="3">return groupedDataPoints, nil</span>
}

func (b *metricsFromDataPointBuilder) filter(metricName string, dataPoints []*MetricsDataPoint) ([]*MetricsDataPoint, error) <span class="cov6" title="11">{
        itemFilter, err := b.filterResolver.Resolve(metricName)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov6" title="10">itemsForFiltering := make([]*filter.Item, len(dataPoints))

        for i, dataPoint := range dataPoints </span><span class="cov9" title="44">{
                itemsForFiltering[i], err = dataPoint.ToItem()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov6" title="10">filteredItems, err := itemFilter.Filter(itemsForFiltering)
        if err != nil </span><span class="cov3" title="3">{
                return nil, err
        }</span>

        // Creating new slice instead of removing elements from source slice because removing by value is not efficient operation.
        // Need to use such approach for preserving data points order.
        <span class="cov5" title="7">filteredItemsSet := make(map[filter.Item]struct{})

        for _, filteredItem := range filteredItems </span><span class="cov9" title="32">{
                filteredItemsSet[*filteredItem] = struct{}{}
        }</span>

        <span class="cov5" title="7">filteredDataPoints := make([]*MetricsDataPoint, len(filteredItems))
        nextFilteredDataPointIndex := 0
        for i, dataPointItem := range itemsForFiltering </span><span class="cov9" title="32">{
                _, exists := filteredItemsSet[*dataPointItem]

                if exists </span><span class="cov9" title="32">{
                        filteredDataPoints[nextFilteredDataPointIndex] = dataPoints[i]
                        nextFilteredDataPointIndex++
                }</span>
        }

        <span class="cov5" title="7">return filteredDataPoints, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package metadata // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata"

import (
        "fmt"
        "hash/fnv"
        "strings"
        "time"
        "unicode/utf8"

        "github.com/mitchellh/hashstructure"
        "go.opentelemetry.io/collector/pdata/pcommon"
        "go.opentelemetry.io/collector/pdata/pmetric"

        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/datasource"
        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/filter"
)

const (
        projectIDLabelName  = "project_id"
        instanceIDLabelName = "instance_id"
        databaseLabelName   = "database"
)

type MetricsDataPointKey struct {
        MetricName string
        MetricUnit string
        MetricType MetricType
}

type MetricsDataPoint struct {
        metricName  string
        timestamp   time.Time
        databaseID  *datasource.DatabaseID
        labelValues []LabelValue
        metricValue MetricValue
}

// Fields must be exported for hashing purposes
type dataForHashing struct {
        MetricName string
        Labels     []label
}

// Fields must be exported for hashing purposes
type label struct {
        Name  string
        Value interface{}
}

func (mdp *MetricsDataPoint) CopyTo(dataPoint pmetric.NumberDataPoint) <span class="cov5" title="18">{
        dataPoint.SetTimestamp(pcommon.NewTimestampFromTime(mdp.timestamp))

        mdp.metricValue.SetValueTo(dataPoint)

        attributes := dataPoint.Attributes()
        attributes.EnsureCapacity(3 + len(mdp.labelValues))
        attributes.PutStr(projectIDLabelName, mdp.databaseID.ProjectID())
        attributes.PutStr(instanceIDLabelName, mdp.databaseID.InstanceID())
        attributes.PutStr(databaseLabelName, mdp.databaseID.DatabaseName())
        for i := range mdp.labelValues </span><span class="cov8" title="108">{
                mdp.labelValues[i].SetValueTo(attributes)
        }</span>
}

func (mdp *MetricsDataPoint) GroupingKey() MetricsDataPointKey <span class="cov7" title="49">{
        return MetricsDataPointKey{
                MetricName: mdp.metricName,
                MetricUnit: mdp.metricValue.Metadata().Unit(),
                MetricType: mdp.metricValue.Metadata().DataType(),
        }
}</span>

func (mdp *MetricsDataPoint) ToItem() (*filter.Item, error) <span class="cov7" title="45">{
        seriesKey, err := mdp.hash()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="45">return &amp;filter.Item{
                SeriesKey: seriesKey,
                Timestamp: mdp.timestamp,
        }, nil</span>
}

func (mdp *MetricsDataPoint) toDataForHashing() dataForHashing <span class="cov7" title="47">{
        // Do not use map here because it has unpredicted order
        // Taking into account 3 default labels: project_id, instance_id, database
        labels := make([]label, len(mdp.labelValues)+3)

        labels[0] = label{Name: projectIDLabelName, Value: mdp.databaseID.ProjectID()}
        labels[1] = label{Name: instanceIDLabelName, Value: mdp.databaseID.InstanceID()}
        labels[2] = label{Name: databaseLabelName, Value: mdp.databaseID.DatabaseName()}

        labelsIndex := 3
        for _, labelValue := range mdp.labelValues </span><span class="cov10" title="282">{
                labels[labelsIndex] = label{Name: labelValue.Metadata().Name(), Value: labelValue.Value()}
                labelsIndex++
        }</span>

        <span class="cov7" title="47">return dataForHashing{
                MetricName: mdp.metricName,
                Labels:     labels,
        }</span>
}

// Convert row_range_start_key label of top-lock-stats metric from format "sample(key1, key2)" to "sample(hash1, hash2)"
func parseAndHashRowrangestartkey(key string) string <span class="cov3" title="6">{
        builderHashedKey := strings.Builder{}
        startIndexKeys := strings.Index(key, "(")
        if startIndexKeys == -1 || startIndexKeys == len(key)-1 </span><span class="cov2" title="3">{ // if "(" does not exist or is the last character of the string, then label is of incorrect format
                return ""
        }</span>
        <span class="cov2" title="3">substring := key[startIndexKeys+1 : len(key)-1]
        builderHashedKey.WriteString(key[:startIndexKeys+1])
        plusPresent := false
        if substring[len(substring)-1] == '+' </span><span class="cov1" title="1">{
                substring = substring[:len(substring)-1]
                plusPresent = true
        }</span>
        <span class="cov2" title="3">keySlice := strings.Split(substring, ",")
        hashFunction := fnv.New32a()
        for cnt, subKey := range keySlice </span><span class="cov3" title="6">{
                hashFunction.Reset()
                hashFunction.Write([]byte(subKey))
                if cnt &lt; len(keySlice)-1 </span><span class="cov2" title="3">{
                        builderHashedKey.WriteString(fmt.Sprint(hashFunction.Sum32()) + ",")
                }</span> else<span class="cov2" title="3"> {
                        builderHashedKey.WriteString(fmt.Sprint(hashFunction.Sum32()))
                }</span>
        }
        <span class="cov2" title="3">if plusPresent </span><span class="cov1" title="1">{
                builderHashedKey.WriteString("+")
        }</span>
        <span class="cov2" title="3">builderHashedKey.WriteString(")")
        return builderHashedKey.String()</span>
}

func (mdp *MetricsDataPoint) HideLockStatsRowrangestartkeyPII() <span class="cov2" title="2">{
        for index, labelValue := range mdp.labelValues </span><span class="cov3" title="6">{
                if labelValue.Metadata().Name() == "row_range_start_key" </span><span class="cov3" title="6">{
                        key := labelValue.Value().(string)
                        hashedKey := parseAndHashRowrangestartkey(key)
                        v := mdp.labelValues[index].(byteSliceLabelValue)
                        p := &amp;v
                        p.ModifyValue(hashedKey)
                        mdp.labelValues[index] = v
                }</span>
        }
}

func TruncateString(str string, length int) string <span class="cov1" title="1">{
        if length &lt;= 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov1" title="1">if utf8.RuneCountInString(str) &lt; length </span><span class="cov0" title="0">{
                return str
        }</span>

        <span class="cov1" title="1">return string([]rune(str)[:length])</span>
}

func (mdp *MetricsDataPoint) TruncateQueryText(length int) <span class="cov1" title="1">{
        for index, labelValue := range mdp.labelValues </span><span class="cov1" title="1">{
                if labelValue.Metadata().Name() == "query_text" </span><span class="cov1" title="1">{
                        queryText := labelValue.Value().(string)
                        truncateQueryText := TruncateString(queryText, length)
                        v := mdp.labelValues[index].(stringLabelValue)
                        p := &amp;v
                        p.ModifyValue(truncateQueryText)
                        mdp.labelValues[index] = v
                }</span>
        }
}

func (mdp *MetricsDataPoint) hash() (string, error) <span class="cov7" title="46">{
        hashedData, err := hashstructure.Hash(mdp.toDataForHashing(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov7" title="46">return fmt.Sprintf("%x", hashedData), nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package metadata // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata"

import (
        "fmt"
        "time"

        "cloud.google.com/go/spanner"

        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/datasource"
)

type MetricsMetadataType int32

const (
        MetricsMetadataTypeCurrentStats MetricsMetadataType = iota
        MetricsMetadataTypeIntervalStats
)

type MetricsMetadata struct {
        Name                string
        Query               string
        MetricNamePrefix    string
        TimestampColumnName string
        HighCardinality     bool
        // In addition to common metric labels
        QueryLabelValuesMetadata  []LabelValueMetadata
        QueryMetricValuesMetadata []MetricValueMetadata
}

func (metadata *MetricsMetadata) timestamp(row *spanner.Row) (time.Time, error) <span class="cov7" title="7">{
        if metadata.MetadataType() == MetricsMetadataTypeCurrentStats </span><span class="cov1" title="1">{
                return time.Now().UTC(), nil
        }</span>
        <span class="cov6" title="6">var timestamp time.Time
        err := row.ColumnByName(metadata.TimestampColumnName, &amp;timestamp)
        return timestamp, err</span>
}

func (metadata *MetricsMetadata) toLabelValues(row *spanner.Row) ([]LabelValue, error) <span class="cov6" title="5">{
        values := make([]LabelValue, len(metadata.QueryLabelValuesMetadata))

        for i, metadataItems := range metadata.QueryLabelValuesMetadata </span><span class="cov8" title="10">{
                var err error

                if values[i], err = toLabelValue(metadataItems, row); err != nil </span><span class="cov3" title="2">{
                        return nil, err
                }</span>
        }

        <span class="cov4" title="3">return values, nil</span>
}

func toLabelValue(labelValueMetadata LabelValueMetadata, row *spanner.Row) (LabelValue, error) <span class="cov10" title="16">{
        valueHolder := labelValueMetadata.ValueHolder()

        err := row.ColumnByName(labelValueMetadata.ColumnName(), valueHolder)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov9" title="14">return labelValueMetadata.NewLabelValue(valueHolder), nil</span>
}

func (metadata *MetricsMetadata) toMetricValues(row *spanner.Row) ([]MetricValue, error) <span class="cov5" title="4">{
        values := make([]MetricValue, len(metadata.QueryMetricValuesMetadata))

        for i, metadataItems := range metadata.QueryMetricValuesMetadata </span><span class="cov6" title="5">{
                var err error

                if values[i], err = toMetricValue(metadataItems, row); err != nil </span><span class="cov3" title="2">{
                        return nil, err
                }</span>
        }

        <span class="cov3" title="2">return values, nil</span>
}

func toMetricValue(metricValueMetadata MetricValueMetadata, row *spanner.Row) (MetricValue, error) <span class="cov7" title="7">{
        valueHolder := metricValueMetadata.ValueHolder()

        err := row.ColumnByName(metricValueMetadata.ColumnName(), valueHolder)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov6" title="5">return metricValueMetadata.NewMetricValue(valueHolder), nil</span>
}

func (metadata *MetricsMetadata) RowToMetricsDataPoints(databaseID *datasource.DatabaseID, row *spanner.Row) ([]*MetricsDataPoint, error) <span class="cov5" title="4">{
        timestamp, err := metadata.timestamp(row)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("error occurred during extracting timestamp %w", err)
        }</span>

        // Reading labels
        <span class="cov4" title="3">labelValues, err := metadata.toLabelValues(row)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("error occurred during extracting label values for row: %w", err)
        }</span>

        // Reading metrics
        <span class="cov3" title="2">metricValues, err := metadata.toMetricValues(row)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("error occurred during extracting metric values row: %w", err)
        }</span>

        <span class="cov1" title="1">return metadata.toMetricsDataPoints(databaseID, timestamp, labelValues, metricValues), nil</span>
}

func (metadata *MetricsMetadata) toMetricsDataPoints(databaseID *datasource.DatabaseID, timestamp time.Time,
        labelValues []LabelValue, metricValues []MetricValue) []*MetricsDataPoint <span class="cov3" title="2">{

        dataPoints := make([]*MetricsDataPoint, len(metricValues))

        for i, metricValue := range metricValues </span><span class="cov4" title="3">{
                dataPoint := &amp;MetricsDataPoint{
                        metricName:  metadata.MetricNamePrefix + metricValue.Metadata().Name(),
                        timestamp:   timestamp,
                        databaseID:  databaseID,
                        labelValues: labelValues,
                        metricValue: metricValue,
                }
                dataPoints[i] = dataPoint
        }</span>

        <span class="cov3" title="2">return dataPoints</span>
}

func (metadata *MetricsMetadata) MetadataType() MetricsMetadataType <span class="cov8" title="9">{
        if metadata.TimestampColumnName == "" </span><span class="cov3" title="2">{
                return MetricsMetadataTypeCurrentStats
        }</span>
        <span class="cov7" title="7">return MetricsMetadataTypeIntervalStats</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package metadata // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata"

import (
        "fmt"

        "cloud.google.com/go/spanner"
        "go.opentelemetry.io/collector/pdata/pmetric"
)

type newMetricValueFunction func(m MetricValueMetadata, value interface{}) MetricValue

type MetricValueMetadata interface {
        ValueMetadata
        ValueType() ValueType
        DataType() MetricType
        Unit() string
        NewMetricValue(value interface{}) MetricValue
}

type MetricValue interface {
        Metadata() MetricValueMetadata
        Value() interface{}
        SetValueTo(ndp pmetric.NumberDataPoint)
}

type queryMetricValueMetadata struct {
        name               string
        columnName         string
        dataType           MetricType
        unit               string
        valueType          ValueType
        newMetricValueFunc newMetricValueFunction
        valueHolderFunc    valueHolderFunction
}

type int64MetricValue struct {
        metadata MetricValueMetadata
        value    int64
}

type float64MetricValue struct {
        metadata MetricValueMetadata
        value    float64
}

type nullFloat64MetricValue struct {
        metadata MetricValueMetadata
        value    spanner.NullFloat64
}

func (m queryMetricValueMetadata) ValueHolder() interface{} <span class="cov5" title="10">{
        return m.valueHolderFunc()
}</span>

func (m queryMetricValueMetadata) NewMetricValue(value interface{}) MetricValue <span class="cov4" title="5">{
        return m.newMetricValueFunc(m, value)
}</span>

func (m queryMetricValueMetadata) Name() string <span class="cov5" title="10">{
        return m.name
}</span>

func (m queryMetricValueMetadata) ColumnName() string <span class="cov6" title="14">{
        return m.columnName
}</span>

func (m queryMetricValueMetadata) ValueType() ValueType <span class="cov5" title="10">{
        return m.valueType
}</span>

func (m queryMetricValueMetadata) DataType() MetricType <span class="cov9" title="85">{
        return m.dataType
}</span>

func (m queryMetricValueMetadata) Unit() string <span class="cov9" title="85">{
        return m.unit
}</span>

func (v int64MetricValue) Metadata() MetricValueMetadata <span class="cov10" title="103">{
        return v.metadata
}</span>

func (v float64MetricValue) Metadata() MetricValueMetadata <span class="cov9" title="70">{
        return v.metadata
}</span>

func (v nullFloat64MetricValue) Metadata() MetricValueMetadata <span class="cov0" title="0">{
        return v.metadata
}</span>

func (v int64MetricValue) Value() interface{} <span class="cov6" title="14">{
        return v.value
}</span>

func (v float64MetricValue) Value() interface{} <span class="cov6" title="14">{
        return v.value
}</span>

func (v nullFloat64MetricValue) Value() interface{} <span class="cov3" title="3">{
        return v.value
}</span>

func (v int64MetricValue) SetValueTo(point pmetric.NumberDataPoint) <span class="cov5" title="10">{
        point.SetIntValue(v.value)
}</span>

func (v float64MetricValue) SetValueTo(point pmetric.NumberDataPoint) <span class="cov5" title="10">{
        point.SetDoubleValue(v.value)
}</span>

func (v nullFloat64MetricValue) SetValueTo(point pmetric.NumberDataPoint) <span class="cov2" title="2">{
        if v.value.Valid </span><span class="cov1" title="1">{
                point.SetDoubleValue(v.value.Float64)
        }</span> else<span class="cov1" title="1"> {
                point.SetDoubleValue(0)
        }</span>
}

func newInt64MetricValue(metadata MetricValueMetadata, valueHolder interface{}) MetricValue <span class="cov3" title="4">{
        return int64MetricValue{
                metadata: metadata,
                value:    *valueHolder.(*int64),
        }
}</span>

func newFloat64MetricValue(metadata MetricValueMetadata, valueHolder interface{}) MetricValue <span class="cov3" title="3">{
        return float64MetricValue{
                metadata: metadata,
                value:    *valueHolder.(*float64),
        }
}</span>

func newNullFloat64MetricValue(metadata MetricValueMetadata, valueHolder interface{}) MetricValue <span class="cov1" title="1">{
        return nullFloat64MetricValue{
                metadata: metadata,
                value:    *valueHolder.(*spanner.NullFloat64),
        }
}</span>

func NewMetricValueMetadata(name string, columnName string, dataType MetricType, unit string,
        valueType ValueType) (MetricValueMetadata, error) <span class="cov8" title="48">{

        var newMetricValueFunc newMetricValueFunction
        var valueHolderFunc valueHolderFunction

        switch valueType </span>{
        case IntValueType:<span class="cov7" title="23">
                newMetricValueFunc = newInt64MetricValue
                valueHolderFunc = func() interface{} </span><span class="cov4" title="6">{
                        var valueHolder int64
                        return &amp;valueHolder
                }</span>
        case FloatValueType:<span class="cov6" title="21">
                newMetricValueFunc = newFloat64MetricValue
                valueHolderFunc = func() interface{} </span><span class="cov3" title="3">{
                        var valueHolder float64
                        return &amp;valueHolder
                }</span>
        case NullFloatValueType:<span class="cov3" title="3">
                newMetricValueFunc = newNullFloat64MetricValue
                valueHolderFunc = func() interface{} </span><span class="cov1" title="1">{
                        var valueHolder spanner.NullFloat64
                        return &amp;valueHolder
                }</span>
        case UnknownValueType, StringValueType, BoolValueType, StringSliceValueType, ByteSliceValueType, LockRequestSliceValueType:<span class="cov1" title="1">
                fallthrough</span>
        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("invalid value type received for metric value %q", name)</span>
        }

        <span class="cov8" title="47">return queryMetricValueMetadata{
                name:               name,
                columnName:         columnName,
                dataType:           dataType,
                unit:               unit,
                valueType:          valueType,
                newMetricValueFunc: newMetricValueFunc,
                valueHolderFunc:    valueHolderFunc,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package metadataparser // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadataparser"

import (
        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata"
)

type Label struct {
        Name       string             `yaml:"name"`
        ColumnName string             `yaml:"column_name"`
        ValueType  metadata.ValueType `yaml:"value_type"`
}

func (label Label) toLabelValueMetadata() (metadata.LabelValueMetadata, error) <span class="cov10" title="15">{
        return metadata.NewLabelValueMetadata(label.Name, label.ColumnName, label.ValueType)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package metadataparser // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadataparser"

import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata"

type Metadata struct {
        Name                string   `yaml:"name"`
        Query               string   `yaml:"query"`
        MetricNamePrefix    string   `yaml:"metric_name_prefix"`
        TimestampColumnName string   `yaml:"timestamp_column_name"`
        HighCardinality     bool     `yaml:"high_cardinality"`
        Labels              []Label  `yaml:"labels"`
        Metrics             []Metric `yaml:"metrics"`
}

func (m Metadata) MetricsMetadata() (*metadata.MetricsMetadata, error) <span class="cov8" title="6">{
        queryLabelValuesMetadata, err := m.toLabelValuesMetadata()
        if err != nil </span><span class="cov4" title="2">{
                return nil, err
        }</span>

        <span class="cov7" title="4">queryMetricValuesMetadata, err := m.toMetricValuesMetadata()
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov5" title="3">return &amp;metadata.MetricsMetadata{
                Name:                      m.Name,
                Query:                     m.Query,
                MetricNamePrefix:          m.MetricNamePrefix,
                TimestampColumnName:       m.TimestampColumnName,
                HighCardinality:           m.HighCardinality,
                QueryLabelValuesMetadata:  queryLabelValuesMetadata,
                QueryMetricValuesMetadata: queryMetricValuesMetadata,
        }, nil</span>
}

func (m Metadata) toLabelValuesMetadata() ([]metadata.LabelValueMetadata, error) <span class="cov10" title="8">{
        valuesMetadata := make([]metadata.LabelValueMetadata, len(m.Labels))

        for i, label := range m.Labels </span><span class="cov10" title="8">{
                value, err := label.toLabelValueMetadata()
                if err != nil </span><span class="cov5" title="3">{
                        return nil, err
                }</span>

                <span class="cov7" title="5">valuesMetadata[i] = value</span>
        }

        <span class="cov7" title="5">return valuesMetadata, nil</span>
}

func (m Metadata) toMetricValuesMetadata() ([]metadata.MetricValueMetadata, error) <span class="cov8" title="6">{
        valuesMetadata := make([]metadata.MetricValueMetadata, len(m.Metrics))
        for i, metric := range m.Metrics </span><span class="cov8" title="6">{
                value, err := metric.toMetricValueMetadata()
                if err != nil </span><span class="cov4" title="2">{
                        return nil, err
                }</span>

                <span class="cov7" title="4">valuesMetadata[i] = value</span>
        }

        <span class="cov7" title="4">return valuesMetadata, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package metadataparser // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadataparser"

import (
        "gopkg.in/yaml.v3"

        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata"
)

func ParseMetadataConfig(metadataContentYaml []byte) ([]*metadata.MetricsMetadata, error) <span class="cov10" title="3">{
        var config MetadataConfig

        err := yaml.Unmarshal(metadataContentYaml, &amp;config)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov6" title="2">result := make([]*metadata.MetricsMetadata, len(config.Metadata))

        for i, parsedMetadata := range config.Metadata </span><span class="cov10" title="3">{
                mData, err := parsedMetadata.MetricsMetadata()
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>

                <span class="cov6" title="2">result[i] = mData</span>
        }

        <span class="cov1" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package metadataparser // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadataparser"

import (
        "fmt"

        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata"
)

type Metric struct {
        Label    `yaml:",inline"`
        DataType MetricType `yaml:"data"`
        Unit     string     `yaml:"unit"`
}

func (metric Metric) toMetricValueMetadata() (metadata.MetricValueMetadata, error) <span class="cov10" title="14">{
        dataType, err := metric.DataType.toMetricType()
        if err != nil </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("invalid value data type received for metric %q", metric.Name)
        }</span>

        <span class="cov9" title="12">return metadata.NewMetricValueMetadata(metric.Name, metric.ColumnName, dataType, metric.Unit, metric.ValueType)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package metadataparser // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadataparser"

import (
        "errors"

        "go.opentelemetry.io/collector/pdata/pmetric"

        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata"
)

type MetricDataType string

const (
        UnknownMetricDataType MetricDataType = "unknown"
        GaugeMetricDataType   MetricDataType = "gauge"
        SumMetricDataType     MetricDataType = "sum"
)

type AggregationType string

const (
        UnknownAggregationType    AggregationType = "unknown"
        DeltaAggregationType      AggregationType = "delta"
        CumulativeAggregationType AggregationType = "cumulative"
)

type MetricType struct {
        DataType    MetricDataType  `yaml:"type"`
        Aggregation AggregationType `yaml:"aggregation"`
        Monotonic   bool            `yaml:"monotonic"`
}

func (metricType MetricType) dataType() (pmetric.MetricType, error) <span class="cov10" title="20">{
        var dataType pmetric.MetricType

        switch metricType.DataType </span>{
        case GaugeMetricDataType:<span class="cov8" title="12">
                dataType = pmetric.MetricTypeGauge</span>
        case SumMetricDataType:<span class="cov5" title="4">
                dataType = pmetric.MetricTypeSum</span>
        case UnknownMetricDataType:<span class="cov4" title="3">
                fallthrough</span>
        default:<span class="cov5" title="4">
                return pmetric.MetricTypeEmpty, errors.New("invalid data type received")</span>
        }

        <span class="cov9" title="16">return dataType, nil</span>
}

func (metricType MetricType) aggregationTemporality() (pmetric.AggregationTemporality, error) <span class="cov9" title="18">{
        var aggregationTemporality pmetric.AggregationTemporality

        switch metricType.Aggregation </span>{
        case DeltaAggregationType:<span class="cov5" title="4">
                aggregationTemporality = pmetric.AggregationTemporalityDelta</span>
        case CumulativeAggregationType:<span class="cov3" title="2">
                aggregationTemporality = pmetric.AggregationTemporalityCumulative</span>
        case "":<span class="cov7" title="10">
                aggregationTemporality = pmetric.AggregationTemporalityUnspecified</span>
        case UnknownAggregationType:<span class="cov1" title="1">
                fallthrough</span>
        default:<span class="cov3" title="2">
                return pmetric.AggregationTemporalityUnspecified, errors.New("invalid aggregation temporality received")</span>
        }

        <span class="cov9" title="16">return aggregationTemporality, nil</span>
}

func (metricType MetricType) toMetricType() (metadata.MetricType, error) <span class="cov9" title="17">{
        dataType, err := metricType.dataType()
        if err != nil </span><span class="cov4" title="3">{
                return nil, err
        }</span>

        <span class="cov8" title="14">aggregationTemporality, err := metricType.aggregationTemporality()
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="13">return metadata.NewMetricType(dataType, aggregationTemporality, metricType.Monotonic), nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package statsreader // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/statsreader"

import (
        "context"
        "errors"
        "fmt"
        "time"

        "cloud.google.com/go/spanner"
        "go.uber.org/zap"
        "google.golang.org/api/iterator"

        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/datasource"
        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata"
)

const (
        dataStalenessSeconds = 15
        dataStalenessPeriod  = dataStalenessSeconds * time.Second

        // Data reads for backfilling are always performed from stale replica nodes and not from the master.
        // For current/fresh data reads main node is used. But in case collector started for example at mm:30+ it is safe
        // to read data from stale replica nodes(at this time replica node will contain required data), since we are
        // requesting data for mm:00. Also stale reads are faster than reads from main node.
        dataStalenessSafeThresholdSeconds = 2 * dataStalenessSeconds
)

type currentStatsReader struct {
        logger                 *zap.Logger
        database               *datasource.Database
        metricsMetadata        *metadata.MetricsMetadata
        topMetricsQueryMaxRows int
        statement              func(args statementArgs) statsStatement
}

func newCurrentStatsReader(
        logger *zap.Logger,
        database *datasource.Database,
        metricsMetadata *metadata.MetricsMetadata,
        config ReaderConfig) *currentStatsReader <span class="cov10" title="2">{

        return &amp;currentStatsReader{
                logger:                 logger,
                database:               database,
                metricsMetadata:        metricsMetadata,
                statement:              currentStatsStatement,
                topMetricsQueryMaxRows: config.TopMetricsQueryMaxRows,
        }
}</span>

func (reader *currentStatsReader) Name() string <span class="cov10" title="2">{
        return fmt.Sprintf("%v %v::%v::%v", reader.metricsMetadata.Name, reader.database.DatabaseID().ProjectID(),
                reader.database.DatabaseID().InstanceID(), reader.database.DatabaseID().DatabaseName())
}</span>

func (reader *currentStatsReader) Read(ctx context.Context) ([]*metadata.MetricsDataPoint, error) <span class="cov0" title="0">{
        reader.logger.Debug("Executing read method", zap.String("reader", reader.Name()))

        stmt := reader.newPullStatement()

        return reader.pull(ctx, stmt)
}</span>

func (reader *currentStatsReader) newPullStatement() statsStatement <span class="cov1" title="1">{
        args := statementArgs{
                query:                  reader.metricsMetadata.Query,
                topMetricsQueryMaxRows: reader.topMetricsQueryMaxRows,
        }

        return reader.statement(args)
}</span>

func (reader *currentStatsReader) pull(ctx context.Context, stmt statsStatement) ([]*metadata.MetricsDataPoint, error) <span class="cov0" title="0">{
        transaction := reader.database.Client().Single()
        if stmt.stalenessRead || isSafeToUseStaleRead(time.Now().UTC()) </span><span class="cov0" title="0">{
                transaction = transaction.WithTimestampBound(spanner.ExactStaleness(dataStalenessPeriod))
        }</span>
        <span class="cov0" title="0">rowsIterator := transaction.Query(ctx, stmt.statement)
        defer rowsIterator.Stop()

        var collectedDataPoints []*metadata.MetricsDataPoint

        for </span><span class="cov0" title="0">{
                row, err := rowsIterator.Next()
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, iterator.Done) </span><span class="cov0" title="0">{
                                return collectedDataPoints, nil
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("query %q failed with error: %w", stmt.statement.SQL, err)</span>
                }

                <span class="cov0" title="0">rowMetricsDataPoints, err := reader.metricsMetadata.RowToMetricsDataPoints(reader.database.DatabaseID(), row)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("query %q failed with error: %w", stmt.statement.SQL, err)
                }</span>

                <span class="cov0" title="0">collectedDataPoints = append(collectedDataPoints, rowMetricsDataPoints...)</span>
        }
}

func isSafeToUseStaleRead(readTimestamp time.Time) bool <span class="cov10" title="2">{
        return (readTimestamp.Second() - dataStalenessSafeThresholdSeconds) &gt;= 0
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package statsreader // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/statsreader"

import (
        "context"
        "fmt"

        "go.opentelemetry.io/collector/receiver/scrapererror"
        "go.uber.org/multierr"
        "go.uber.org/zap"

        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/datasource"
        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata"
)

type DatabaseReader struct {
        database *datasource.Database
        logger   *zap.Logger
        readers  []Reader
}

func NewDatabaseReader(ctx context.Context,
        parsedMetadata []*metadata.MetricsMetadata,
        databaseID *datasource.DatabaseID,
        serviceAccountPath string,
        readerConfig ReaderConfig,
        logger *zap.Logger) (*DatabaseReader, error) <span class="cov4" title="2">{

        database, err := datasource.NewDatabase(ctx, databaseID, serviceAccountPath)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("error occurred during client instantiation for database %q: %w", databaseID.ID(), err)
        }</span>

        <span class="cov1" title="1">readers := initializeReaders(logger, parsedMetadata, database, readerConfig)

        return &amp;DatabaseReader{
                database: database,
                logger:   logger,
                readers:  readers,
        }, nil</span>
}

func initializeReaders(logger *zap.Logger, parsedMetadata []*metadata.MetricsMetadata,
        database *datasource.Database, readerConfig ReaderConfig) []Reader <span class="cov4" title="2">{
        readers := make([]Reader, len(parsedMetadata))

        for i, mData := range parsedMetadata </span><span class="cov4" title="2">{
                switch mData.MetadataType() </span>{
                case metadata.MetricsMetadataTypeCurrentStats:<span class="cov1" title="1">
                        readers[i] = newCurrentStatsReader(logger, database, mData, readerConfig)</span>
                case metadata.MetricsMetadataTypeIntervalStats:<span class="cov1" title="1">
                        readers[i] = newIntervalStatsReader(logger, database, mData, readerConfig)</span>
                }
        }

        <span class="cov4" title="2">return readers</span>
}

func (databaseReader *DatabaseReader) Name() string <span class="cov1" title="1">{
        return databaseReader.database.DatabaseID().ID()
}</span>

func (databaseReader *DatabaseReader) Shutdown() <span class="cov10" title="5">{
        databaseReader.logger.Debug("Closing connection to database",
                zap.String("database", databaseReader.database.DatabaseID().ID()))
        databaseReader.database.Client().Close()
}</span>

func (databaseReader *DatabaseReader) Read(ctx context.Context) ([]*metadata.MetricsDataPoint, error) <span class="cov4" title="2">{
        databaseReader.logger.Debug("Executing read method for database",
                zap.String("database", databaseReader.database.DatabaseID().ID()))

        var (
                result []*metadata.MetricsDataPoint
                err    error
        )

        for _, reader := range databaseReader.readers </span><span class="cov4" title="2">{
                dataPoints, lastErr := reader.Read(ctx)
                if lastErr != nil </span><span class="cov1" title="1">{
                        err = multierr.Append(err, fmt.Errorf("cannot read data for data points databaseReader %q because of an error: %w",
                                reader.Name(), lastErr))
                }</span> else<span class="cov1" title="1"> {
                        result = append(result, dataPoints...)
                }</span>
        }

        <span class="cov4" title="2">if len(result) &gt; 0 &amp;&amp; err != nil </span><span class="cov0" title="0">{
                err = scrapererror.NewPartialScrapeError(err, len(multierr.Errors(err)))
        }</span>

        <span class="cov4" title="2">return result, err</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package statsreader // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/statsreader"

import (
        "context"
        "time"

        "go.uber.org/zap"

        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/datasource"
        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata"
)

const (
        // Max duration of data backfilling(if enabled).
        // Different backends can support or not support such option.
        // Since, the initial intent was to work mainly with Prometheus backend,
        // this constant was set to 1 hour - max allowed interval by Prometheus.
        backfillIntervalDuration = time.Hour
        topLockStatsMetricName   = "top minute lock stats"
        topQueryStatsMetricName  = "top minute query stats"
        maxLengthTruncateText    = 1024
)

type intervalStatsReader struct {
        currentStatsReader
        timestampsGenerator               *timestampsGenerator
        lastPullTimestamp                 time.Time
        hideTopnLockstatsRowrangestartkey bool
        truncateText                      bool
}

func newIntervalStatsReader(
        logger *zap.Logger,
        database *datasource.Database,
        metricsMetadata *metadata.MetricsMetadata,
        config ReaderConfig) *intervalStatsReader <span class="cov10" title="3">{

        reader := currentStatsReader{
                logger:                 logger,
                database:               database,
                metricsMetadata:        metricsMetadata,
                statement:              intervalStatsStatement,
                topMetricsQueryMaxRows: config.TopMetricsQueryMaxRows,
        }
        tsGenerator := &amp;timestampsGenerator{
                backfillEnabled: config.BackfillEnabled,
                difference:      time.Minute,
        }

        return &amp;intervalStatsReader{
                currentStatsReader:                reader,
                timestampsGenerator:               tsGenerator,
                hideTopnLockstatsRowrangestartkey: config.HideTopnLockstatsRowrangestartkey,
                truncateText:                      config.TruncateText,
        }
}</span>

func (reader *intervalStatsReader) Read(ctx context.Context) ([]*metadata.MetricsDataPoint, error) <span class="cov0" title="0">{
        reader.logger.Debug("Executing read method", zap.String("reader", reader.Name()))

        // Generating pull timestamps
        pullTimestamps := reader.timestampsGenerator.pullTimestamps(reader.lastPullTimestamp, time.Now().UTC())

        var collectedDataPoints []*metadata.MetricsDataPoint

        // Pulling metrics for each generated pull timestamp
        timestampsAmount := len(pullTimestamps)
        for i, pullTimestamp := range pullTimestamps </span><span class="cov0" title="0">{
                stmt := reader.newPullStatement(pullTimestamp)
                // Latest timestamp for backfilling must be read from actual data(not stale)
                if i == (timestampsAmount-1) &amp;&amp; reader.isBackfillExecution() </span><span class="cov0" title="0">{
                        stmt.stalenessRead = false
                }</span>
                <span class="cov0" title="0">dataPoints, err := reader.pull(ctx, stmt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">metricMetadata := reader.currentStatsReader.metricsMetadata
                if reader.hideTopnLockstatsRowrangestartkey &amp;&amp; metricMetadata != nil &amp;&amp; metricMetadata.Name == topLockStatsMetricName </span><span class="cov0" title="0">{
                        for _, dataPoint := range dataPoints </span><span class="cov0" title="0">{
                                dataPoint.HideLockStatsRowrangestartkeyPII()
                        }</span>
                }
                <span class="cov0" title="0">if reader.truncateText &amp;&amp; metricMetadata != nil &amp;&amp; metricMetadata.Name == topQueryStatsMetricName </span><span class="cov0" title="0">{
                        for _, dataPoint := range dataPoints </span><span class="cov0" title="0">{
                                dataPoint.TruncateQueryText(maxLengthTruncateText)
                        }</span>
                }

                <span class="cov0" title="0">collectedDataPoints = append(collectedDataPoints, dataPoints...)</span>
        }

        <span class="cov0" title="0">reader.lastPullTimestamp = pullTimestamps[timestampsAmount-1]

        return collectedDataPoints, nil</span>
}

func (reader *intervalStatsReader) newPullStatement(pullTimestamp time.Time) statsStatement <span class="cov1" title="1">{
        args := statementArgs{
                query:                  reader.metricsMetadata.Query,
                topMetricsQueryMaxRows: reader.topMetricsQueryMaxRows,
                pullTimestamp:          pullTimestamp,
                stalenessRead:          reader.isBackfillExecution(),
        }

        return reader.statement(args)
}</span>

func (reader *intervalStatsReader) isBackfillExecution() bool <span class="cov1" title="1">{
        return reader.timestampsGenerator.isBackfillExecution(reader.lastPullTimestamp)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package statsreader // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/statsreader"

import (
        "context"
        "strings"

        "go.opentelemetry.io/collector/receiver/scrapererror"
        "go.uber.org/multierr"
        "go.uber.org/zap"

        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata"
)

type ProjectReader struct {
        databaseReaders []CompositeReader
        logger          *zap.Logger
}

func NewProjectReader(databaseReaders []CompositeReader, logger *zap.Logger) *ProjectReader <span class="cov1" title="1">{
        return &amp;ProjectReader{
                databaseReaders: databaseReaders,
                logger:          logger,
        }
}</span>

func (projectReader *ProjectReader) Shutdown() <span class="cov10" title="5">{
        for _, databaseReader := range projectReader.databaseReaders </span><span class="cov8" title="4">{
                projectReader.logger.Info("Shutting down projectReader for database",
                        zap.String("database", databaseReader.Name()))
                databaseReader.Shutdown()
        }</span>
}

func (projectReader *ProjectReader) Read(ctx context.Context) ([]*metadata.MetricsDataPoint, error) <span class="cov4" title="2">{
        var (
                result []*metadata.MetricsDataPoint
                err    error
        )

        for _, databaseReader := range projectReader.databaseReaders </span><span class="cov4" title="2">{
                dataPoints, readErr := databaseReader.Read(ctx)
                err = multierr.Append(err, readErr)
                if readErr == nil </span><span class="cov1" title="1">{
                        result = append(result, dataPoints...)
                }</span>
        }

        <span class="cov4" title="2">if len(result) &gt; 0 &amp;&amp; err != nil </span><span class="cov0" title="0">{
                err = scrapererror.NewPartialScrapeError(err, len(multierr.Errors(err)))
        }</span>

        <span class="cov4" title="2">return result, err</span>
}

func (projectReader *ProjectReader) Name() string <span class="cov1" title="1">{
        databaseReaderNames := make([]string, len(projectReader.databaseReaders))

        for i, databaseReader := range projectReader.databaseReaders </span><span class="cov1" title="1">{
                databaseReaderNames[i] = databaseReader.Name()
        }</span>

        <span class="cov1" title="1">return "Project reader for: " + strings.Join(databaseReaderNames, ",")</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package statsreader // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/statsreader"

import (
        "time"

        "cloud.google.com/go/spanner"
)

const (
        topMetricsQueryLimitParameterName = "topMetricsQueryMaxRows"
        topMetricsQueryLimitCondition     = " LIMIT @" + topMetricsQueryLimitParameterName

        pullTimestampParameterName = "pullTimestamp"
)

type statementArgs struct {
        query                  string
        topMetricsQueryMaxRows int
        pullTimestamp          time.Time
        stalenessRead          bool
}

type statsStatement struct {
        statement     spanner.Statement
        stalenessRead bool
}

func currentStatsStatement(args statementArgs) statsStatement <span class="cov10" title="6">{
        stmt := spanner.Statement{SQL: args.query, Params: map[string]interface{}{}}

        if args.topMetricsQueryMaxRows &gt; 0 </span><span class="cov7" title="4">{
                stmt = spanner.Statement{
                        SQL: args.query + topMetricsQueryLimitCondition,
                        Params: map[string]interface{}{
                                topMetricsQueryLimitParameterName: args.topMetricsQueryMaxRows,
                        },
                }
        }</span>

        <span class="cov10" title="6">return statsStatement{
                statement:     stmt,
                stalenessRead: args.stalenessRead,
        }</span>
}

func intervalStatsStatement(args statementArgs) statsStatement <span class="cov6" title="3">{
        stmt := currentStatsStatement(args)

        if len(stmt.statement.Params) == 0 </span><span class="cov1" title="1">{
                stmt.statement.Params = map[string]interface{}{}
        }</span>

        <span class="cov6" title="3">stmt.statement.Params[pullTimestampParameterName] = args.pullTimestamp

        return stmt</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package statsreader // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/statsreader"

import "time"

type timestampsGenerator struct {
        backfillEnabled bool
        difference      time.Duration
}

// This slice will always contain at least one value - now shifted to the start of minute(upper bound).
// In case lastPullTimestamp is greater than now argument slice will contain only one value - now shifted to the start of minute(upper bound).
func (g *timestampsGenerator) pullTimestamps(lastPullTimestamp time.Time, now time.Time) []time.Time <span class="cov4" title="7">{
        var timestamps []time.Time
        upperBound := shiftToStartOfMinute(now)

        if lastPullTimestamp.IsZero() </span><span class="cov2" title="2">{
                if g.backfillEnabled </span><span class="cov1" title="1">{
                        timestamps = pullTimestampsWithDifference(upperBound.Add(-1*backfillIntervalDuration), upperBound,
                                g.difference)
                }</span> else<span class="cov1" title="1"> {
                        timestamps = []time.Time{upperBound}
                }</span>
        } else<span class="cov3" title="5"> {
                // lastPullTimestamp is already set to start of minute
                timestamps = pullTimestampsWithDifference(lastPullTimestamp, upperBound, g.difference)
        }</span>

        <span class="cov4" title="7">return timestamps</span>
}

// This slice will always contain at least one value(upper bound).
// Difference between each two points is 1 minute.
func pullTimestampsWithDifference(lowerBound time.Time, upperBound time.Time, difference time.Duration) []time.Time <span class="cov4" title="8">{
        var timestamps []time.Time

        for value := lowerBound.Add(difference); !value.After(upperBound); value = value.Add(difference) </span><span class="cov10" title="190">{
                timestamps = append(timestamps, value)
        }</span>

        // To ensure that we did not miss upper bound and timestamps slice will contain at least one value
        <span class="cov4" title="8">if len(timestamps) == 0 || timestamps[len(timestamps)-1] != upperBound </span><span class="cov3" title="5">{
                timestamps = append(timestamps, upperBound)
        }</span>

        <span class="cov4" title="8">return timestamps</span>
}

func shiftToStartOfMinute(now time.Time) time.Time <span class="cov4" title="9">{
        return time.Date(now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), 0, 0, now.Location())
}</span>

func (g *timestampsGenerator) isBackfillExecution(lastPullTimestamp time.Time) bool <span class="cov3" title="5">{
        return lastPullTimestamp.IsZero() &amp;&amp; g.backfillEnabled
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package googlecloudspannerreceiver // import "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver"

import (
        "context"
        _ "embed"
        "fmt"

        "go.opentelemetry.io/collector/component"
        "go.opentelemetry.io/collector/pdata/pmetric"
        "go.opentelemetry.io/collector/receiver"
        "go.opentelemetry.io/collector/receiver/scrapererror"
        "go.uber.org/multierr"
        "go.uber.org/zap"

        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/datasource"
        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/filterfactory"
        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadata"
        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/metadataparser"
        "github.com/open-telemetry/opentelemetry-collector-contrib/receiver/googlecloudspannerreceiver/internal/statsreader"
)

//go:embed "internal/metadataconfig/metrics.yaml"
var metadataYaml []byte

var _ receiver.Metrics = (*googleCloudSpannerReceiver)(nil)

type googleCloudSpannerReceiver struct {
        logger         *zap.Logger
        config         *Config
        cancel         context.CancelFunc
        projectReaders []statsreader.CompositeReader
        metricsBuilder metadata.MetricsBuilder
}

func newGoogleCloudSpannerReceiver(logger *zap.Logger, config *Config) *googleCloudSpannerReceiver <span class="cov10" title="15">{
        return &amp;googleCloudSpannerReceiver{
                logger: logger,
                config: config,
        }
}</span>

func (r *googleCloudSpannerReceiver) Scrape(ctx context.Context) (pmetric.Metrics, error) <span class="cov3" title="2">{
        var (
                allMetricsDataPoints []*metadata.MetricsDataPoint
                err                  error
        )

        for _, projectReader := range r.projectReaders </span><span class="cov3" title="2">{
                dataPoints, readErr := projectReader.Read(ctx)
                err = multierr.Append(err, readErr)
                if err == nil </span><span class="cov1" title="1">{
                        allMetricsDataPoints = append(allMetricsDataPoints, dataPoints...)
                }</span>
        }

        <span class="cov3" title="2">result, buildErr := r.metricsBuilder.Build(allMetricsDataPoints)

        if buildErr != nil </span><span class="cov0" title="0">{
                err = multierr.Append(err, buildErr)
        }</span>

        <span class="cov3" title="2">if result.MetricCount() &gt; 0 &amp;&amp; err != nil </span><span class="cov0" title="0">{
                err = scrapererror.NewPartialScrapeError(err, len(multierr.Errors(err)))
        }</span>

        <span class="cov3" title="2">return result, err</span>
}

func (r *googleCloudSpannerReceiver) Start(ctx context.Context, _ component.Host) error <span class="cov3" title="2">{
        ctx, r.cancel = context.WithCancel(ctx)
        err := r.initialize(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (r *googleCloudSpannerReceiver) Shutdown(context.Context) error <span class="cov3" title="2">{
        for _, projectReader := range r.projectReaders </span><span class="cov3" title="2">{
                projectReader.Shutdown()
        }</span>

        <span class="cov3" title="2">if r.metricsBuilder == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov3" title="2">err := r.metricsBuilder.Shutdown()
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov1" title="1">r.cancel()

        return nil</span>
}

func (r *googleCloudSpannerReceiver) initialize(ctx context.Context) error <span class="cov6" title="5">{
        parsedMetadata, err := metadataparser.ParseMetadataConfig(metadataYaml)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("error occurred during parsing of metadata: %w", err)
        }</span>

        <span class="cov5" title="4">err = r.initializeProjectReaders(ctx, parsedMetadata)
        if err != nil </span><span class="cov3" title="2">{
                return err
        }</span>

        <span class="cov3" title="2">return r.initializeMetricsBuilder(parsedMetadata)</span>
}

func (r *googleCloudSpannerReceiver) initializeProjectReaders(ctx context.Context,
        parsedMetadata []*metadata.MetricsMetadata) error <span class="cov7" title="7">{

        readerConfig := statsreader.ReaderConfig{
                BackfillEnabled:                   r.config.BackfillEnabled,
                TopMetricsQueryMaxRows:            r.config.TopMetricsQueryMaxRows,
                HideTopnLockstatsRowrangestartkey: r.config.HideTopnLockstatsRowrangestartkey,
                TruncateText:                      r.config.TruncateText,
        }

        for _, project := range r.config.Projects </span><span class="cov7" title="7">{
                projectReader, err := newProjectReader(ctx, r.logger, project, parsedMetadata, readerConfig)
                if err != nil </span><span class="cov5" title="4">{
                        return err
                }</span>

                <span class="cov4" title="3">r.projectReaders = append(r.projectReaders, projectReader)</span>
        }

        <span class="cov4" title="3">return nil</span>
}

func (r *googleCloudSpannerReceiver) initializeMetricsBuilder(parsedMetadata []*metadata.MetricsMetadata) error <span class="cov5" title="4">{
        r.logger.Debug("Constructing metrics builder")

        projectAmount := len(r.config.Projects)
        instanceAmount := 0
        databaseAmount := 0

        for _, project := range r.config.Projects </span><span class="cov5" title="4">{
                instanceAmount += len(project.Instances)

                for _, instance := range project.Instances </span><span class="cov5" title="4">{
                        databaseAmount += len(instance.Databases)
                }</span>
        }

        <span class="cov5" title="4">factoryConfig := &amp;filterfactory.ItemFilterFactoryConfig{
                MetadataItems:  parsedMetadata,
                TotalLimit:     r.config.CardinalityTotalLimit,
                ProjectAmount:  projectAmount,
                InstanceAmount: instanceAmount,
                DatabaseAmount: databaseAmount,
        }
        itemFilterResolver, err := filterfactory.NewItemFilterResolver(r.logger, factoryConfig)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov4" title="3">r.metricsBuilder = metadata.NewMetricsFromDataPointBuilder(itemFilterResolver)

        return nil</span>
}

func newProjectReader(ctx context.Context, logger *zap.Logger, project Project, parsedMetadata []*metadata.MetricsMetadata,
        readerConfig statsreader.ReaderConfig) (*statsreader.ProjectReader, error) <span class="cov8" title="9">{
        logger.Debug("Constructing project reader for project", zap.String("project id", project.ID))

        databaseReadersCount := 0
        for _, instance := range project.Instances </span><span class="cov8" title="9">{
                databaseReadersCount += len(instance.Databases)
        }</span>

        <span class="cov8" title="9">databaseReaders := make([]statsreader.CompositeReader, databaseReadersCount)
        databaseReaderIndex := 0
        for _, instance := range project.Instances </span><span class="cov8" title="9">{
                for _, database := range instance.Databases </span><span class="cov8" title="9">{
                        logger.Debug("Constructing database reader for combination of project, instance, database",
                                zap.String("project id", project.ID), zap.String("instance id", instance.ID), zap.String("database", database))

                        databaseID := datasource.NewDatabaseID(project.ID, instance.ID, database)

                        databaseReader, err := statsreader.NewDatabaseReader(ctx, parsedMetadata, databaseID,
                                project.ServiceAccountKey, readerConfig, logger)
                        if err != nil </span><span class="cov6" title="5">{
                                return nil, err
                        }</span>

                        <span class="cov5" title="4">databaseReaders[databaseReaderIndex] = databaseReader
                        databaseReaderIndex++</span>
                }
        }

        <span class="cov5" title="4">return statsreader.NewProjectReader(databaseReaders, logger), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
