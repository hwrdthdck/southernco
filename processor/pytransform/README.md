# pytransform

<!-- status autogenerated section -->
| Status        |           |
| ------------- |-----------|
| Stability     | [alpha]: traces, metrics, logs   |


[beta]: https://github.com/open-telemetry/opentelemetry-collector#beta
[sumo]: https://github.com/SumoLogic/sumologic-otel-collector
<!-- end autogenerated section -->


The pytransform processor modifies telemetry based on configuration using Python code.

The processor leverages an embedded python version that has access to core python functionality and __does not__ require python be installed on the host. By leveraging Python code to modify telemetry, you have access to the full power of the Python language to modify data.

## Config

To configure pytransform, you add your code using the `code` option in the config. Each instance of pytransform can only have a single code section. 


```yaml
processors:
  pytransform:
    code: |
      {your python code}
```


## How it works

The python language is embedded to the Open Telemetry binary, this allows you to run this processor without having python installed on the host itself. 

This design is based on Embedded Python for Go Project found [here](https://github.com/kluctl/go-embed-python).

When a python transform is executed, a controlled subprocess is called using the embedded python implementation that calls the user code. 

### Python Runtime and Helper Fucntions

The pytransform processor sends the metric, trace or log events to the python runtime by setting the env variable `INPUT`. You do not need to read this environment variable, pytransform adds helper functions to handle this automatically.

When a telemetry event is initialised in python, the event data will be accessible under the variable `event`. For example, the code below would print the event received from open telemetry.

```yaml
processors:
  pytransform:
    code: |
      print(event)
```

#### send()

You are able to modify this event using python code, however you choose. This can be in the form of functions, classes, regex using the python [re](https://docs.python.org/3/library/re.html) library, etc. It is import however, to maintain the structure of the event as the modified event needs to be returned to the pytransform processor. Events can be returned using another helper function, `send`.

For example, the config below adds a resource attribute to the telemetry event and returns it to the pytransform processor. 

```yaml
processors:
  pytransform/logs:
    code: |
      # edit resource attributes
      for data in event['resourceLogs']:
        for attr in data['resource']['attributes']:
          attr['value']['stringValue'] = 'source.log'

      send(event)
```

Note the use of the `send` function at the end of the code. If the event is not passed back to the processor using send, this will result in an error and the input event will be passed as unchanged.

```log
pytransform/logprocessor.go:54	python script returned empty output, returning record unchanged	{"kind": "processor", "name": "pytransform/test", "pipeline": "logs"}
```


#### print()

The `print` function in the pytransform Python runtime is overwritten with a special function that sends strings to the pytransform processor. These strings are then printed using the internal Open Telemetry logger. 

For example, take the following config:

```yaml
processors:
  pytransform:
    code: |
      print('hello world')
      send(event)
```

This results in a log line appearing in the Open Telemetry process:

```log
2023-09-16T18:00:21.551+0200	info	pytransform/pytransform.go:45	hello world	{"kind": "processor", "name": "pytransform/test", "pipeline": "logs", "src": "python.print()"}
```

The is useful for debugging python code.

### Timeout

There are a number of things that are possible running python within the Open Telemetry workflow, as such, to protect the runtime and host from long running zombie processes in python, each python invokation has a **maximum timeout of 1500ms**

The goal is to encourage using this processor solely for complex telemetry transformations rather than long running tasks.


## Examples

This section contains examples of the event payloads that are sent to the pytransform processor python runtime from each telemetry type. These examples can help you understand the structure of the telemetry events and how to modify them.

##### Log Event Payload Example:

```json
{
	"resourceLogs": [{
		"resource": {
			"attributes": [{
				"key": "log.file.name",
				"value": {
					"stringValue": "test.log"
				}
			}]
		},
		"scopeLogs": [{
			"scope": {},
			"logRecords": [{
				"observedTimeUnixNano": "1694127596456358000",
				"body": {
					"stringValue": "2023-09-06T01:09:24.045+0200 INFO starting app.",
					"attributes": [{

						"key": "app",
						"value": {
							"stringValue": "dev"
						}
					}],
					"traceId": "",
					"spanId": ""
				}
			}]
		}]
	}]
}
```

View the the log.proto type definition [here](https://github.com/open-telemetry/opentelemetry-proto/blob/main/opentelemetry/proto/logs/v1/logs.proto)

##### Metric Event Payload Example:

```json
{
	"resourceMetrics": [{
		"resource": {},
		"scopeMetrics": [{
			"scope": {
				"name": "otelcol/hostmetricsreceiver/memory",
				"version": "0.84.0"
			},
			"metrics": [{
				"name": "system.memory.usage",
				"description": "Bytes of memory in use.",
				"unit": "By",
				"sum": {
					"dataPoints": [{
							"attributes": [{
								"key": "state",
								"value": {
									"stringValue": "used"
								}
							}],
							"startTimeUnixNano": "1694171569000000000",
							"timeUnixNano": "1694189699786689531",
							"asInt": "1874247680"
						},
						{
							"attributes": [{
								"key": "state",
								"value": {
									"stringValue": "free"
								}
							}],
							"startTimeUnixNano": "1694171569000000000",
							"timeUnixNano": "1694189699786689531",
							"asInt": "29214199808"
						}
					],
					"aggregationTemporality": 2
				}
			}]
		}],
		"schemaUrl": "https://opentelemetry.io/schemas/1.9.0"
	}]
} 
```
View the metric.proto type definition [here](https://github.com/open-telemetry/opentelemetry-proto/blob/main/opentelemetry/proto/metrics/v1/metrics.proto)

##### Trace Event Payload Example:

```json
{
	"resourceSpans": [{
		"resource": {
			"attributes": [{
					"key": "telemetry.sdk.language",
					"value": {
						"stringValue": "python"
					}
				},
				{
					"key": "telemetry.sdk.name",
					"value": {
						"stringValue": "opentelemetry"
					}
				},
				{
					"key": "telemetry.sdk.version",
					"value": {
						"stringValue": "1.19.0"
					}
				},
				{
					"key": "telemetry.auto.version",
					"value": {
						"stringValue": "0.40b0"
					}
				},
				{
					"key": "service.name",
					"value": {
						"stringValue": "unknown_service"
					}
				}
			]
		},
		"scopeSpans": [{
			"scope": {
				"name": "opentelemetry.instrumentation.flask",
				"version": "0.40b0"
			},
			"spans": [{
				"traceId": "9cb5bf738137b2248dc7b20445ec2e1c",
				"spanId": "88079ad5c94b5b13",
				"parentSpanId": "",
				"name": "/roll",
				"kind": 2,
				"startTimeUnixNano": "1694388218052842000",
				"endTimeUnixNano": "1694388218053415000",
				"attributes": [{
						"key": "http.method",
						"value": {
							"stringValue": "GET"
						}
					},
					{
						"key": "http.server_name",
						"value": {
							"stringValue": "0.0.0.0"
						}
					},
					{
						"key": "http.scheme",
						"value": {
							"stringValue": "http"
						}
					},
					{
						"key": "net.host.port",
						"value": {
							"intValue": "5001"
						}
					},
					{
						"key": "http.host",
						"value": {
							"stringValue": "localhost:5001"
						}
					},
					{
						"key": "http.target",
						"value": {
							"stringValue": "/roll"
						}
					},
					{
						"key": "net.peer.ip",
						"value": {
							"stringValue": "127.0.0.1"
						}
					},
					{
						"key": "http.user_agent",
						"value": {
							"stringValue": "curl/7.87.0"
						}
					},
					{
						"key": "net.peer.port",
						"value": {
							"intValue": "52365"
						}
					},
					{
						"key": "http.flavor",
						"value": {
							"stringValue": "1.1"
						}
					},
					{
						"key": "http.route",
						"value": {
							"stringValue": "/roll"
						}
					},
					{
						"key": "http.status_code",
						"value": {
							"intValue": "200"
						}
					}
				],
				"status": {}
			}]
		}]
	}]
}
```

View the trace.proto type definition [here](https://github.com/open-telemetry/opentelemetry-proto/blob/main/opentelemetry/proto/trace/v1/trace.proto).


## Full Configuration Example

For following configuration example demonstrates the pytransform processor telemetry events for logs, metrics and traces.

```yaml
receivers:
  otlp:
    protocols:
      http:
        endpoint: "0.0.0.0:4318"
      grpc:
        endpoint: "0.0.0.0:4317"

  filelog:
    start_at: beginning
    include_file_name: true
    include: 
      - $LOGFILE

    operators:
      - type: move
        from: attributes["log.file.name"]
        to: resource["log.file.name"]

      - type: add
        field: attributes.app
        value: dev

processors:

  # - change resource attribute log.file.name to source.log
  # - add resource attribute cluster: dev
  # - filter out any logs that contain the word password
  # - add an attribute to each log: language: golang
  pytransform/logs:
    code: |
      # edit resource attributes
      for data in event['resourceLogs']:
        for attr in [
            attr for attr in data['resource']['attributes']
            if attr['key'] == 'log.file.name'
        ]:
          attr['value']['stringValue'] = 'source.log'

        # add resource attribute
        data['resource']['attributes'].append({
          'key': 'cluser',
          'value': {
            'stringValue': 'dev'
          }
        })


      # filter/delete logs
      for data in event['resourceLogs']:
        for slog in  data['scopeLogs']:
          slog['logRecords'] = [ lr for lr in slog['logRecords'] if 'password' not in lr['body']['stringValue']]
          
          # add an attribute to each log
          for lr in slog['logRecords']:
            lr['attributes'].append({
              'key': 'language',
              'value': {
                'stringValue': 'golang'
              }})
              
      send(event)

  # - print event received to otel runtime log
  # - if there are no resources, add a resource attribute source pytransform
  # - prefix each metric name with pytransform
  pytransform/metrics:
    code: |
      print("received event")
      for md in event['resourceMetrics']:
        # if resources are empty
        if not md['resource']:
          md['resource'] = {
            'attributes': [
              {
                "key": "source",
                "value": {
                  "stringValue": "pytransform"
                }
              }
            ]
          }

        # prefix each metric name with pytransform
        for sm in md['scopeMetrics']:
          for m in sm['metrics']:
            m['name'] = 'pytransform.' + m['name']

      send(event)

  # - add resource attribute source pytransform
  # - filter out any spans with http.target /roll attribute
  pytransform/traces:
    code: |
      for td in event['resourceSpans']:
        # add resource attribute
        td['resource']['attributes'].append({
          'key': 'source',
          'value': {
            'stringValue': 'pytransform'
          }
        })

        # filter spans with http.target /roll attribute
        has_roll_attr = lambda attrs: [a for a in attrs if a['key'] == 'http.target' and a['value']['stringValue'] == '/roll']
        for sd in td['scopeSpans']:
          sd['spans'] = [
            s for s in sd['spans']
            if not has_roll_attr(s['attributes'])
          ]

      send(event)
exporters:
  logging:
    verbosity: detailed


service:
  pipelines:
    logs:
      receivers:
      - filelog
      processors:
      - pytransform/logs
      exporters:
      - logging

    metrics:
      receivers:
      - otlp
      processors:
      - pytransform/metrics
      exporters:
      - logging

    traces:
      receivers:
      - otlp
      processors:
      - pytransform/traces
      exporters:
      - logging
```

### Warnings

The Pytransform processor allows you to modify all aspects of you telemetry data. This can result in invalid or bad data being propogated if you are not careful. It is your responsibility to inspect the data and ensure it is valid.